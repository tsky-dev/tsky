/* eslint-disable */
// This file is automatically generated by @tsky/lex-cli, do not edit!

/**
 * @module
 * Contains type declarations for Bluesky lexicons
 */

type ObjectOmit<T, K extends keyof any> = Omit<T, K>;

/** Handles type branding in objects */
export declare namespace Brand {
  /** Symbol used to brand objects, this does not actually exist in runtime */
  const Type: unique symbol;

  /** Get the intended `$type` field */
  type GetType<T extends { [Type]: string }> = T[typeof Type];

  /** Creates a union of objects where it's discriminated by `$type` field. */
  type Union<T extends { [Type]: string }> = T extends any
    ? T & { $type: GetType<T> }
    : never;

  /** Omits the type branding from object */
  type Omit<T extends { [Type]: string }> = ObjectOmit<T, typeof Type>;
}

/** Base AT Protocol schema types */
export declare namespace At {
  /** CID string */
  type CID = string;

  /** DID of a user */
  type DID = `did:${string}`;

  /** User handle */
  type Handle = string;

  /** URI string */
  type Uri = string;

  /** Object containing a CID string */
  interface CIDLink {
    $link: CID;
  }

  /** Object containing a base64-encoded bytes */
  interface Bytes {
    $bytes: string;
  }

  /** Blob interface */
  interface Blob<T extends string = string> {
    $type: "blob";
    mimeType: T;
    ref: {
      $link: string;
    };
    size: number;
  }
}
export declare namespace AppBskyActorDefs {
  interface AdultContentPref {
    [Brand.Type]: "app.bsky.actor.defs#adultContentPref";
    /** \@default false */
    enabled: boolean;
  }
  /** If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress. */
  interface BskyAppProgressGuide {
    [Brand.Type]: "app.bsky.actor.defs#bskyAppProgressGuide";
    /** Maximum string length: 100 */
    guide: string;
  }
  /** A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this. */
  interface BskyAppStatePref {
    [Brand.Type]: "app.bsky.actor.defs#bskyAppStatePref";
    activeProgressGuide?: BskyAppProgressGuide;
    /**
     * Storage for NUXs the user has encountered.
     * Maximum array length: 100
     */
    nuxs?: AppBskyActorDefs.Nux[];
    /**
     * An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.
     * Maximum array length: 1000
     * Maximum string length: 100
     */
    queuedNudges?: string[];
  }
  interface ContentLabelPref {
    [Brand.Type]: "app.bsky.actor.defs#contentLabelPref";
    label: string;
    visibility: "hide" | "ignore" | "show" | "warn" | (string & {});
    /** Which labeler does this preference apply to? If undefined, applies globally. */
    labelerDid?: At.DID;
  }
  interface FeedViewPref {
    [Brand.Type]: "app.bsky.actor.defs#feedViewPref";
    /** The URI of the feed, or an identifier which describes the feed. */
    feed: string;
    /** Hide quote posts in the feed. */
    hideQuotePosts?: boolean;
    /** Hide replies in the feed. */
    hideReplies?: boolean;
    /** Hide replies in the feed if they do not have this number of likes. */
    hideRepliesByLikeCount?: number;
    /**
     * Hide replies in the feed if they are not by followed users.
     * \@default true
     */
    hideRepliesByUnfollowed?: boolean;
    /** Hide reposts in the feed. */
    hideReposts?: boolean;
  }
  interface HiddenPostsPref {
    [Brand.Type]: "app.bsky.actor.defs#hiddenPostsPref";
    /** A list of URIs of posts the account owner has hidden. */
    items: At.Uri[];
  }
  interface InterestsPref {
    [Brand.Type]: "app.bsky.actor.defs#interestsPref";
    /**
     * A list of tags which describe the account owner's interests gathered during onboarding.
     * Maximum array length: 100
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tags: string[];
  }
  /** The subject's followers whom you also follow */
  interface KnownFollowers {
    [Brand.Type]: "app.bsky.actor.defs#knownFollowers";
    count: number;
    /**
     * Minimum array length: 0
     * Maximum array length: 5
     */
    followers: ProfileViewBasic[];
  }
  interface LabelerPrefItem {
    [Brand.Type]: "app.bsky.actor.defs#labelerPrefItem";
    did: At.DID;
  }
  interface LabelersPref {
    [Brand.Type]: "app.bsky.actor.defs#labelersPref";
    labelers: LabelerPrefItem[];
  }
  /** A word that the account owner has muted. */
  interface MutedWord {
    [Brand.Type]: "app.bsky.actor.defs#mutedWord";
    /** The intended targets of the muted word. */
    targets: AppBskyActorDefs.MutedWordTarget[];
    /**
     * The muted word itself.
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    value: string;
    /**
     * Groups of users to apply the muted word to. If undefined, applies to all users.
     * \@default "all"
     */
    actorTarget?: "all" | "exclude-following" | (string & {});
    /** The date and time at which the muted word will expire and no longer be applied. */
    expiresAt?: string;
    id?: string;
  }
  interface MutedWordsPref {
    [Brand.Type]: "app.bsky.actor.defs#mutedWordsPref";
    /** A list of words the account owner has muted. */
    items: AppBskyActorDefs.MutedWord[];
  }
  /**
   * Maximum string length: 640
   * Maximum grapheme length: 64
   */
  type MutedWordTarget = "content" | "tag" | (string & {});
  /** A new user experiences (NUX) storage object */
  interface Nux {
    [Brand.Type]: "app.bsky.actor.defs#nux";
    /** \@default false */
    completed: boolean;
    /** Maximum string length: 100 */
    id: string;
    /**
     * Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    data?: string;
    /** The date and time at which the NUX will expire and should be considered completed. */
    expiresAt?: string;
  }
  interface PersonalDetailsPref {
    [Brand.Type]: "app.bsky.actor.defs#personalDetailsPref";
    /** The birth date of account owner. */
    birthDate?: string;
  }
  type Preferences = Brand.Union<
    | AdultContentPref
    | BskyAppStatePref
    | ContentLabelPref
    | FeedViewPref
    | HiddenPostsPref
    | InterestsPref
    | LabelersPref
    | MutedWordsPref
    | PersonalDetailsPref
    | SavedFeedsPref
    | SavedFeedsPrefV2
    | ThreadViewPref
  >[];
  interface ProfileAssociated {
    [Brand.Type]: "app.bsky.actor.defs#profileAssociated";
    chat?: ProfileAssociatedChat;
    feedgens?: number;
    labeler?: boolean;
    lists?: number;
    starterPacks?: number;
  }
  interface ProfileAssociatedChat {
    [Brand.Type]: "app.bsky.actor.defs#profileAssociatedChat";
    allowIncoming: "all" | "following" | "none" | (string & {});
  }
  interface ProfileView {
    [Brand.Type]: "app.bsky.actor.defs#profileView";
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    createdAt?: string;
    /**
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    indexedAt?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    viewer?: ViewerState;
  }
  interface ProfileViewBasic {
    [Brand.Type]: "app.bsky.actor.defs#profileViewBasic";
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    createdAt?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    viewer?: ViewerState;
  }
  interface ProfileViewDetailed {
    [Brand.Type]: "app.bsky.actor.defs#profileViewDetailed";
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    banner?: string;
    createdAt?: string;
    /**
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    followersCount?: number;
    followsCount?: number;
    indexedAt?: string;
    joinedViaStarterPack?: AppBskyGraphDefs.StarterPackViewBasic;
    labels?: ComAtprotoLabelDefs.Label[];
    pinnedPost?: ComAtprotoRepoStrongRef.Main;
    postsCount?: number;
    viewer?: ViewerState;
  }
  interface SavedFeed {
    [Brand.Type]: "app.bsky.actor.defs#savedFeed";
    id: string;
    pinned: boolean;
    type: "feed" | "list" | "timeline" | (string & {});
    value: string;
  }
  interface SavedFeedsPref {
    [Brand.Type]: "app.bsky.actor.defs#savedFeedsPref";
    pinned: At.Uri[];
    saved: At.Uri[];
    timelineIndex?: number;
  }
  interface SavedFeedsPrefV2 {
    [Brand.Type]: "app.bsky.actor.defs#savedFeedsPrefV2";
    items: AppBskyActorDefs.SavedFeed[];
  }
  interface ThreadViewPref {
    [Brand.Type]: "app.bsky.actor.defs#threadViewPref";
    /** Show followed users at the top of all replies. */
    prioritizeFollowedUsers?: boolean;
    /** Sorting mode for threads. */
    sort?:
      | "hotness"
      | "most-likes"
      | "newest"
      | "oldest"
      | "random"
      | (string & {});
  }
  /** Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests. */
  interface ViewerState {
    [Brand.Type]: "app.bsky.actor.defs#viewerState";
    blockedBy?: boolean;
    blocking?: At.Uri;
    blockingByList?: AppBskyGraphDefs.ListViewBasic;
    followedBy?: At.Uri;
    following?: At.Uri;
    knownFollowers?: KnownFollowers;
    muted?: boolean;
    mutedByList?: AppBskyGraphDefs.ListViewBasic;
  }
}

/** Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth. */
export declare namespace AppBskyActorGetPreferences {
  type Input = undefined;
  interface Output {
    preferences: AppBskyActorDefs.Preferences;
  }
}

/** Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth. */
export declare namespace AppBskyActorGetProfile {
  interface Params {
    /** Handle or DID of account to fetch profile of. */
    actor: string;
  }
  type Input = undefined;
  type Output = AppBskyActorDefs.ProfileViewDetailed;
}

/** Get detailed profile views of multiple actors. */
export declare namespace AppBskyActorGetProfiles {
  interface Params {
    /** Maximum array length: 25 */
    actors: string[];
  }
  type Input = undefined;
  interface Output {
    profiles: AppBskyActorDefs.ProfileViewDetailed[];
  }
}

/** Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding. */
export declare namespace AppBskyActorGetSuggestions {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    actors: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

export declare namespace AppBskyActorProfile {
  /** A declaration of a Bluesky account profile. */
  interface Record {
    $type: "app.bsky.actor.profile";
    /** Small image to be displayed next to posts from account. AKA, 'profile picture' */
    avatar?: At.Blob;
    /** Larger horizontal image to display behind profile view. */
    banner?: At.Blob;
    createdAt?: string;
    /**
     * Free-form profile description text.
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    joinedViaStarterPack?: ComAtprotoRepoStrongRef.Main;
    /** Self-label values, specific to the Bluesky application, on the overall account. */
    labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
    pinnedPost?: ComAtprotoRepoStrongRef.Main;
  }
}

/** Set the private preferences attached to the account. */
export declare namespace AppBskyActorPutPreferences {
  interface Params {}
  interface Input {
    preferences: AppBskyActorDefs.Preferences;
  }
  type Output = undefined;
}

/** Find actors (profiles) matching search criteria. Does not require auth. */
export declare namespace AppBskyActorSearchActors {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q?: string;
    /**
     * DEPRECATED: use 'q' instead.
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output {
    actors: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth. */
export declare namespace AppBskyActorSearchActorsTypeahead {
  interface Params {
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 10
     */
    limit?: number;
    /** Search query prefix; not a full query string. */
    q?: string;
    /**
     * DEPRECATED: use 'q' instead.
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output {
    actors: AppBskyActorDefs.ProfileViewBasic[];
  }
}

export declare namespace AppBskyEmbedDefs {
  /** width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit. */
  interface AspectRatio {
    [Brand.Type]: "app.bsky.embed.defs#aspectRatio";
    /** Minimum: 1 */
    height: number;
    /** Minimum: 1 */
    width: number;
  }
}

export declare namespace AppBskyEmbedExternal {
  /** A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post). */
  interface Main {
    [Brand.Type]: "app.bsky.embed.external";
    external: External;
  }
  interface External {
    [Brand.Type]: "app.bsky.embed.external#external";
    description: string;
    title: string;
    uri: string;
    thumb?: At.Blob;
  }
  interface View {
    [Brand.Type]: "app.bsky.embed.external#view";
    external: ViewExternal;
  }
  interface ViewExternal {
    [Brand.Type]: "app.bsky.embed.external#viewExternal";
    description: string;
    title: string;
    uri: string;
    thumb?: string;
  }
}

export declare namespace AppBskyEmbedImages {
  interface Main {
    [Brand.Type]: "app.bsky.embed.images";
    /** Maximum array length: 4 */
    images: Image[];
  }
  interface Image {
    [Brand.Type]: "app.bsky.embed.images#image";
    /** Alt text description of the image, for accessibility. */
    alt: string;
    image: At.Blob;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
  }
  interface View {
    [Brand.Type]: "app.bsky.embed.images#view";
    /** Maximum array length: 4 */
    images: ViewImage[];
  }
  interface ViewImage {
    [Brand.Type]: "app.bsky.embed.images#viewImage";
    /** Alt text description of the image, for accessibility. */
    alt: string;
    /** Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View. */
    fullsize: string;
    /** Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View. */
    thumb: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
  }
}

export declare namespace AppBskyEmbedRecord {
  interface Main {
    [Brand.Type]: "app.bsky.embed.record";
    record: ComAtprotoRepoStrongRef.Main;
  }
  interface View {
    [Brand.Type]: "app.bsky.embed.record#view";
    record: Brand.Union<
      | ViewBlocked
      | ViewDetached
      | ViewNotFound
      | ViewRecord
      | AppBskyFeedDefs.GeneratorView
      | AppBskyGraphDefs.ListView
      | AppBskyGraphDefs.StarterPackViewBasic
      | AppBskyLabelerDefs.LabelerView
    >;
  }
  interface ViewBlocked {
    [Brand.Type]: "app.bsky.embed.record#viewBlocked";
    author: AppBskyFeedDefs.BlockedAuthor;
    blocked: boolean;
    uri: At.Uri;
  }
  interface ViewDetached {
    [Brand.Type]: "app.bsky.embed.record#viewDetached";
    detached: boolean;
    uri: At.Uri;
  }
  interface ViewNotFound {
    [Brand.Type]: "app.bsky.embed.record#viewNotFound";
    notFound: boolean;
    uri: At.Uri;
  }
  interface ViewRecord {
    [Brand.Type]: "app.bsky.embed.record#viewRecord";
    author: AppBskyActorDefs.ProfileViewBasic;
    cid: At.CID;
    indexedAt: string;
    uri: At.Uri;
    /** The record data itself. */
    value: unknown;
    embeds?: Brand.Union<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedRecord.View
      | AppBskyEmbedRecordWithMedia.View
      | AppBskyEmbedVideo.View
    >[];
    labels?: ComAtprotoLabelDefs.Label[];
    likeCount?: number;
    quoteCount?: number;
    replyCount?: number;
    repostCount?: number;
  }
}

export declare namespace AppBskyEmbedRecordWithMedia {
  interface Main {
    [Brand.Type]: "app.bsky.embed.recordWithMedia";
    media: Brand.Union<
      | AppBskyEmbedExternal.Main
      | AppBskyEmbedImages.Main
      | AppBskyEmbedVideo.Main
    >;
    record: AppBskyEmbedRecord.Main;
  }
  interface View {
    [Brand.Type]: "app.bsky.embed.recordWithMedia#view";
    media: Brand.Union<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedVideo.View
    >;
    record: AppBskyEmbedRecord.View;
  }
}

export declare namespace AppBskyEmbedVideo {
  interface Main {
    [Brand.Type]: "app.bsky.embed.video";
    video: At.Blob;
    /**
     * Alt text description of the video, for accessibility.
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    alt?: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
    /** Maximum array length: 20 */
    captions?: Caption[];
  }
  interface Caption {
    [Brand.Type]: "app.bsky.embed.video#caption";
    file: At.Blob;
    lang: string;
  }
  interface View {
    [Brand.Type]: "app.bsky.embed.video#view";
    cid: At.CID;
    playlist: string;
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    alt?: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
    thumbnail?: string;
  }
}

export declare namespace AppBskyFeedDefs {
  interface BlockedAuthor {
    [Brand.Type]: "app.bsky.feed.defs#blockedAuthor";
    did: At.DID;
    viewer?: AppBskyActorDefs.ViewerState;
  }
  interface BlockedPost {
    [Brand.Type]: "app.bsky.feed.defs#blockedPost";
    author: BlockedAuthor;
    blocked: boolean;
    uri: At.Uri;
  }
  type ClickthroughAuthor = "app.bsky.feed.defs#clickthroughAuthor";
  type ClickthroughEmbed = "app.bsky.feed.defs#clickthroughEmbed";
  type ClickthroughItem = "app.bsky.feed.defs#clickthroughItem";
  type ClickthroughReposter = "app.bsky.feed.defs#clickthroughReposter";
  interface FeedViewPost {
    [Brand.Type]: "app.bsky.feed.defs#feedViewPost";
    post: PostView;
    /**
     * Context provided by feed generator that may be passed back alongside interactions.
     * Maximum string length: 2000
     */
    feedContext?: string;
    reason?: Brand.Union<ReasonPin | ReasonRepost>;
    reply?: ReplyRef;
  }
  interface GeneratorView {
    [Brand.Type]: "app.bsky.feed.defs#generatorView";
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    did: At.DID;
    displayName: string;
    indexedAt: string;
    uri: At.Uri;
    acceptsInteractions?: boolean;
    avatar?: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: GeneratorViewerState;
  }
  interface GeneratorViewerState {
    [Brand.Type]: "app.bsky.feed.defs#generatorViewerState";
    like?: At.Uri;
  }
  interface Interaction {
    [Brand.Type]: "app.bsky.feed.defs#interaction";
    event?:
      | "app.bsky.feed.defs#clickthroughAuthor"
      | "app.bsky.feed.defs#clickthroughEmbed"
      | "app.bsky.feed.defs#clickthroughItem"
      | "app.bsky.feed.defs#clickthroughReposter"
      | "app.bsky.feed.defs#interactionLike"
      | "app.bsky.feed.defs#interactionQuote"
      | "app.bsky.feed.defs#interactionReply"
      | "app.bsky.feed.defs#interactionRepost"
      | "app.bsky.feed.defs#interactionSeen"
      | "app.bsky.feed.defs#interactionShare"
      | "app.bsky.feed.defs#requestLess"
      | "app.bsky.feed.defs#requestMore"
      | (string & {});
    /**
     * Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.
     * Maximum string length: 2000
     */
    feedContext?: string;
    item?: At.Uri;
  }
  type InteractionLike = "app.bsky.feed.defs#interactionLike";
  type InteractionQuote = "app.bsky.feed.defs#interactionQuote";
  type InteractionReply = "app.bsky.feed.defs#interactionReply";
  type InteractionRepost = "app.bsky.feed.defs#interactionRepost";
  type InteractionSeen = "app.bsky.feed.defs#interactionSeen";
  type InteractionShare = "app.bsky.feed.defs#interactionShare";
  interface NotFoundPost {
    [Brand.Type]: "app.bsky.feed.defs#notFoundPost";
    notFound: boolean;
    uri: At.Uri;
  }
  interface PostView {
    [Brand.Type]: "app.bsky.feed.defs#postView";
    author: AppBskyActorDefs.ProfileViewBasic;
    cid: At.CID;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    embed?: Brand.Union<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedRecord.View
      | AppBskyEmbedRecordWithMedia.View
      | AppBskyEmbedVideo.View
    >;
    labels?: ComAtprotoLabelDefs.Label[];
    likeCount?: number;
    quoteCount?: number;
    replyCount?: number;
    repostCount?: number;
    threadgate?: ThreadgateView;
    viewer?: ViewerState;
  }
  interface ReasonPin {
    [Brand.Type]: "app.bsky.feed.defs#reasonPin";
  }
  interface ReasonRepost {
    [Brand.Type]: "app.bsky.feed.defs#reasonRepost";
    by: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
  }
  interface ReplyRef {
    [Brand.Type]: "app.bsky.feed.defs#replyRef";
    parent: Brand.Union<BlockedPost | NotFoundPost | PostView>;
    root: Brand.Union<BlockedPost | NotFoundPost | PostView>;
    /** When parent is a reply to another post, this is the author of that post. */
    grandparentAuthor?: AppBskyActorDefs.ProfileViewBasic;
  }
  type RequestLess = "app.bsky.feed.defs#requestLess";
  type RequestMore = "app.bsky.feed.defs#requestMore";
  interface SkeletonFeedPost {
    [Brand.Type]: "app.bsky.feed.defs#skeletonFeedPost";
    post: At.Uri;
    /**
     * Context that will be passed through to client and may be passed to feed generator back alongside interactions.
     * Maximum string length: 2000
     */
    feedContext?: string;
    reason?: Brand.Union<SkeletonReasonPin | SkeletonReasonRepost>;
  }
  interface SkeletonReasonPin {
    [Brand.Type]: "app.bsky.feed.defs#skeletonReasonPin";
  }
  interface SkeletonReasonRepost {
    [Brand.Type]: "app.bsky.feed.defs#skeletonReasonRepost";
    repost: At.Uri;
  }
  interface ThreadgateView {
    [Brand.Type]: "app.bsky.feed.defs#threadgateView";
    cid?: At.CID;
    lists?: AppBskyGraphDefs.ListViewBasic[];
    record?: unknown;
    uri?: At.Uri;
  }
  interface ThreadViewPost {
    [Brand.Type]: "app.bsky.feed.defs#threadViewPost";
    post: PostView;
    parent?: Brand.Union<BlockedPost | NotFoundPost | ThreadViewPost>;
    replies?: Brand.Union<BlockedPost | NotFoundPost | ThreadViewPost>[];
  }
  /** Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests. */
  interface ViewerState {
    [Brand.Type]: "app.bsky.feed.defs#viewerState";
    embeddingDisabled?: boolean;
    like?: At.Uri;
    pinned?: boolean;
    replyDisabled?: boolean;
    repost?: At.Uri;
    threadMuted?: boolean;
  }
}

/** Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View). */
export declare namespace AppBskyFeedDescribeFeedGenerator {
  interface Params {}
  type Input = undefined;
  interface Output {
    did: At.DID;
    feeds: Feed[];
    links?: Links;
  }
  interface Feed {
    [Brand.Type]: "app.bsky.feed.describeFeedGenerator#feed";
    uri: At.Uri;
  }
  interface Links {
    [Brand.Type]: "app.bsky.feed.describeFeedGenerator#links";
    privacyPolicy?: string;
    termsOfService?: string;
  }
}

export declare namespace AppBskyFeedGenerator {
  /** Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository. */
  interface Record {
    $type: "app.bsky.feed.generator";
    createdAt: string;
    did: At.DID;
    /**
     * Maximum string length: 240
     * Maximum grapheme length: 24
     */
    displayName: string;
    /** Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions */
    acceptsInteractions?: boolean;
    avatar?: At.Blob;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    /** Self-label values */
    labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
  }
}

/** Get a list of feeds (feed generator records) created by the actor (in the actor's repo). */
export declare namespace AppBskyFeedGetActorFeeds {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a list of posts liked by an actor. Requires auth, actor must be the requesting account. */
export declare namespace AppBskyFeedGetActorLikes {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors {
    BlockedActor: {};
    BlockedByActor: {};
  }
}

/** Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth. */
export declare namespace AppBskyFeedGetAuthorFeed {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Combinations of post/repost types to include in response.
     * \@default "posts_with_replies"
     */
    filter?:
      | "posts_and_author_threads"
      | "posts_no_replies"
      | "posts_with_media"
      | "posts_with_replies"
      | (string & {});
    /** \@default false */
    includePins?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors {
    BlockedActor: {};
    BlockedByActor: {};
  }
}

/** Get a hydrated feed from an actor's selected feed generator. Implemented by App View. */
export declare namespace AppBskyFeedGetFeed {
  interface Params {
    feed: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors {
    UnknownFeed: {};
  }
}

/** Get information about a feed generator. Implemented by AppView. */
export declare namespace AppBskyFeedGetFeedGenerator {
  interface Params {
    /** AT-URI of the feed generator record. */
    feed: At.Uri;
  }
  type Input = undefined;
  interface Output {
    /** Indicates whether the feed generator service has been online recently, or else seems to be inactive. */
    isOnline: boolean;
    /** Indicates whether the feed generator service is compatible with the record declaration. */
    isValid: boolean;
    view: AppBskyFeedDefs.GeneratorView;
  }
}

/** Get information about a list of feed generators. */
export declare namespace AppBskyFeedGetFeedGenerators {
  interface Params {
    feeds: At.Uri[];
  }
  type Input = undefined;
  interface Output {
    feeds: AppBskyFeedDefs.GeneratorView[];
  }
}

/** Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service. */
export declare namespace AppBskyFeedGetFeedSkeleton {
  interface Params {
    /** Reference to feed generator record describing the specific feed being requested. */
    feed: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feed: AppBskyFeedDefs.SkeletonFeedPost[];
    cursor?: string;
  }
  interface Errors {
    UnknownFeed: {};
  }
}

/** Get like records which reference a subject (by AT-URI and CID). */
export declare namespace AppBskyFeedGetLikes {
  interface Params {
    /** AT-URI of the subject (eg, a post record). */
    uri: At.Uri;
    /** CID of the subject record (aka, specific version of record), to filter likes. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    likes: Like[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
  interface Like {
    [Brand.Type]: "app.bsky.feed.getLikes#like";
    actor: AppBskyActorDefs.ProfileView;
    createdAt: string;
    indexedAt: string;
  }
}

/** Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth. */
export declare namespace AppBskyFeedGetListFeed {
  interface Params {
    /** Reference (AT-URI) to the list record. */
    list: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors {
    UnknownList: {};
  }
}

/** Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'. */
export declare namespace AppBskyFeedGetPosts {
  interface Params {
    /**
     * List of post AT-URIs to return hydrated views for.
     * Maximum array length: 25
     */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output {
    posts: AppBskyFeedDefs.PostView[];
  }
}

/** Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests. */
export declare namespace AppBskyFeedGetPostThread {
  interface Params {
    /** Reference (AT-URI) to post record. */
    uri: At.Uri;
    /**
     * How many levels of reply depth should be included in response.
     * Minimum: 0
     * Maximum: 1000
     * \@default 6
     */
    depth?: number;
    /**
     * How many levels of parent (and grandparent, etc) post to include.
     * Minimum: 0
     * Maximum: 1000
     * \@default 80
     */
    parentHeight?: number;
  }
  type Input = undefined;
  interface Output {
    thread: Brand.Union<
      | AppBskyFeedDefs.BlockedPost
      | AppBskyFeedDefs.NotFoundPost
      | AppBskyFeedDefs.ThreadViewPost
    >;
    threadgate?: AppBskyFeedDefs.ThreadgateView;
  }
  interface Errors {
    NotFound: {};
  }
}

/** Get a list of quotes for a given post. */
export declare namespace AppBskyFeedGetQuotes {
  interface Params {
    /** Reference (AT-URI) of post record */
    uri: At.Uri;
    /** If supplied, filters to quotes of specific version (by CID) of the post record. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    posts: AppBskyFeedDefs.PostView[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
}

/** Get a list of reposts for a given post. */
export declare namespace AppBskyFeedGetRepostedBy {
  interface Params {
    /** Reference (AT-URI) of post record */
    uri: At.Uri;
    /** If supplied, filters to reposts of specific version (by CID) of the post record. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    repostedBy: AppBskyActorDefs.ProfileView[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
}

/** Get a list of suggested feeds (feed generators) for the requesting account. */
export declare namespace AppBskyFeedGetSuggestedFeeds {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed. */
export declare namespace AppBskyFeedGetTimeline {
  interface Params {
    /** Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism. */
    algorithm?: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
}

export declare namespace AppBskyFeedLike {
  /** Record declaring a 'like' of a piece of subject content. */
  interface Record {
    $type: "app.bsky.feed.like";
    createdAt: string;
    subject: ComAtprotoRepoStrongRef.Main;
  }
}

export declare namespace AppBskyFeedPost {
  /** Record containing a Bluesky post. */
  interface Record {
    $type: "app.bsky.feed.post";
    /** Client-declared timestamp when this post was originally created. */
    createdAt: string;
    /**
     * The primary post content. May be an empty string, if there are embeds.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    text: string;
    embed?: Brand.Union<
      | AppBskyEmbedExternal.Main
      | AppBskyEmbedImages.Main
      | AppBskyEmbedRecord.Main
      | AppBskyEmbedRecordWithMedia.Main
      | AppBskyEmbedVideo.Main
    >;
    /**
     * DEPRECATED: replaced by app.bsky.richtext.facet.
     * \@deprecated
     */
    entities?: Entity[];
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
    /** Self-label values for this post. Effectively content warnings. */
    labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
    /**
     * Indicates human language of post primary text content.
     * Maximum array length: 3
     */
    langs?: string[];
    reply?: ReplyRef;
    /**
     * Additional hashtags, in addition to any included in post text and facets.
     * Maximum array length: 8
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tags?: string[];
  }
  /**
   * Deprecated: use facets instead.
   * \@deprecated
   */
  interface Entity {
    [Brand.Type]: "app.bsky.feed.post#entity";
    index: TextSlice;
    /** Expected values are 'mention' and 'link'. */
    type: string;
    value: string;
  }
  interface ReplyRef {
    [Brand.Type]: "app.bsky.feed.post#replyRef";
    parent: ComAtprotoRepoStrongRef.Main;
    root: ComAtprotoRepoStrongRef.Main;
  }
  /**
   * Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.
   * \@deprecated
   */
  interface TextSlice {
    [Brand.Type]: "app.bsky.feed.post#textSlice";
    /** Minimum: 0 */
    end: number;
    /** Minimum: 0 */
    start: number;
  }
}

export declare namespace AppBskyFeedPostgate {
  /** Record defining interaction rules for a post. The record key (rkey) of the postgate record must match the record key of the post, and that record must be in the same repository. */
  interface Record {
    $type: "app.bsky.feed.postgate";
    createdAt: string;
    /** Reference (AT-URI) to the post record. */
    post: At.Uri;
    /**
     * List of AT-URIs embedding this post that the author has detached from.
     * Maximum array length: 50
     */
    detachedEmbeddingUris?: At.Uri[];
    /** Maximum array length: 5 */
    embeddingRules?: Brand.Union<DisableRule>[];
  }
  /** Disables embedding of this post. */
  interface DisableRule {
    [Brand.Type]: "app.bsky.feed.postgate#disableRule";
  }
}

export declare namespace AppBskyFeedRepost {
  /** Record representing a 'repost' of an existing Bluesky post. */
  interface Record {
    $type: "app.bsky.feed.repost";
    createdAt: string;
    subject: ComAtprotoRepoStrongRef.Main;
  }
}

/** Find posts matching search criteria, returning views of those posts. */
export declare namespace AppBskyFeedSearchPosts {
  interface Params {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Filter to posts by the given account. Handles are resolved to DID before query-time. */
    author?: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /** Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization. */
    domain?: string;
    /** Filter to posts in the given language. Expected to be based on post language field, though server may override language detection. */
    lang?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions. */
    mentions?: string;
    /** Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD). */
    since?: string;
    /**
     * Specifies the ranking order of results.
     * \@default "latest"
     */
    sort?: "latest" | "top" | (string & {});
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag?: string[];
    /** Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD). */
    until?: string;
    /** Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching. */
    url?: string;
  }
  type Input = undefined;
  interface Output {
    posts: AppBskyFeedDefs.PostView[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors {
    BadQueryString: {};
  }
}

/** Send information about interactions with feed items back to the feed generator that served them. */
export declare namespace AppBskyFeedSendInteractions {
  interface Params {}
  interface Input {
    interactions: AppBskyFeedDefs.Interaction[];
  }
  interface Output {}
}

export declare namespace AppBskyFeedThreadgate {
  /** Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository. */
  interface Record {
    $type: "app.bsky.feed.threadgate";
    createdAt: string;
    /** Reference (AT-URI) to the post record. */
    post: At.Uri;
    /** Maximum array length: 5 */
    allow?: Brand.Union<FollowingRule | ListRule | MentionRule>[];
    /**
     * List of hidden reply URIs.
     * Maximum array length: 50
     */
    hiddenReplies?: At.Uri[];
  }
  /** Allow replies from actors you follow. */
  interface FollowingRule {
    [Brand.Type]: "app.bsky.feed.threadgate#followingRule";
  }
  /** Allow replies from actors on a list. */
  interface ListRule {
    [Brand.Type]: "app.bsky.feed.threadgate#listRule";
    list: At.Uri;
  }
  /** Allow replies from actors mentioned in your post. */
  interface MentionRule {
    [Brand.Type]: "app.bsky.feed.threadgate#mentionRule";
  }
}

export declare namespace AppBskyGraphBlock {
  /** Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details. */
  interface Record {
    $type: "app.bsky.graph.block";
    createdAt: string;
    /** DID of the account to be blocked. */
    subject: At.DID;
  }
}

export declare namespace AppBskyGraphDefs {
  type Curatelist = "app.bsky.graph.defs#curatelist";
  interface ListItemView {
    [Brand.Type]: "app.bsky.graph.defs#listItemView";
    subject: AppBskyActorDefs.ProfileView;
    uri: At.Uri;
  }
  type ListPurpose =
    | "app.bsky.graph.defs#curatelist"
    | "app.bsky.graph.defs#modlist"
    | "app.bsky.graph.defs#referencelist"
    | (string & {});
  interface ListView {
    [Brand.Type]: "app.bsky.graph.defs#listView";
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    purpose: ListPurpose;
    uri: At.Uri;
    avatar?: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
    viewer?: ListViewerState;
  }
  interface ListViewBasic {
    [Brand.Type]: "app.bsky.graph.defs#listViewBasic";
    cid: At.CID;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    purpose: ListPurpose;
    uri: At.Uri;
    avatar?: string;
    indexedAt?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
    viewer?: ListViewerState;
  }
  interface ListViewerState {
    [Brand.Type]: "app.bsky.graph.defs#listViewerState";
    blocked?: At.Uri;
    muted?: boolean;
  }
  type Modlist = "app.bsky.graph.defs#modlist";
  /** indicates that a handle or DID could not be resolved */
  interface NotFoundActor {
    [Brand.Type]: "app.bsky.graph.defs#notFoundActor";
    actor: string;
    notFound: boolean;
  }
  type Referencelist = "app.bsky.graph.defs#referencelist";
  /** lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object) */
  interface Relationship {
    [Brand.Type]: "app.bsky.graph.defs#relationship";
    did: At.DID;
    /** if the actor is followed by this DID, contains the AT-URI of the follow record */
    followedBy?: At.Uri;
    /** if the actor follows this DID, this is the AT-URI of the follow record */
    following?: At.Uri;
  }
  interface StarterPackView {
    [Brand.Type]: "app.bsky.graph.defs#starterPackView";
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    /** Maximum array length: 3 */
    feeds?: AppBskyFeedDefs.GeneratorView[];
    /** Minimum: 0 */
    joinedAllTimeCount?: number;
    /** Minimum: 0 */
    joinedWeekCount?: number;
    labels?: ComAtprotoLabelDefs.Label[];
    list?: ListViewBasic;
    /** Maximum array length: 12 */
    listItemsSample?: ListItemView[];
  }
  interface StarterPackViewBasic {
    [Brand.Type]: "app.bsky.graph.defs#starterPackViewBasic";
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    /** Minimum: 0 */
    joinedAllTimeCount?: number;
    /** Minimum: 0 */
    joinedWeekCount?: number;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
  }
}

export declare namespace AppBskyGraphFollow {
  /** Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView. */
  interface Record {
    $type: "app.bsky.graph.follow";
    createdAt: string;
    subject: At.DID;
  }
}

/** Get a list of starter packs created by the actor. */
export declare namespace AppBskyGraphGetActorStarterPacks {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
    cursor?: string;
  }
}

/** Enumerates which accounts the requesting account is currently blocking. Requires auth. */
export declare namespace AppBskyGraphGetBlocks {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    blocks: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerates accounts which follow a specified account (actor). */
export declare namespace AppBskyGraphGetFollowers {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    followers: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Enumerates accounts which a specified account (actor) follows. */
export declare namespace AppBskyGraphGetFollows {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    follows: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Enumerates accounts which follow a specified account (actor) and are followed by the viewer. */
export declare namespace AppBskyGraphGetKnownFollowers {
  interface Params {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    followers: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Gets a 'view' (with additional context) of a specified list. */
export declare namespace AppBskyGraphGetList {
  interface Params {
    /** Reference (AT-URI) of the list record to hydrate. */
    list: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    items: AppBskyGraphDefs.ListItemView[];
    list: AppBskyGraphDefs.ListView;
    cursor?: string;
  }
}

/** Get mod lists that the requesting account (actor) is blocking. Requires auth. */
export declare namespace AppBskyGraphGetListBlocks {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetListMutes {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates the lists created by a specified account (actor). */
export declare namespace AppBskyGraphGetLists {
  interface Params {
    /** The account (actor) to enumerate lists from. */
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates accounts that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetMutes {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    mutes: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerates public relationships between one account, and a list of other accounts. Does not require auth. */
export declare namespace AppBskyGraphGetRelationships {
  interface Params {
    /** Primary account requesting relationships for. */
    actor: string;
    /**
     * List of 'other' accounts to be related back to the primary.
     * Maximum array length: 30
     */
    others?: string[];
  }
  type Input = undefined;
  interface Output {
    relationships: Brand.Union<
      AppBskyGraphDefs.NotFoundActor | AppBskyGraphDefs.Relationship
    >[];
    actor?: At.DID;
  }
  interface Errors {
    ActorNotFound: {};
  }
}

/** Gets a view of a starter pack. */
export declare namespace AppBskyGraphGetStarterPack {
  interface Params {
    /** Reference (AT-URI) of the starter pack record. */
    starterPack: At.Uri;
  }
  type Input = undefined;
  interface Output {
    starterPack: AppBskyGraphDefs.StarterPackView;
  }
}

/** Get views for a list of starter packs. */
export declare namespace AppBskyGraphGetStarterPacks {
  interface Params {
    /** Maximum array length: 25 */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
  }
}

/** Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account. */
export declare namespace AppBskyGraphGetSuggestedFollowsByActor {
  interface Params {
    actor: string;
  }
  type Input = undefined;
  interface Output {
    suggestions: AppBskyActorDefs.ProfileView[];
    /**
     * If true, response has fallen-back to generic results, and is not scoped using relativeToDid
     * \@default false
     */
    isFallback?: boolean;
  }
}

export declare namespace AppBskyGraphList {
  /** Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists. */
  interface Record {
    $type: "app.bsky.graph.list";
    createdAt: string;
    /**
     * Display name for list; can not be empty.
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    /** Defines the purpose of the list (aka, moderation-oriented or curration-oriented) */
    purpose: AppBskyGraphDefs.ListPurpose;
    avatar?: At.Blob;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
  }
}

export declare namespace AppBskyGraphListblock {
  /** Record representing a block relationship against an entire an entire list of accounts (actors). */
  interface Record {
    $type: "app.bsky.graph.listblock";
    createdAt: string;
    /** Reference (AT-URI) to the mod list record. */
    subject: At.Uri;
  }
}

export declare namespace AppBskyGraphListitem {
  /** Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records. */
  interface Record {
    $type: "app.bsky.graph.listitem";
    createdAt: string;
    /** Reference (AT-URI) to the list record (app.bsky.graph.list). */
    list: At.Uri;
    /** The account which is included on the list. */
    subject: At.DID;
  }
}

/** Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActor {
  interface Params {}
  interface Input {
    actor: string;
  }
  type Output = undefined;
}

/** Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActorList {
  interface Params {}
  interface Input {
    list: At.Uri;
  }
  type Output = undefined;
}

/** Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteThread {
  interface Params {}
  interface Input {
    root: At.Uri;
  }
  type Output = undefined;
}

/** Find starter packs matching search criteria. Does not require auth. */
export declare namespace AppBskyGraphSearchStarterPacks {
  interface Params {
    /** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
    cursor?: string;
  }
}

export declare namespace AppBskyGraphStarterpack {
  /** Record defining a starter pack of actors and feeds for new users. */
  interface Record {
    $type: "app.bsky.graph.starterpack";
    createdAt: string;
    /** Reference (AT-URI) to the list record. */
    list: At.Uri;
    /**
     * Display name for starter pack; can not be empty.
     * Minimum string length: 1
     * Maximum string length: 500
     * Maximum grapheme length: 50
     */
    name: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    /** Maximum array length: 3 */
    feeds?: FeedItem[];
  }
  interface FeedItem {
    [Brand.Type]: "app.bsky.graph.starterpack#feedItem";
    uri: At.Uri;
  }
}

/** Unmutes the specified account. Requires auth. */
export declare namespace AppBskyGraphUnmuteActor {
  interface Params {}
  interface Input {
    actor: string;
  }
  type Output = undefined;
}

/** Unmutes the specified list of accounts. Requires auth. */
export declare namespace AppBskyGraphUnmuteActorList {
  interface Params {}
  interface Input {
    list: At.Uri;
  }
  type Output = undefined;
}

/** Unmutes the specified thread. Requires auth. */
export declare namespace AppBskyGraphUnmuteThread {
  interface Params {}
  interface Input {
    root: At.Uri;
  }
  type Output = undefined;
}

export declare namespace AppBskyLabelerDefs {
  interface LabelerPolicies {
    [Brand.Type]: "app.bsky.labeler.defs#labelerPolicies";
    /** The label values which this labeler publishes. May include global or custom labels. */
    labelValues: ComAtprotoLabelDefs.LabelValue[];
    /** Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler. */
    labelValueDefinitions?: ComAtprotoLabelDefs.LabelValueDefinition[];
  }
  interface LabelerView {
    [Brand.Type]: "app.bsky.labeler.defs#labelerView";
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: LabelerViewerState;
  }
  interface LabelerViewDetailed {
    [Brand.Type]: "app.bsky.labeler.defs#labelerViewDetailed";
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    policies: AppBskyLabelerDefs.LabelerPolicies;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: LabelerViewerState;
  }
  interface LabelerViewerState {
    [Brand.Type]: "app.bsky.labeler.defs#labelerViewerState";
    like?: At.Uri;
  }
}

/** Get information about a list of labeler services. */
export declare namespace AppBskyLabelerGetServices {
  interface Params {
    dids: At.DID[];
    /** \@default false */
    detailed?: boolean;
  }
  type Input = undefined;
  interface Output {
    views: Brand.Union<
      AppBskyLabelerDefs.LabelerView | AppBskyLabelerDefs.LabelerViewDetailed
    >[];
  }
}

export declare namespace AppBskyLabelerService {
  /** A declaration of the existence of labeler service. */
  interface Record {
    $type: "app.bsky.labeler.service";
    createdAt: string;
    policies: AppBskyLabelerDefs.LabelerPolicies;
    labels?: Brand.Union<ComAtprotoLabelDefs.SelfLabels>;
  }
}

/** Count the number of unread notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationGetUnreadCount {
  interface Params {
    priority?: boolean;
    seenAt?: string;
  }
  type Input = undefined;
  interface Output {
    count: number;
  }
}

/** Enumerate notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationListNotifications {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    priority?: boolean;
    seenAt?: string;
  }
  type Input = undefined;
  interface Output {
    notifications: Notification[];
    cursor?: string;
    priority?: boolean;
    seenAt?: string;
  }
  interface Notification {
    [Brand.Type]: "app.bsky.notification.listNotifications#notification";
    author: AppBskyActorDefs.ProfileView;
    cid: At.CID;
    indexedAt: string;
    isRead: boolean;
    /** Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'. */
    reason:
      | "follow"
      | "like"
      | "mention"
      | "quote"
      | "reply"
      | "repost"
      | "starterpack-joined"
      | (string & {});
    record: unknown;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    reasonSubject?: At.Uri;
  }
}

/** Set notification-related preferences for an account. Requires auth. */
export declare namespace AppBskyNotificationPutPreferences {
  interface Params {}
  interface Input {
    priority: boolean;
  }
  type Output = undefined;
}

/** Register to receive push notifications, via a specified service, for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationRegisterPush {
  interface Params {}
  interface Input {
    appId: string;
    platform: "android" | "ios" | "web" | (string & {});
    serviceDid: At.DID;
    token: string;
  }
  type Output = undefined;
}

/** Notify server that the requesting account has seen notifications. Requires auth. */
export declare namespace AppBskyNotificationUpdateSeen {
  interface Params {}
  interface Input {
    seenAt: string;
  }
  type Output = undefined;
}

export declare namespace AppBskyRichtextFacet {
  /** Annotation of a sub-string within rich text. */
  interface Main {
    [Brand.Type]: "app.bsky.richtext.facet";
    features: Brand.Union<Link | Mention | Tag>[];
    index: ByteSlice;
  }
  /** Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets. */
  interface ByteSlice {
    [Brand.Type]: "app.bsky.richtext.facet#byteSlice";
    /** Minimum: 0 */
    byteEnd: number;
    /** Minimum: 0 */
    byteStart: number;
  }
  /** Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL. */
  interface Link {
    [Brand.Type]: "app.bsky.richtext.facet#link";
    uri: string;
  }
  /** Facet feature for mention of another account. The text is usually a handle, including a '\@' prefix, but the facet reference is a DID. */
  interface Mention {
    [Brand.Type]: "app.bsky.richtext.facet#mention";
    did: At.DID;
  }
  /** Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags'). */
  interface Tag {
    [Brand.Type]: "app.bsky.richtext.facet#tag";
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag: string;
  }
}

export declare namespace AppBskyUnspeccedDefs {
  interface SkeletonSearchActor {
    [Brand.Type]: "app.bsky.unspecced.defs#skeletonSearchActor";
    did: At.DID;
  }
  interface SkeletonSearchPost {
    [Brand.Type]: "app.bsky.unspecced.defs#skeletonSearchPost";
    uri: At.Uri;
  }
  interface SkeletonSearchStarterPack {
    [Brand.Type]: "app.bsky.unspecced.defs#skeletonSearchStarterPack";
    uri: At.Uri;
  }
}

/** Get miscellaneous runtime configuration. */
export declare namespace AppBskyUnspeccedGetConfig {
  interface Params {}
  type Input = undefined;
  interface Output {
    checkEmailConfirmed?: boolean;
  }
}

/** An unspecced view of globally popular feed generators. */
export declare namespace AppBskyUnspeccedGetPopularFeedGenerators {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    query?: string;
  }
  type Input = undefined;
  interface Output {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions */
export declare namespace AppBskyUnspeccedGetSuggestionsSkeleton {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer. */
    relativeToDid?: At.DID;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output {
    actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
    cursor?: string;
    /** DID of the account these suggestions are relative to. If this is returned undefined, suggestions are based on the viewer. */
    relativeToDid?: At.DID;
  }
}

/** Get a list of suggestions (feeds and users) tagged with categories */
export declare namespace AppBskyUnspeccedGetTaggedSuggestions {
  type Input = undefined;
  interface Output {
    suggestions: Suggestion[];
  }
  interface Suggestion {
    [Brand.Type]: "app.bsky.unspecced.getTaggedSuggestions#suggestion";
    subject: string;
    subjectType: "actor" | "feed" | (string & {});
    tag: string;
  }
}

/** Backend Actors (profile) search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchActorsSkeleton {
  interface Params {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax. */
    q: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** If true, acts as fast/simple 'typeahead' query. */
    typeahead?: boolean;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output {
    actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors {
    BadQueryString: {};
  }
}

/** Backend Posts search, returns only skeleton */
export declare namespace AppBskyUnspeccedSearchPostsSkeleton {
  interface Params {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Filter to posts by the given account. Handles are resolved to DID before query-time. */
    author?: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /** Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization. */
    domain?: string;
    /** Filter to posts in the given language. Expected to be based on post language field, though server may override language detection. */
    lang?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions. */
    mentions?: string;
    /** Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD). */
    since?: string;
    /**
     * Specifies the ranking order of results.
     * \@default "latest"
     */
    sort?: "latest" | "top" | (string & {});
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag?: string[];
    /** Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD). */
    until?: string;
    /** Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching. */
    url?: string;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output {
    posts: AppBskyUnspeccedDefs.SkeletonSearchPost[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors {
    BadQueryString: {};
  }
}

/** Backend Starter Pack search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchStarterPacksSkeleton {
  interface Params {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output {
    starterPacks: AppBskyUnspeccedDefs.SkeletonSearchStarterPack[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors {
    BadQueryString: {};
  }
}

export declare namespace AppBskyVideoDefs {
  interface JobStatus {
    [Brand.Type]: "app.bsky.video.defs#jobStatus";
    did: At.DID;
    jobId: string;
    /** The state of the video processing job. All values not listed as a known value indicate that the job is in process. */
    state: "JOB_STATE_COMPLETED" | "JOB_STATE_FAILED" | (string & {});
    blob?: At.Blob;
    error?: string;
    message?: string;
    /**
     * Progress within the current processing state.
     * Minimum: 0
     * Maximum: 100
     */
    progress?: number;
  }
}

/** Get status details for a video processing job. */
export declare namespace AppBskyVideoGetJobStatus {
  interface Params {
    jobId: string;
  }
  type Input = undefined;
  interface Output {
    jobStatus: AppBskyVideoDefs.JobStatus;
  }
}

/** Get video upload limits for the authenticated user. */
export declare namespace AppBskyVideoGetUploadLimits {
  interface Params {}
  type Input = undefined;
  interface Output {
    canUpload: boolean;
    error?: string;
    message?: string;
    remainingDailyBytes?: number;
    remainingDailyVideos?: number;
  }
}

/** Upload a video to be processed then stored on the PDS. */
export declare namespace AppBskyVideoUploadVideo {
  interface Params {}
  type Input = Blob | ArrayBufferView;
  interface Output {
    jobStatus: AppBskyVideoDefs.JobStatus;
  }
}

export declare namespace ChatBskyActorDeclaration {
  /** A declaration of a Bluesky chat account. */
  interface Record {
    $type: "chat.bsky.actor.declaration";
    allowIncoming: "all" | "following" | "none" | (string & {});
  }
}

export declare namespace ChatBskyActorDefs {
  interface ProfileViewBasic {
    [Brand.Type]: "chat.bsky.actor.defs#profileViewBasic";
    did: At.DID;
    handle: At.Handle;
    associated?: AppBskyActorDefs.ProfileAssociated;
    avatar?: string;
    /** Set to true when the actor cannot actively participate in converations */
    chatDisabled?: boolean;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    viewer?: AppBskyActorDefs.ViewerState;
  }
}

export declare namespace ChatBskyActorDeleteAccount {
  interface Params {}
  type Input = undefined;
  interface Output {}
}

export declare namespace ChatBskyActorExportAccountData {
  interface Params {}
  type Input = undefined;
  type Output = Uint8Array;
}

export declare namespace ChatBskyConvoDefs {
  interface ConvoView {
    [Brand.Type]: "chat.bsky.convo.defs#convoView";
    id: string;
    members: ChatBskyActorDefs.ProfileViewBasic[];
    muted: boolean;
    rev: string;
    unreadCount: number;
    lastMessage?: Brand.Union<DeletedMessageView | MessageView>;
    opened?: boolean;
  }
  interface DeletedMessageView {
    [Brand.Type]: "chat.bsky.convo.defs#deletedMessageView";
    id: string;
    rev: string;
    sender: MessageViewSender;
    sentAt: string;
  }
  interface LogBeginConvo {
    [Brand.Type]: "chat.bsky.convo.defs#logBeginConvo";
    convoId: string;
    rev: string;
  }
  interface LogCreateMessage {
    [Brand.Type]: "chat.bsky.convo.defs#logCreateMessage";
    convoId: string;
    message: Brand.Union<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogDeleteMessage {
    [Brand.Type]: "chat.bsky.convo.defs#logDeleteMessage";
    convoId: string;
    message: Brand.Union<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogLeaveConvo {
    [Brand.Type]: "chat.bsky.convo.defs#logLeaveConvo";
    convoId: string;
    rev: string;
  }
  interface MessageInput {
    [Brand.Type]: "chat.bsky.convo.defs#messageInput";
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    text: string;
    embed?: Brand.Union<AppBskyEmbedRecord.Main>;
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
  }
  interface MessageRef {
    [Brand.Type]: "chat.bsky.convo.defs#messageRef";
    convoId: string;
    did: At.DID;
    messageId: string;
  }
  interface MessageView {
    [Brand.Type]: "chat.bsky.convo.defs#messageView";
    id: string;
    rev: string;
    sender: MessageViewSender;
    sentAt: string;
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    text: string;
    embed?: Brand.Union<AppBskyEmbedRecord.View>;
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
  }
  interface MessageViewSender {
    [Brand.Type]: "chat.bsky.convo.defs#messageViewSender";
    did: At.DID;
  }
}

export declare namespace ChatBskyConvoDeleteMessageForSelf {
  interface Params {}
  interface Input {
    convoId: string;
    messageId: string;
  }
  type Output = ChatBskyConvoDefs.DeletedMessageView;
}

export declare namespace ChatBskyConvoGetConvo {
  interface Params {
    convoId: string;
  }
  type Input = undefined;
  interface Output {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoGetConvoForMembers {
  interface Params {
    /**
     * Minimum array length: 1
     * Maximum array length: 10
     */
    members: At.DID[];
  }
  type Input = undefined;
  interface Output {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoGetLog {
  interface Params {
    cursor?: string;
  }
  type Input = undefined;
  interface Output {
    logs: Brand.Union<
      | ChatBskyConvoDefs.LogBeginConvo
      | ChatBskyConvoDefs.LogCreateMessage
      | ChatBskyConvoDefs.LogDeleteMessage
      | ChatBskyConvoDefs.LogLeaveConvo
    >[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoGetMessages {
  interface Params {
    convoId: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    messages: Brand.Union<
      ChatBskyConvoDefs.DeletedMessageView | ChatBskyConvoDefs.MessageView
    >[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoLeaveConvo {
  interface Params {}
  interface Input {
    convoId: string;
  }
  interface Output {
    convoId: string;
    rev: string;
  }
}

export declare namespace ChatBskyConvoListConvos {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    convos: ChatBskyConvoDefs.ConvoView[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoMuteConvo {
  interface Params {}
  interface Input {
    convoId: string;
  }
  interface Output {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoSendMessage {
  interface Params {}
  interface Input {
    convoId: string;
    message: ChatBskyConvoDefs.MessageInput;
  }
  type Output = ChatBskyConvoDefs.MessageView;
}

export declare namespace ChatBskyConvoSendMessageBatch {
  interface Params {}
  interface Input {
    /** Maximum array length: 100 */
    items: BatchItem[];
  }
  interface Output {
    items: ChatBskyConvoDefs.MessageView[];
  }
  interface BatchItem {
    [Brand.Type]: "chat.bsky.convo.sendMessageBatch#batchItem";
    convoId: string;
    message: ChatBskyConvoDefs.MessageInput;
  }
}

export declare namespace ChatBskyConvoUnmuteConvo {
  interface Params {}
  interface Input {
    convoId: string;
  }
  interface Output {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoUpdateRead {
  interface Params {}
  interface Input {
    convoId: string;
    messageId?: string;
  }
  interface Output {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyModerationGetActorMetadata {
  interface Params {
    actor: At.DID;
  }
  type Input = undefined;
  interface Output {
    all: Metadata;
    day: Metadata;
    month: Metadata;
  }
  interface Metadata {
    [Brand.Type]: "chat.bsky.moderation.getActorMetadata#metadata";
    convos: number;
    convosStarted: number;
    messagesReceived: number;
    messagesSent: number;
  }
}

export declare namespace ChatBskyModerationGetMessageContext {
  interface Params {
    messageId: string;
    /** \@default 5 */
    after?: number;
    /** \@default 5 */
    before?: number;
    /** Conversation that the message is from. NOTE: this field will eventually be required. */
    convoId?: string;
  }
  type Input = undefined;
  interface Output {
    messages: Brand.Union<
      ChatBskyConvoDefs.DeletedMessageView | ChatBskyConvoDefs.MessageView
    >[];
  }
}

export declare namespace ChatBskyModerationUpdateActorAccess {
  interface Params {}
  interface Input {
    actor: At.DID;
    allowAccess: boolean;
    ref?: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoAdminDefs {
  interface AccountView {
    [Brand.Type]: "com.atproto.admin.defs#accountView";
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    deactivatedAt?: string;
    email?: string;
    emailConfirmedAt?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invites?: ComAtprotoServerDefs.InviteCode[];
    invitesDisabled?: boolean;
    relatedRecords?: unknown[];
    threatSignatures?: ThreatSignature[];
  }
  interface RepoBlobRef {
    [Brand.Type]: "com.atproto.admin.defs#repoBlobRef";
    cid: At.CID;
    did: At.DID;
    recordUri?: At.Uri;
  }
  interface RepoRef {
    [Brand.Type]: "com.atproto.admin.defs#repoRef";
    did: At.DID;
  }
  interface StatusAttr {
    [Brand.Type]: "com.atproto.admin.defs#statusAttr";
    applied: boolean;
    ref?: string;
  }
  interface ThreatSignature {
    [Brand.Type]: "com.atproto.admin.defs#threatSignature";
    property: string;
    value: string;
  }
}

/** Delete a user account as an administrator. */
export declare namespace ComAtprotoAdminDeleteAccount {
  interface Params {}
  interface Input {
    did: At.DID;
  }
  type Output = undefined;
}

/** Disable an account from receiving new invite codes, but does not invalidate existing codes. */
export declare namespace ComAtprotoAdminDisableAccountInvites {
  interface Params {}
  interface Input {
    account: At.DID;
    /** Optional reason for disabled invites. */
    note?: string;
  }
  type Output = undefined;
}

/** Disable some set of codes and/or all codes associated with a set of users. */
export declare namespace ComAtprotoAdminDisableInviteCodes {
  interface Params {}
  interface Input {
    accounts?: string[];
    codes?: string[];
  }
  type Output = undefined;
}

/** Re-enable an account's ability to receive invite codes. */
export declare namespace ComAtprotoAdminEnableAccountInvites {
  interface Params {}
  interface Input {
    account: At.DID;
    /** Optional reason for enabled invites. */
    note?: string;
  }
  type Output = undefined;
}

/** Get details about an account. */
export declare namespace ComAtprotoAdminGetAccountInfo {
  interface Params {
    did: At.DID;
  }
  type Input = undefined;
  type Output = ComAtprotoAdminDefs.AccountView;
}

/** Get details about some accounts. */
export declare namespace ComAtprotoAdminGetAccountInfos {
  interface Params {
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output {
    infos: ComAtprotoAdminDefs.AccountView[];
  }
}

/** Get an admin view of invite codes. */
export declare namespace ComAtprotoAdminGetInviteCodes {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 500
     * \@default 100
     */
    limit?: number;
    /** \@default "recent" */
    sort?: "recent" | "usage" | (string & {});
  }
  type Input = undefined;
  interface Output {
    codes: ComAtprotoServerDefs.InviteCode[];
    cursor?: string;
  }
}

/** Get the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminGetSubjectStatus {
  interface Params {
    blob?: At.CID;
    did?: At.DID;
    uri?: At.Uri;
  }
  type Input = undefined;
  interface Output {
    subject: Brand.Union<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    deactivated?: ComAtprotoAdminDefs.StatusAttr;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
}

/** Get list of accounts that matches your search query. */
export declare namespace ComAtprotoAdminSearchAccounts {
  interface Params {
    cursor?: string;
    email?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    accounts: ComAtprotoAdminDefs.AccountView[];
    cursor?: string;
  }
}

/** Send email to a user's account email address. */
export declare namespace ComAtprotoAdminSendEmail {
  interface Params {}
  interface Input {
    content: string;
    recipientDid: At.DID;
    senderDid: At.DID;
    /** Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers */
    comment?: string;
    subject?: string;
  }
  interface Output {
    sent: boolean;
  }
}

/** Administrative action to update an account's email. */
export declare namespace ComAtprotoAdminUpdateAccountEmail {
  interface Params {}
  interface Input {
    /** The handle or DID of the repo. */
    account: string;
    email: string;
  }
  type Output = undefined;
}

/** Administrative action to update an account's handle. */
export declare namespace ComAtprotoAdminUpdateAccountHandle {
  interface Params {}
  interface Input {
    did: At.DID;
    handle: At.Handle;
  }
  type Output = undefined;
}

/** Update the password for a user account as an administrator. */
export declare namespace ComAtprotoAdminUpdateAccountPassword {
  interface Params {}
  interface Input {
    did: At.DID;
    password: string;
  }
  type Output = undefined;
}

/** Update the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminUpdateSubjectStatus {
  interface Params {}
  interface Input {
    subject: Brand.Union<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    deactivated?: ComAtprotoAdminDefs.StatusAttr;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
  interface Output {
    subject: Brand.Union<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
}

/** Describe the credentials that should be included in the DID doc of an account that is migrating to this service. */
export declare namespace ComAtprotoIdentityGetRecommendedDidCredentials {
  interface Params {}
  type Input = undefined;
  interface Output {
    alsoKnownAs?: string[];
    /** Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs. */
    rotationKeys?: string[];
    services?: unknown;
    verificationMethods?: unknown;
  }
}

/** Request an email with a code to in order to request a signed PLC operation. Requires Auth. */
export declare namespace ComAtprotoIdentityRequestPlcOperationSignature {
  interface Params {}
  type Input = undefined;
  type Output = undefined;
}

/** Resolves a handle (domain name) to a DID. */
export declare namespace ComAtprotoIdentityResolveHandle {
  interface Params {
    /** The handle to resolve. */
    handle: At.Handle;
  }
  type Input = undefined;
  interface Output {
    did: At.DID;
  }
}

/** Signs a PLC operation to update some value(s) in the requesting DID's document. */
export declare namespace ComAtprotoIdentitySignPlcOperation {
  interface Params {}
  interface Input {
    alsoKnownAs?: string[];
    rotationKeys?: string[];
    services?: unknown;
    /** A token received through com.atproto.identity.requestPlcOperationSignature */
    token?: string;
    verificationMethods?: unknown;
  }
  interface Output {
    /** A signed DID PLC operation. */
    operation: unknown;
  }
}

/** Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry */
export declare namespace ComAtprotoIdentitySubmitPlcOperation {
  interface Params {}
  interface Input {
    operation: unknown;
  }
  type Output = undefined;
}

/** Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth. */
export declare namespace ComAtprotoIdentityUpdateHandle {
  interface Params {}
  interface Input {
    /** The new handle. */
    handle: At.Handle;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoLabelDefs {
  /** Metadata tag on an atproto resource (eg, repo or record). */
  interface Label {
    [Brand.Type]: "com.atproto.label.defs#label";
    /** Timestamp when this label was created. */
    cts: string;
    /** DID of the actor who created this label. */
    src: At.DID;
    /** AT URI of the record, repository (account), or other resource that this label applies to. */
    uri: string;
    /**
     * The short string name of the value or type of this label.
     * Maximum string length: 128
     */
    val: string;
    /** Optionally, CID specifying the specific version of 'uri' resource this label applies to. */
    cid?: At.CID;
    /** Timestamp at which this label expires (no longer applies). */
    exp?: string;
    /** If true, this is a negation label, overwriting a previous label. */
    neg?: boolean;
    /** Signature of dag-cbor encoded label. */
    sig?: At.Bytes;
    /** The AT Protocol version of the label object. */
    ver?: number;
  }
  type LabelValue =
    | "!hide"
    | "!no-promote"
    | "!no-unauthenticated"
    | "!warn"
    | "dmca-violation"
    | "doxxing"
    | "gore"
    | "nsfl"
    | "nudity"
    | "porn"
    | "sexual"
    | (string & {});
  /** Declares a label value and its expected interpretations and behaviors. */
  interface LabelValueDefinition {
    [Brand.Type]: "com.atproto.label.defs#labelValueDefinition";
    /** What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing. */
    blurs: "content" | "media" | "none" | (string & {});
    /**
     * The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).
     * Maximum string length: 100
     * Maximum grapheme length: 100
     */
    identifier: string;
    locales: LabelValueDefinitionStrings[];
    /** How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing. */
    severity: "alert" | "inform" | "none" | (string & {});
    /** Does the user need to have adult content enabled in order to configure this label? */
    adultOnly?: boolean;
    /**
     * The default setting for this label.
     * \@default "warn"
     */
    defaultSetting?: "hide" | "ignore" | "warn" | (string & {});
  }
  /** Strings which describe the label in the UI, localized into a specific language. */
  interface LabelValueDefinitionStrings {
    [Brand.Type]: "com.atproto.label.defs#labelValueDefinitionStrings";
    /**
     * A longer description of what the label means and why it might be applied.
     * Maximum string length: 100000
     * Maximum grapheme length: 10000
     */
    description: string;
    /** The code of the language these strings are written in. */
    lang: string;
    /**
     * A short human-readable name for the label.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    name: string;
  }
  /** Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel. */
  interface SelfLabel {
    [Brand.Type]: "com.atproto.label.defs#selfLabel";
    /**
     * The short string name of the value or type of this label.
     * Maximum string length: 128
     */
    val: string;
  }
  /** Metadata tags on an atproto record, published by the author within the record. */
  interface SelfLabels {
    [Brand.Type]: "com.atproto.label.defs#selfLabels";
    /** Maximum array length: 10 */
    values: SelfLabel[];
  }
}

/** Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth. */
export declare namespace ComAtprotoLabelQueryLabels {
  interface Params {
    /** List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI. */
    uriPatterns: string[];
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 250
     * \@default 50
     */
    limit?: number;
    /** Optional list of label sources (DIDs) to filter on. */
    sources?: At.DID[];
  }
  type Input = undefined;
  interface Output {
    labels: ComAtprotoLabelDefs.Label[];
    cursor?: string;
  }
}

export declare namespace ComAtprotoLabelSubscribeLabels {
  interface Params {
    /** The last known event seq number to backfill from. */
    cursor?: number;
  }
  type Message = Brand.Union<Info | Labels>;
  interface Errors {
    FutureCursor: {};
  }
  interface Info {
    [Brand.Type]: "com.atproto.label.subscribeLabels#info";
    name: "OutdatedCursor" | (string & {});
    message?: string;
  }
  interface Labels {
    [Brand.Type]: "com.atproto.label.subscribeLabels#labels";
    labels: ComAtprotoLabelDefs.Label[];
    seq: number;
  }
}

/** Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth. */
export declare namespace ComAtprotoModerationCreateReport {
  interface Params {}
  interface Input {
    /** Indicates the broad category of violation the report is for. */
    reasonType: ComAtprotoModerationDefs.ReasonType;
    subject: Brand.Union<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /**
     * Additional context about the content and violation.
     * Maximum string length: 20000
     * Maximum grapheme length: 2000
     */
    reason?: string;
  }
  interface Output {
    createdAt: string;
    id: number;
    reasonType: ComAtprotoModerationDefs.ReasonType;
    reportedBy: At.DID;
    subject: Brand.Union<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /**
     * Maximum string length: 20000
     * Maximum grapheme length: 2000
     */
    reason?: string;
  }
}

export declare namespace ComAtprotoModerationDefs {
  type ReasonAppeal = "com.atproto.moderation.defs#reasonAppeal";
  type ReasonMisleading = "com.atproto.moderation.defs#reasonMisleading";
  type ReasonOther = "com.atproto.moderation.defs#reasonOther";
  type ReasonRude = "com.atproto.moderation.defs#reasonRude";
  type ReasonSexual = "com.atproto.moderation.defs#reasonSexual";
  type ReasonSpam = "com.atproto.moderation.defs#reasonSpam";
  type ReasonType =
    | "com.atproto.moderation.defs#reasonAppeal"
    | "com.atproto.moderation.defs#reasonMisleading"
    | "com.atproto.moderation.defs#reasonOther"
    | "com.atproto.moderation.defs#reasonRude"
    | "com.atproto.moderation.defs#reasonSexual"
    | "com.atproto.moderation.defs#reasonSpam"
    | "com.atproto.moderation.defs#reasonViolation"
    | (string & {});
  type ReasonViolation = "com.atproto.moderation.defs#reasonViolation";
}

/** Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoApplyWrites {
  interface Params {}
  interface Input {
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    writes: Brand.Union<Create | Delete | Update>[];
    /** If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations. */
    swapCommit?: At.CID;
    /** Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output {
    commit?: ComAtprotoRepoDefs.CommitMeta;
    results?: Brand.Union<CreateResult | DeleteResult | UpdateResult>[];
  }
  interface Errors {
    InvalidSwap: {};
  }
  /** Operation which creates a new record. */
  interface Create {
    [Brand.Type]: "com.atproto.repo.applyWrites#create";
    collection: string;
    value: unknown;
    /** Maximum string length: 512 */
    rkey?: string;
  }
  interface CreateResult {
    [Brand.Type]: "com.atproto.repo.applyWrites#createResult";
    cid: At.CID;
    uri: At.Uri;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  /** Operation which deletes an existing record. */
  interface Delete {
    [Brand.Type]: "com.atproto.repo.applyWrites#delete";
    collection: string;
    rkey: string;
  }
  interface DeleteResult {
    [Brand.Type]: "com.atproto.repo.applyWrites#deleteResult";
  }
  /** Operation which updates an existing record. */
  interface Update {
    [Brand.Type]: "com.atproto.repo.applyWrites#update";
    collection: string;
    rkey: string;
    value: unknown;
  }
  interface UpdateResult {
    [Brand.Type]: "com.atproto.repo.applyWrites#updateResult";
    cid: At.CID;
    uri: At.Uri;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
}

/** Create a single new repository record. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoCreateRecord {
  interface Params {}
  interface Input {
    /** The NSID of the record collection. */
    collection: string;
    /** The record itself. Must contain a $type field. */
    record: unknown;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /**
     * The Record Key.
     * Maximum string length: 512
     */
    rkey?: string;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output {
    cid: At.CID;
    uri: At.Uri;
    commit?: ComAtprotoRepoDefs.CommitMeta;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  interface Errors {
    InvalidSwap: {};
  }
}

export declare namespace ComAtprotoRepoDefs {
  interface CommitMeta {
    [Brand.Type]: "com.atproto.repo.defs#commitMeta";
    cid: At.CID;
    rev: string;
  }
}

/** Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoDeleteRecord {
  interface Params {}
  interface Input {
    /** The NSID of the record collection. */
    collection: string;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey: string;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Compare and swap with the previous record by CID. */
    swapRecord?: At.CID;
  }
  interface Output {
    commit?: ComAtprotoRepoDefs.CommitMeta;
  }
  interface Errors {
    InvalidSwap: {};
  }
}

/** Get information about an account and repository, including the list of collections. Does not require auth. */
export declare namespace ComAtprotoRepoDescribeRepo {
  interface Params {
    /** The handle or DID of the repo. */
    repo: string;
  }
  type Input = undefined;
  interface Output {
    /** List of all the collections (NSIDs) for which this repo contains at least one record. */
    collections: string[];
    did: At.DID;
    /** The complete DID document for this account. */
    didDoc: unknown;
    handle: At.Handle;
    /** Indicates if handle is currently valid (resolves bi-directionally) */
    handleIsCorrect: boolean;
  }
}

/** Get a single record from a repository. Does not require auth. */
export declare namespace ComAtprotoRepoGetRecord {
  interface Params {
    /** The NSID of the record collection. */
    collection: string;
    /** The handle or DID of the repo. */
    repo: string;
    /** The Record Key. */
    rkey: string;
    /** The CID of the version of the record. If not specified, then return the most recent version. */
    cid?: At.CID;
  }
  type Input = undefined;
  interface Output {
    uri: At.Uri;
    value: unknown;
    cid?: At.CID;
  }
  interface Errors {
    RecordNotFound: {};
  }
}

/** Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set. */
export declare namespace ComAtprotoRepoImportRepo {
  interface Params {}
  type Input = Blob | ArrayBufferView;
  type Output = undefined;
}

/** Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow. */
export declare namespace ComAtprotoRepoListMissingBlobs {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    blobs: RecordBlob[];
    cursor?: string;
  }
  interface RecordBlob {
    [Brand.Type]: "com.atproto.repo.listMissingBlobs#recordBlob";
    cid: At.CID;
    recordUri: At.Uri;
  }
}

/** List a range of records in a repository, matching a specific collection. Does not require auth. */
export declare namespace ComAtprotoRepoListRecords {
  interface Params {
    /** The NSID of the record type. */
    collection: string;
    /** The handle or DID of the repo. */
    repo: string;
    cursor?: string;
    /**
     * The number of records to return.
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Flag to reverse the order of the returned records. */
    reverse?: boolean;
    /**
     * DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)
     * \@deprecated
     */
    rkeyEnd?: string;
    /**
     * DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)
     * \@deprecated
     */
    rkeyStart?: string;
  }
  type Input = undefined;
  interface Output {
    records: Record[];
    cursor?: string;
  }
  interface Record {
    [Brand.Type]: "com.atproto.repo.listRecords#record";
    cid: At.CID;
    uri: At.Uri;
    value: unknown;
  }
}

/** Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoPutRecord {
  interface Params {}
  interface Input {
    /** The NSID of the record collection. */
    collection: string;
    /** The record to write. */
    record: unknown;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /**
     * The Record Key.
     * Maximum string length: 512
     */
    rkey: string;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation */
    swapRecord?: At.CID | null;
    /** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output {
    cid: At.CID;
    uri: At.Uri;
    commit?: ComAtprotoRepoDefs.CommitMeta;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  interface Errors {
    InvalidSwap: {};
  }
}

export declare namespace ComAtprotoRepoStrongRef {
  interface Main {
    [Brand.Type]: "com.atproto.repo.strongRef";
    cid: At.CID;
    uri: At.Uri;
  }
}

/** Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoUploadBlob {
  interface Params {}
  type Input = Blob | ArrayBufferView;
  interface Output {
    blob: At.Blob;
  }
}

/** Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup. */
export declare namespace ComAtprotoServerActivateAccount {
  interface Params {}
  type Input = undefined;
  type Output = undefined;
}

/** Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself. */
export declare namespace ComAtprotoServerCheckAccountStatus {
  interface Params {}
  type Input = undefined;
  interface Output {
    activated: boolean;
    expectedBlobs: number;
    importedBlobs: number;
    indexedRecords: number;
    privateStateValues: number;
    repoBlocks: number;
    repoCommit: At.CID;
    repoRev: string;
    validDid: boolean;
  }
}

/** Confirm an email using a token from com.atproto.server.requestEmailConfirmation. */
export declare namespace ComAtprotoServerConfirmEmail {
  interface Params {}
  interface Input {
    email: string;
    token: string;
  }
  type Output = undefined;
  interface Errors {
    AccountNotFound: {};
    ExpiredToken: {};
    InvalidToken: {};
    InvalidEmail: {};
  }
}

/** Create an account. Implemented by PDS. */
export declare namespace ComAtprotoServerCreateAccount {
  interface Params {}
  interface Input {
    /** Requested handle for the account. */
    handle: At.Handle;
    /** Pre-existing atproto DID, being imported to a new account. */
    did?: At.DID;
    email?: string;
    inviteCode?: string;
    /** Initial account password. May need to meet instance-specific password strength requirements. */
    password?: string;
    /** A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented. */
    plcOp?: unknown;
    /** DID PLC rotation key (aka, recovery key) to be included in PLC creation operation. */
    recoveryKey?: string;
    verificationCode?: string;
    verificationPhone?: string;
  }
  /** Account login session returned on successful account creation. */
  interface Output {
    accessJwt: string;
    /** The DID of the new account. */
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    /** Complete DID document. */
    didDoc?: unknown;
  }
  interface Errors {
    InvalidHandle: {};
    InvalidPassword: {};
    InvalidInviteCode: {};
    HandleNotAvailable: {};
    UnsupportedDomain: {};
    UnresolvableDid: {};
    IncompatibleDidDoc: {};
  }
}

/** Create an App Password. */
export declare namespace ComAtprotoServerCreateAppPassword {
  interface Params {}
  interface Input {
    /** A short name for the App Password, to help distinguish them. */
    name: string;
    /** If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients. */
    privileged?: boolean;
  }
  type Output = AppPassword;
  interface Errors {
    AccountTakedown: {};
  }
  interface AppPassword {
    [Brand.Type]: "com.atproto.server.createAppPassword#appPassword";
    createdAt: string;
    name: string;
    password: string;
    privileged?: boolean;
  }
}

/** Create an invite code. */
export declare namespace ComAtprotoServerCreateInviteCode {
  interface Params {}
  interface Input {
    useCount: number;
    forAccount?: At.DID;
  }
  interface Output {
    code: string;
  }
}

/** Create invite codes. */
export declare namespace ComAtprotoServerCreateInviteCodes {
  interface Params {}
  interface Input {
    /** \@default 1 */
    codeCount: number;
    useCount: number;
    forAccounts?: At.DID[];
  }
  interface Output {
    codes: AccountCodes[];
  }
  interface AccountCodes {
    [Brand.Type]: "com.atproto.server.createInviteCodes#accountCodes";
    account: string;
    codes: string[];
  }
}

/** Create an authentication session. */
export declare namespace ComAtprotoServerCreateSession {
  interface Params {}
  interface Input {
    /** Handle or other identifier supported by the server for the authenticating user. */
    identifier: string;
    password: string;
    authFactorToken?: string;
  }
  interface Output {
    accessJwt: string;
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors {
    AccountTakedown: {};
    AuthFactorTokenRequired: {};
  }
}

/** Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host. */
export declare namespace ComAtprotoServerDeactivateAccount {
  interface Params {}
  interface Input {
    /** A recommendation to server as to how long they should hold onto the deactivated account before deleting. */
    deleteAfter?: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoServerDefs {
  interface InviteCode {
    [Brand.Type]: "com.atproto.server.defs#inviteCode";
    available: number;
    code: string;
    createdAt: string;
    createdBy: string;
    disabled: boolean;
    forAccount: string;
    uses: InviteCodeUse[];
  }
  interface InviteCodeUse {
    [Brand.Type]: "com.atproto.server.defs#inviteCodeUse";
    usedAt: string;
    usedBy: At.DID;
  }
}

/** Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth. */
export declare namespace ComAtprotoServerDeleteAccount {
  interface Params {}
  interface Input {
    did: At.DID;
    password: string;
    token: string;
  }
  type Output = undefined;
  interface Errors {
    ExpiredToken: {};
    InvalidToken: {};
  }
}

/** Delete the current session. Requires auth. */
export declare namespace ComAtprotoServerDeleteSession {
  interface Params {}
  type Input = undefined;
  type Output = undefined;
}

/** Describes the server's account creation requirements and capabilities. Implemented by PDS. */
export declare namespace ComAtprotoServerDescribeServer {
  interface Params {}
  type Input = undefined;
  interface Output {
    /** List of domain suffixes that can be used in account handles. */
    availableUserDomains: string[];
    did: At.DID;
    /** Contact information */
    contact?: Contact;
    /** If true, an invite code must be supplied to create an account on this instance. */
    inviteCodeRequired?: boolean;
    /** URLs of service policy documents. */
    links?: Links;
    /** If true, a phone verification token must be supplied to create an account on this instance. */
    phoneVerificationRequired?: boolean;
  }
  interface Contact {
    [Brand.Type]: "com.atproto.server.describeServer#contact";
    email?: string;
  }
  interface Links {
    [Brand.Type]: "com.atproto.server.describeServer#links";
    privacyPolicy?: string;
    termsOfService?: string;
  }
}

/** Get all invite codes for the current account. Requires auth. */
export declare namespace ComAtprotoServerGetAccountInviteCodes {
  interface Params {
    /**
     * Controls whether any new 'earned' but not 'created' invites should be created.
     * \@default true
     */
    createAvailable?: boolean;
    /** \@default true */
    includeUsed?: boolean;
  }
  type Input = undefined;
  interface Output {
    codes: ComAtprotoServerDefs.InviteCode[];
  }
  interface Errors {
    DuplicateCreate: {};
  }
}

/** Get a signed token on behalf of the requesting DID for the requested service. */
export declare namespace ComAtprotoServerGetServiceAuth {
  interface Params {
    /** The DID of the service that the token will be used to authenticate with */
    aud: At.DID;
    /** The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope. */
    exp?: number;
    /** Lexicon (XRPC) method to bind the requested token to */
    lxm?: string;
  }
  type Input = undefined;
  interface Output {
    token: string;
  }
  interface Errors {
    BadExpiration: {};
  }
}

/** Get information about the current auth session. Requires auth. */
export declare namespace ComAtprotoServerGetSession {
  interface Params {}
  type Input = undefined;
  interface Output {
    did: At.DID;
    handle: At.Handle;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
}

/** List all App Passwords. */
export declare namespace ComAtprotoServerListAppPasswords {
  interface Params {}
  type Input = undefined;
  interface Output {
    passwords: AppPassword[];
  }
  interface Errors {
    AccountTakedown: {};
  }
  interface AppPassword {
    [Brand.Type]: "com.atproto.server.listAppPasswords#appPassword";
    createdAt: string;
    name: string;
    privileged?: boolean;
  }
}

/** Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt'). */
export declare namespace ComAtprotoServerRefreshSession {
  interface Params {}
  type Input = undefined;
  interface Output {
    accessJwt: string;
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    active?: boolean;
    didDoc?: unknown;
    /** Hosting status of the account. If not specified, then assume 'active'. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors {
    AccountTakedown: {};
  }
}

/** Initiate a user account deletion via email. */
export declare namespace ComAtprotoServerRequestAccountDelete {
  interface Params {}
  type Input = undefined;
  type Output = undefined;
}

/** Request an email with a code to confirm ownership of email. */
export declare namespace ComAtprotoServerRequestEmailConfirmation {
  interface Params {}
  type Input = undefined;
  type Output = undefined;
}

/** Request a token in order to update email. */
export declare namespace ComAtprotoServerRequestEmailUpdate {
  interface Params {}
  type Input = undefined;
  interface Output {
    tokenRequired: boolean;
  }
}

/** Initiate a user account password reset via email. */
export declare namespace ComAtprotoServerRequestPasswordReset {
  interface Params {}
  interface Input {
    email: string;
  }
  type Output = undefined;
}

/** Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented. */
export declare namespace ComAtprotoServerReserveSigningKey {
  interface Params {}
  interface Input {
    /** The DID to reserve a key for. */
    did?: At.DID;
  }
  interface Output {
    /** The public key for the reserved signing key, in did:key serialization. */
    signingKey: string;
  }
}

/** Reset a user account password using a token. */
export declare namespace ComAtprotoServerResetPassword {
  interface Params {}
  interface Input {
    password: string;
    token: string;
  }
  type Output = undefined;
  interface Errors {
    ExpiredToken: {};
    InvalidToken: {};
  }
}

/** Revoke an App Password by name. */
export declare namespace ComAtprotoServerRevokeAppPassword {
  interface Params {}
  interface Input {
    name: string;
  }
  type Output = undefined;
}

/** Update an account's email. */
export declare namespace ComAtprotoServerUpdateEmail {
  interface Params {}
  interface Input {
    email: string;
    emailAuthFactor?: boolean;
    /** Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed. */
    token?: string;
  }
  type Output = undefined;
  interface Errors {
    ExpiredToken: {};
    InvalidToken: {};
    TokenRequired: {};
  }
}

/** Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlob {
  interface Params {
    /** The CID of the blob to fetch */
    cid: At.CID;
    /** The DID of the account. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors {
    BlobNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlocks {
  interface Params {
    cids: At.CID[];
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors {
    BlockNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/**
 * DEPRECATED - please use com.atproto.sync.getRepo instead
 * \@deprecated
 */
export declare namespace ComAtprotoSyncGetCheckout {
  interface Params {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
}

/**
 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
 * \@deprecated
 */
export declare namespace ComAtprotoSyncGetHead {
  interface Params {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output {
    root: At.CID;
  }
  interface Errors {
    HeadNotFound: {};
  }
}

/** Get the current commit CID & revision of the specified repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetLatestCommit {
  interface Params {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output {
    cid: At.CID;
    rev: string;
  }
  interface Errors {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetRecord {
  interface Params {
    collection: string;
    /** The DID of the repo. */
    did: At.DID;
    /** Record Key */
    rkey: string;
    /**
     * DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit
     * \@deprecated
     */
    commit?: At.CID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors {
    RecordNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetRepo {
  interface Params {
    /** The DID of the repo. */
    did: At.DID;
    /** The revision ('rev') of the repo to create a diff from. */
    since?: string;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncGetRepoStatus {
  interface Params {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output {
    active: boolean;
    did: At.DID;
    /** Optional field, the current rev of the repo, if active=true */
    rev?: string;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors {
    RepoNotFound: {};
  }
}

/** List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncListBlobs {
  interface Params {
    /** The DID of the repo. */
    did: At.DID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
    /** Optional revision of the repo to list blobs since. */
    since?: string;
  }
  type Input = undefined;
  interface Output {
    cids: At.CID[];
    cursor?: string;
  }
  interface Errors {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncListRepos {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    repos: Repo[];
    cursor?: string;
  }
  interface Repo {
    [Brand.Type]: "com.atproto.sync.listRepos#repo";
    did: At.DID;
    /** Current repo commit CID */
    head: At.CID;
    rev: string;
    active?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
}

/** Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay. */
export declare namespace ComAtprotoSyncNotifyOfUpdate {
  interface Params {}
  interface Input {
    /** Hostname of the current service (usually a PDS) that is notifying of update. */
    hostname: string;
  }
  type Output = undefined;
}

/** Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth. */
export declare namespace ComAtprotoSyncRequestCrawl {
  interface Params {}
  interface Input {
    /** Hostname of the current service (eg, PDS) that is requesting to be crawled. */
    hostname: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoSyncSubscribeRepos {
  interface Params {
    /** The last known event seq number to backfill from. */
    cursor?: number;
  }
  type Message = Brand.Union<
    Account | Commit | Handle | Identity | Info | Migrate | Tombstone
  >;
  interface Errors {
    FutureCursor: {};
    ConsumerTooSlow: {};
  }
  /** Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active. */
  interface Account {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#account";
    /** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
    active: boolean;
    did: At.DID;
    seq: number;
    time: string;
    /** If active=false, this optional field indicates a reason for why the account is not active. */
    status?:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | (string & {});
  }
  /** Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature. */
  interface Commit {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#commit";
    /** List of new blobs (by CID) referenced by records in this commit. */
    blobs: At.CIDLink[];
    /** CAR file containing relevant blocks, as a diff since the previous repo state. */
    blocks: At.Bytes;
    /** Repo commit object CID. */
    commit: At.CIDLink;
    /**
     * Maximum array length: 200
     * List of repo mutation operations in this commit (eg, records created, updated, or deleted).
     */
    ops: RepoOp[];
    /**
     * DEPRECATED -- unused
     * \@deprecated
     */
    rebase: boolean;
    /** The repo this event comes from. */
    repo: At.DID;
    /** The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event. */
    rev: string;
    /** The stream sequence number of this message. */
    seq: number;
    /** The rev of the last emitted commit from this repo (if any). */
    since: string | null;
    /** Timestamp of when this message was originally broadcast. */
    time: string;
    /** Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data. */
    tooBig: boolean;
    /**
     * DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability.
     * \@deprecated
     */
    prev?: At.CIDLink | null;
  }
  /**
   * DEPRECATED -- Use #identity event instead
   * \@deprecated
   */
  interface Handle {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#handle";
    did: At.DID;
    handle: At.Handle;
    seq: number;
    time: string;
  }
  /** Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache. */
  interface Identity {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#identity";
    did: At.DID;
    seq: number;
    time: string;
    /** The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details. */
    handle?: At.Handle;
  }
  interface Info {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#info";
    name: "OutdatedCursor" | (string & {});
    message?: string;
  }
  /**
   * DEPRECATED -- Use #account event instead
   * \@deprecated
   */
  interface Migrate {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#migrate";
    did: At.DID;
    migrateTo: string | null;
    seq: number;
    time: string;
  }
  /** A repo operation, ie a mutation of a single record. */
  interface RepoOp {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#repoOp";
    action: "create" | "delete" | "update" | (string & {});
    /** For creates and updates, the new record CID. For deletions, null. */
    cid: At.CIDLink | null;
    path: string;
  }
  /**
   * DEPRECATED -- Use #account event instead
   * \@deprecated
   */
  interface Tombstone {
    [Brand.Type]: "com.atproto.sync.subscribeRepos#tombstone";
    did: At.DID;
    seq: number;
    time: string;
  }
}

/** Add a handle to the set of reserved handles. */
export declare namespace ComAtprotoTempAddReservedHandle {
  interface Params {}
  interface Input {
    handle: string;
  }
  interface Output {}
}

/** Check accounts location in signup queue. */
export declare namespace ComAtprotoTempCheckSignupQueue {
  interface Params {}
  type Input = undefined;
  interface Output {
    activated: boolean;
    estimatedTimeMs?: number;
    placeInQueue?: number;
  }
}

/**
 * DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.
 * \@deprecated
 */
export declare namespace ComAtprotoTempFetchLabels {
  interface Params {
    /**
     * Minimum: 1
     * Maximum: 250
     * \@default 50
     */
    limit?: number;
    since?: number;
  }
  type Input = undefined;
  interface Output {
    labels: ComAtprotoLabelDefs.Label[];
  }
}

/** Request a verification code to be sent to the supplied phone number */
export declare namespace ComAtprotoTempRequestPhoneVerification {
  interface Params {}
  interface Input {
    phoneNumber: string;
  }
  type Output = undefined;
}

/** Administrative action to create a new, re-usable communication (email for now) template. */
export declare namespace ToolsOzoneCommunicationCreateTemplate {
  interface Params {}
  interface Input {
    /** Content of the template, markdown supported, can contain variable placeholders. */
    contentMarkdown: string;
    /** Name of the template. */
    name: string;
    /** Subject of the message, used in emails. */
    subject: string;
    /** DID of the user who is creating the template. */
    createdBy?: At.DID;
    /** Message language. */
    lang?: string;
  }
  type Output = ToolsOzoneCommunicationDefs.TemplateView;
  interface Errors {
    DuplicateTemplateName: {};
  }
}

export declare namespace ToolsOzoneCommunicationDefs {
  interface TemplateView {
    [Brand.Type]: "tools.ozone.communication.defs#templateView";
    /** Subject of the message, used in emails. */
    contentMarkdown: string;
    createdAt: string;
    disabled: boolean;
    id: string;
    /** DID of the user who last updated the template. */
    lastUpdatedBy: At.DID;
    /** Name of the template. */
    name: string;
    updatedAt: string;
    /** Message language. */
    lang?: string;
    /** Content of the template, can contain markdown and variable placeholders. */
    subject?: string;
  }
}

/** Delete a communication template. */
export declare namespace ToolsOzoneCommunicationDeleteTemplate {
  interface Params {}
  interface Input {
    id: string;
  }
  type Output = undefined;
}

/** Get list of all communication templates. */
export declare namespace ToolsOzoneCommunicationListTemplates {
  interface Params {}
  type Input = undefined;
  interface Output {
    communicationTemplates: ToolsOzoneCommunicationDefs.TemplateView[];
  }
}

/** Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only. */
export declare namespace ToolsOzoneCommunicationUpdateTemplate {
  interface Params {}
  interface Input {
    /** ID of the template to be updated. */
    id: string;
    /** Content of the template, markdown supported, can contain variable placeholders. */
    contentMarkdown?: string;
    disabled?: boolean;
    /** Message language. */
    lang?: string;
    /** Name of the template. */
    name?: string;
    /** Subject of the message, used in emails. */
    subject?: string;
    /** DID of the user who is updating the template. */
    updatedBy?: At.DID;
  }
  type Output = ToolsOzoneCommunicationDefs.TemplateView;
  interface Errors {
    DuplicateTemplateName: {};
  }
}

export declare namespace ToolsOzoneModerationDefs {
  /** Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface AccountEvent {
    [Brand.Type]: "tools.ozone.moderation.defs#accountEvent";
    /** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
    active: boolean;
    timestamp: string;
    comment?: string;
    status?:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | "tombstoned"
      | "unknown"
      | (string & {});
  }
  interface AccountHosting {
    [Brand.Type]: "tools.ozone.moderation.defs#accountHosting";
    status:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | "unknown"
      | (string & {});
    createdAt?: string;
    deactivatedAt?: string;
    deletedAt?: string;
    reactivatedAt?: string;
    updatedAt?: string;
  }
  interface BlobView {
    [Brand.Type]: "tools.ozone.moderation.defs#blobView";
    cid: At.CID;
    createdAt: string;
    mimeType: string;
    size: number;
    details?: Brand.Union<ImageDetails | VideoDetails>;
    moderation?: Moderation;
  }
  /** Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface IdentityEvent {
    [Brand.Type]: "tools.ozone.moderation.defs#identityEvent";
    timestamp: string;
    comment?: string;
    handle?: At.Handle;
    pdsHost?: string;
    tombstone?: boolean;
  }
  interface ImageDetails {
    [Brand.Type]: "tools.ozone.moderation.defs#imageDetails";
    height: number;
    width: number;
  }
  interface Moderation {
    [Brand.Type]: "tools.ozone.moderation.defs#moderation";
    subjectStatus?: SubjectStatusView;
  }
  interface ModerationDetail {
    [Brand.Type]: "tools.ozone.moderation.defs#moderationDetail";
    subjectStatus?: SubjectStatusView;
  }
  interface ModEventAcknowledge {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventAcknowledge";
    comment?: string;
  }
  /** Add a comment to a subject */
  interface ModEventComment {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventComment";
    comment: string;
    /** Make the comment persistent on the subject */
    sticky?: boolean;
  }
  /** Divert a record's blobs to a 3rd party service for further scanning/tagging */
  interface ModEventDivert {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventDivert";
    comment?: string;
  }
  /** Keep a log of outgoing email to a user */
  interface ModEventEmail {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventEmail";
    /** The subject line of the email sent to the user. */
    subjectLine: string;
    /** Additional comment about the outgoing comm. */
    comment?: string;
    /** The content of the email sent to the user. */
    content?: string;
  }
  interface ModEventEscalate {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventEscalate";
    comment?: string;
  }
  /** Apply/Negate labels on a subject */
  interface ModEventLabel {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventLabel";
    createLabelVals: string[];
    negateLabelVals: string[];
    comment?: string;
  }
  /** Mute incoming reports on a subject */
  interface ModEventMute {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventMute";
    /** Indicates how long the subject should remain muted. */
    durationInHours: number;
    comment?: string;
  }
  /** Mute incoming reports from an account */
  interface ModEventMuteReporter {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventMuteReporter";
    comment?: string;
    /** Indicates how long the account should remain muted. Falsy value here means a permanent mute. */
    durationInHours?: number;
  }
  /** Report a subject */
  interface ModEventReport {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventReport";
    reportType: ComAtprotoModerationDefs.ReasonType;
    comment?: string;
    /** Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject. */
    isReporterMuted?: boolean;
  }
  /** Resolve appeal on a subject */
  interface ModEventResolveAppeal {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventResolveAppeal";
    /** Describe resolution. */
    comment?: string;
  }
  /** Revert take down action on a subject */
  interface ModEventReverseTakedown {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventReverseTakedown";
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  /** Add/Remove a tag on a subject */
  interface ModEventTag {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventTag";
    /** Tags to be added to the subject. If already exists, won't be duplicated. */
    add: string[];
    /** Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated. */
    remove: string[];
    /** Additional comment about added/removed tags. */
    comment?: string;
  }
  /** Take down a subject permanently or temporarily */
  interface ModEventTakedown {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventTakedown";
    /** If true, all other reports on content authored by this account will be resolved (acknowledged). */
    acknowledgeAccountSubjects?: boolean;
    comment?: string;
    /** Indicates how long the takedown should be in effect before automatically expiring. */
    durationInHours?: number;
  }
  /** Unmute action on a subject */
  interface ModEventUnmute {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventUnmute";
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  /** Unmute incoming reports from an account */
  interface ModEventUnmuteReporter {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventUnmuteReporter";
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  interface ModEventView {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventView";
    createdAt: string;
    createdBy: At.DID;
    event: Brand.Union<
      | AccountEvent
      | IdentityEvent
      | ModEventAcknowledge
      | ModEventComment
      | ModEventDivert
      | ModEventEmail
      | ModEventEscalate
      | ModEventLabel
      | ModEventMute
      | ModEventMuteReporter
      | ModEventReport
      | ModEventResolveAppeal
      | ModEventReverseTakedown
      | ModEventTag
      | ModEventTakedown
      | ModEventUnmute
      | ModEventUnmuteReporter
      | RecordEvent
    >;
    id: number;
    subject: Brand.Union<
      | ChatBskyConvoDefs.MessageRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    subjectBlobCids: string[];
    creatorHandle?: string;
    subjectHandle?: string;
  }
  interface ModEventViewDetail {
    [Brand.Type]: "tools.ozone.moderation.defs#modEventViewDetail";
    createdAt: string;
    createdBy: At.DID;
    event: Brand.Union<
      | AccountEvent
      | IdentityEvent
      | ModEventAcknowledge
      | ModEventComment
      | ModEventDivert
      | ModEventEmail
      | ModEventEscalate
      | ModEventLabel
      | ModEventMute
      | ModEventMuteReporter
      | ModEventReport
      | ModEventResolveAppeal
      | ModEventReverseTakedown
      | ModEventTag
      | ModEventTakedown
      | ModEventUnmute
      | ModEventUnmuteReporter
      | RecordEvent
    >;
    id: number;
    subject: Brand.Union<
      RecordView | RecordViewNotFound | RepoView | RepoViewNotFound
    >;
    subjectBlobs: BlobView[];
  }
  /** Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface RecordEvent {
    [Brand.Type]: "tools.ozone.moderation.defs#recordEvent";
    op: "create" | "delete" | "update" | (string & {});
    timestamp: string;
    cid?: At.CID;
    comment?: string;
  }
  interface RecordHosting {
    [Brand.Type]: "tools.ozone.moderation.defs#recordHosting";
    status: "deleted" | "unknown" | (string & {});
    createdAt?: string;
    deletedAt?: string;
    updatedAt?: string;
  }
  interface RecordView {
    [Brand.Type]: "tools.ozone.moderation.defs#recordView";
    blobCids: At.CID[];
    cid: At.CID;
    indexedAt: string;
    moderation: Moderation;
    repo: RepoView;
    uri: At.Uri;
    value: unknown;
  }
  interface RecordViewDetail {
    [Brand.Type]: "tools.ozone.moderation.defs#recordViewDetail";
    blobs: BlobView[];
    cid: At.CID;
    indexedAt: string;
    moderation: ModerationDetail;
    repo: RepoView;
    uri: At.Uri;
    value: unknown;
    labels?: ComAtprotoLabelDefs.Label[];
  }
  interface RecordViewNotFound {
    [Brand.Type]: "tools.ozone.moderation.defs#recordViewNotFound";
    uri: At.Uri;
  }
  interface RepoView {
    [Brand.Type]: "tools.ozone.moderation.defs#repoView";
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    moderation: Moderation;
    relatedRecords: unknown[];
    deactivatedAt?: string;
    email?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invitesDisabled?: boolean;
    threatSignatures?: ComAtprotoAdminDefs.ThreatSignature[];
  }
  interface RepoViewDetail {
    [Brand.Type]: "tools.ozone.moderation.defs#repoViewDetail";
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    moderation: ModerationDetail;
    relatedRecords: unknown[];
    deactivatedAt?: string;
    email?: string;
    emailConfirmedAt?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invites?: ComAtprotoServerDefs.InviteCode[];
    invitesDisabled?: boolean;
    labels?: ComAtprotoLabelDefs.Label[];
    threatSignatures?: ComAtprotoAdminDefs.ThreatSignature[];
  }
  interface RepoViewNotFound {
    [Brand.Type]: "tools.ozone.moderation.defs#repoViewNotFound";
    did: At.DID;
  }
  type ReviewClosed = "tools.ozone.moderation.defs#reviewClosed";
  type ReviewEscalated = "tools.ozone.moderation.defs#reviewEscalated";
  type ReviewNone = "tools.ozone.moderation.defs#reviewNone";
  type ReviewOpen = "tools.ozone.moderation.defs#reviewOpen";
  type SubjectReviewState =
    | "#reviewClosed"
    | "#reviewEscalated"
    | "#reviewNone"
    | "#reviewOpen"
    | (string & {});
  interface SubjectStatusView {
    [Brand.Type]: "tools.ozone.moderation.defs#subjectStatusView";
    /** Timestamp referencing the first moderation status impacting event was emitted on the subject */
    createdAt: string;
    id: number;
    reviewState: SubjectReviewState;
    subject: Brand.Union<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /** Timestamp referencing when the last update was made to the moderation status of the subject */
    updatedAt: string;
    /** True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators. */
    appealed?: boolean;
    /** Sticky comment on the subject. */
    comment?: string;
    hosting?: Brand.Union<AccountHosting | RecordHosting>;
    /** Timestamp referencing when the author of the subject appealed a moderation action */
    lastAppealedAt?: string;
    lastReportedAt?: string;
    lastReviewedAt?: string;
    lastReviewedBy?: At.DID;
    muteReportingUntil?: string;
    muteUntil?: string;
    subjectBlobCids?: At.CID[];
    subjectRepoHandle?: string;
    suspendUntil?: string;
    tags?: string[];
    takendown?: boolean;
  }
  interface VideoDetails {
    [Brand.Type]: "tools.ozone.moderation.defs#videoDetails";
    height: number;
    length: number;
    width: number;
  }
}

/** Take a moderation action on an actor. */
export declare namespace ToolsOzoneModerationEmitEvent {
  interface Params {}
  interface Input {
    createdBy: At.DID;
    event: Brand.Union<
      | ToolsOzoneModerationDefs.AccountEvent
      | ToolsOzoneModerationDefs.IdentityEvent
      | ToolsOzoneModerationDefs.ModEventAcknowledge
      | ToolsOzoneModerationDefs.ModEventComment
      | ToolsOzoneModerationDefs.ModEventEmail
      | ToolsOzoneModerationDefs.ModEventEscalate
      | ToolsOzoneModerationDefs.ModEventLabel
      | ToolsOzoneModerationDefs.ModEventMute
      | ToolsOzoneModerationDefs.ModEventMuteReporter
      | ToolsOzoneModerationDefs.ModEventReport
      | ToolsOzoneModerationDefs.ModEventResolveAppeal
      | ToolsOzoneModerationDefs.ModEventReverseTakedown
      | ToolsOzoneModerationDefs.ModEventTag
      | ToolsOzoneModerationDefs.ModEventTakedown
      | ToolsOzoneModerationDefs.ModEventUnmute
      | ToolsOzoneModerationDefs.ModEventUnmuteReporter
      | ToolsOzoneModerationDefs.RecordEvent
    >;
    subject: Brand.Union<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    subjectBlobCids?: At.CID[];
  }
  type Output = ToolsOzoneModerationDefs.ModEventView;
  interface Errors {
    SubjectHasAction: {};
  }
}

/** Get details about a moderation event. */
export declare namespace ToolsOzoneModerationGetEvent {
  interface Params {
    id: number;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.ModEventViewDetail;
}

/** Get details about a record. */
export declare namespace ToolsOzoneModerationGetRecord {
  interface Params {
    uri: At.Uri;
    cid?: At.CID;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.RecordViewDetail;
  interface Errors {
    RecordNotFound: {};
  }
}

/** Get details about some records. */
export declare namespace ToolsOzoneModerationGetRecords {
  interface Params {
    /** Maximum array length: 100 */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output {
    records: Brand.Union<
      | ToolsOzoneModerationDefs.RecordViewDetail
      | ToolsOzoneModerationDefs.RecordViewNotFound
    >[];
  }
}

/** Get details about a repository. */
export declare namespace ToolsOzoneModerationGetRepo {
  interface Params {
    did: At.DID;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.RepoViewDetail;
  interface Errors {
    RepoNotFound: {};
  }
}

/** Get details about some repositories. */
export declare namespace ToolsOzoneModerationGetRepos {
  interface Params {
    /** Maximum array length: 100 */
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output {
    repos: Brand.Union<
      | ToolsOzoneModerationDefs.RepoViewDetail
      | ToolsOzoneModerationDefs.RepoViewNotFound
    >[];
  }
}

/** List moderation events related to a subject. */
export declare namespace ToolsOzoneModerationQueryEvents {
  interface Params {
    /** If specified, only events where all of these labels were added are returned */
    addedLabels?: string[];
    /** If specified, only events where all of these tags were added are returned */
    addedTags?: string[];
    /**
     * If specified, only events where the subject belongs to the given collections will be returned. When subjectType is set to 'account', this will be ignored.
     * Maximum array length: 20
     */
    collections?: string[];
    /** If specified, only events with comments containing the keyword are returned. Apply || separator to use multiple keywords and match using OR condition. */
    comment?: string;
    /** Retrieve events created after a given timestamp */
    createdAfter?: string;
    /** Retrieve events created before a given timestamp */
    createdBefore?: string;
    createdBy?: At.DID;
    cursor?: string;
    /** If true, only events with comments are returned */
    hasComment?: boolean;
    /**
     * If true, events on all record types (posts, lists, profile etc.) or records from given 'collections' param, owned by the did are returned.
     * \@default false
     */
    includeAllUserRecords?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** If specified, only events where all of these labels were removed are returned */
    removedLabels?: string[];
    /** If specified, only events where all of these tags were removed are returned */
    removedTags?: string[];
    reportTypes?: string[];
    /**
     * Sort direction for the events. Defaults to descending order of created at timestamp.
     * \@default "desc"
     */
    sortDirection?: "asc" | "desc";
    subject?: string;
    /** If specified, only events where the subject is of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored. */
    subjectType?: "account" | "record" | (string & {});
    /** The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned. */
    types?: string[];
  }
  type Input = undefined;
  interface Output {
    events: ToolsOzoneModerationDefs.ModEventView[];
    cursor?: string;
  }
}

/** View moderation statuses of subjects (record or repo). */
export declare namespace ToolsOzoneModerationQueryStatuses {
  interface Params {
    /** Get subjects in unresolved appealed status */
    appealed?: boolean;
    /**
     * If specified, subjects belonging to the given collections will be returned. When subjectType is set to 'account', this will be ignored.
     * Maximum array length: 20
     */
    collections?: string[];
    /** Search subjects by keyword from comments */
    comment?: string;
    cursor?: string;
    excludeTags?: string[];
    /** Search subjects where the associated record/account was deleted after a given timestamp */
    hostingDeletedAfter?: string;
    /** Search subjects where the associated record/account was deleted before a given timestamp */
    hostingDeletedBefore?: string;
    /** Search subjects by the status of the associated record/account */
    hostingStatuses?: string[];
    /** Search subjects where the associated record/account was updated after a given timestamp */
    hostingUpdatedAfter?: string;
    /** Search subjects where the associated record/account was updated before a given timestamp */
    hostingUpdatedBefore?: string;
    ignoreSubjects?: string[];
    /** All subjects, or subjects from given 'collections' param, belonging to the account specified in the 'subject' param will be returned. */
    includeAllUserRecords?: boolean;
    /** By default, we don't include muted subjects in the results. Set this to true to include them. */
    includeMuted?: boolean;
    /** Get all subject statuses that were reviewed by a specific moderator */
    lastReviewedBy?: At.DID;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** When set to true, only muted subjects and reporters will be returned. */
    onlyMuted?: boolean;
    /** Search subjects reported after a given timestamp */
    reportedAfter?: string;
    /** Search subjects reported before a given timestamp */
    reportedBefore?: string;
    /** Search subjects reviewed after a given timestamp */
    reviewedAfter?: string;
    /** Search subjects reviewed before a given timestamp */
    reviewedBefore?: string;
    /** Specify when fetching subjects in a certain state */
    reviewState?: string;
    /** \@default "desc" */
    sortDirection?: "asc" | "desc";
    /** \@default "lastReportedAt" */
    sortField?: "lastReviewedAt" | "lastReportedAt";
    /** The subject to get the status for. */
    subject?: string;
    /** If specified, subjects of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored. */
    subjectType?: "account" | "record" | (string & {});
    tags?: string[];
    /** Get subjects that were taken down */
    takendown?: boolean;
  }
  type Input = undefined;
  interface Output {
    subjectStatuses: ToolsOzoneModerationDefs.SubjectStatusView[];
    cursor?: string;
  }
}

/** Find repositories based on a search term. */
export declare namespace ToolsOzoneModerationSearchRepos {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    q?: string;
    /**
     * DEPRECATED: use 'q' instead
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output {
    repos: ToolsOzoneModerationDefs.RepoView[];
    cursor?: string;
  }
}

/** Get details about ozone's server configuration. */
export declare namespace ToolsOzoneServerGetConfig {
  interface Params {}
  type Input = undefined;
  interface Output {
    appview?: ServiceConfig;
    blobDivert?: ServiceConfig;
    chat?: ServiceConfig;
    pds?: ServiceConfig;
    viewer?: ViewerConfig;
  }
  interface ServiceConfig {
    [Brand.Type]: "tools.ozone.server.getConfig#serviceConfig";
    url?: string;
  }
  interface ViewerConfig {
    [Brand.Type]: "tools.ozone.server.getConfig#viewerConfig";
    role?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
}

/** Add values to a specific set. Attempting to add values to a set that does not exist will result in an error. */
export declare namespace ToolsOzoneSetAddValues {
  interface Params {}
  interface Input {
    /** Name of the set to add values to */
    name: string;
    /**
     * Array of string values to add to the set
     * Minimum array length: 1
     * Maximum array length: 1000
     */
    values: string[];
  }
  type Output = undefined;
}

export declare namespace ToolsOzoneSetDefs {
  interface Set {
    [Brand.Type]: "tools.ozone.set.defs#set";
    /**
     * Minimum string length: 3
     * Maximum string length: 128
     */
    name: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
  }
  interface SetView {
    [Brand.Type]: "tools.ozone.set.defs#setView";
    createdAt: string;
    /**
     * Minimum string length: 3
     * Maximum string length: 128
     */
    name: string;
    setSize: number;
    updatedAt: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
  }
}

/** Delete an entire set. Attempting to delete a set that does not exist will result in an error. */
export declare namespace ToolsOzoneSetDeleteSet {
  interface Params {}
  interface Input {
    /** Name of the set to delete */
    name: string;
  }
  interface Output {}
  interface Errors {
    SetNotFound: {};
  }
}

/** Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error */
export declare namespace ToolsOzoneSetDeleteValues {
  interface Params {}
  interface Input {
    /** Name of the set to delete values from */
    name: string;
    /**
     * Array of string values to delete from the set
     * Minimum array length: 1
     */
    values: string[];
  }
  type Output = undefined;
  interface Errors {
    SetNotFound: {};
  }
}

/** Get a specific set and its values */
export declare namespace ToolsOzoneSetGetValues {
  interface Params {
    name: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 100
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    set: ToolsOzoneSetDefs.SetView;
    values: string[];
    cursor?: string;
  }
  interface Errors {
    SetNotFound: {};
  }
}

/** Query available sets */
export declare namespace ToolsOzoneSetQuerySets {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    namePrefix?: string;
    /** \@default "name" */
    sortBy?: "name" | "createdAt" | "updatedAt";
    /**
     * Defaults to ascending order of name field.
     * \@default "asc"
     */
    sortDirection?: "asc" | "desc";
  }
  type Input = undefined;
  interface Output {
    sets: ToolsOzoneSetDefs.SetView[];
    cursor?: string;
  }
}

/** Create or update set metadata */
export declare namespace ToolsOzoneSetUpsertSet {
  interface Params {}
  type Input = ToolsOzoneSetDefs.Set;
  type Output = ToolsOzoneSetDefs.SetView;
}

export declare namespace ToolsOzoneSettingDefs {
  interface Option {
    [Brand.Type]: "tools.ozone.setting.defs#option";
    createdBy: At.DID;
    did: At.DID;
    key: string;
    lastUpdatedBy: At.DID;
    scope: "instance" | "personal" | (string & {});
    value: unknown;
    createdAt?: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
    managerRole?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
    updatedAt?: string;
  }
}

/** List settings with optional filtering */
export declare namespace ToolsOzoneSettingListOptions {
  interface Params {
    cursor?: string;
    /**
     * Filter for only the specified keys. Ignored if prefix is provided
     * Maximum array length: 100
     */
    keys?: string[];
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Filter keys by prefix */
    prefix?: string;
    /** \@default "instance" */
    scope?: "instance" | "personal" | (string & {});
  }
  type Input = undefined;
  interface Output {
    options: ToolsOzoneSettingDefs.Option[];
    cursor?: string;
  }
}

/** Delete settings by key */
export declare namespace ToolsOzoneSettingRemoveOptions {
  interface Params {}
  interface Input {
    /**
     * Minimum array length: 1
     * Maximum array length: 200
     */
    keys: string[];
    scope: "instance" | "personal" | (string & {});
  }
  interface Output {}
}

/** Create or update setting option */
export declare namespace ToolsOzoneSettingUpsertOption {
  interface Params {}
  interface Input {
    key: string;
    scope: "instance" | "personal" | (string & {});
    value: unknown;
    /** Maximum string length: 2000 */
    description?: string;
    managerRole?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
  interface Output {
    option: ToolsOzoneSettingDefs.Option;
  }
}

export declare namespace ToolsOzoneSignatureDefs {
  interface SigDetail {
    [Brand.Type]: "tools.ozone.signature.defs#sigDetail";
    property: string;
    value: string;
  }
}

/** Find all correlated threat signatures between 2 or more accounts. */
export declare namespace ToolsOzoneSignatureFindCorrelation {
  interface Params {
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output {
    details: ToolsOzoneSignatureDefs.SigDetail[];
  }
}

/** Get accounts that share some matching threat signatures with the root account. */
export declare namespace ToolsOzoneSignatureFindRelatedAccounts {
  interface Params {
    did: At.DID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    accounts: RelatedAccount[];
    cursor?: string;
  }
  interface RelatedAccount {
    [Brand.Type]: "tools.ozone.signature.findRelatedAccounts#relatedAccount";
    account: ComAtprotoAdminDefs.AccountView;
    similarities?: ToolsOzoneSignatureDefs.SigDetail[];
  }
}

/** Search for accounts that match one or more threat signature values. */
export declare namespace ToolsOzoneSignatureSearchAccounts {
  interface Params {
    values: string[];
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    accounts: ComAtprotoAdminDefs.AccountView[];
    cursor?: string;
  }
}

/** Add a member to the ozone team. Requires admin role. */
export declare namespace ToolsOzoneTeamAddMember {
  interface Params {}
  interface Input {
    did: At.DID;
    role:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
  type Output = ToolsOzoneTeamDefs.Member;
  interface Errors {
    MemberAlreadyExists: {};
  }
}

export declare namespace ToolsOzoneTeamDefs {
  interface Member {
    [Brand.Type]: "tools.ozone.team.defs#member";
    did: At.DID;
    role: "#roleAdmin" | "#roleModerator" | "#roleTriage" | (string & {});
    createdAt?: string;
    disabled?: boolean;
    lastUpdatedBy?: string;
    profile?: AppBskyActorDefs.ProfileViewDetailed;
    updatedAt?: string;
  }
  type RoleAdmin = "tools.ozone.team.defs#roleAdmin";
  type RoleModerator = "tools.ozone.team.defs#roleModerator";
  type RoleTriage = "tools.ozone.team.defs#roleTriage";
}

/** Delete a member from ozone team. Requires admin role. */
export declare namespace ToolsOzoneTeamDeleteMember {
  interface Params {}
  interface Input {
    did: At.DID;
  }
  type Output = undefined;
  interface Errors {
    MemberNotFound: {};
    CannotDeleteSelf: {};
  }
}

/** List all members with access to the ozone service. */
export declare namespace ToolsOzoneTeamListMembers {
  interface Params {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output {
    members: ToolsOzoneTeamDefs.Member[];
    cursor?: string;
  }
}

/** Update a member in the ozone service. Requires admin role. */
export declare namespace ToolsOzoneTeamUpdateMember {
  interface Params {}
  interface Input {
    did: At.DID;
    disabled?: boolean;
    role?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
  type Output = ToolsOzoneTeamDefs.Member;
  interface Errors {
    MemberNotFound: {};
  }
}

export declare interface Records {
  "app.bsky.actor.profile": AppBskyActorProfile.Record;
  "app.bsky.feed.generator": AppBskyFeedGenerator.Record;
  "app.bsky.feed.like": AppBskyFeedLike.Record;
  "app.bsky.feed.post": AppBskyFeedPost.Record;
  "app.bsky.feed.postgate": AppBskyFeedPostgate.Record;
  "app.bsky.feed.repost": AppBskyFeedRepost.Record;
  "app.bsky.feed.threadgate": AppBskyFeedThreadgate.Record;
  "app.bsky.graph.block": AppBskyGraphBlock.Record;
  "app.bsky.graph.follow": AppBskyGraphFollow.Record;
  "app.bsky.graph.list": AppBskyGraphList.Record;
  "app.bsky.graph.listblock": AppBskyGraphListblock.Record;
  "app.bsky.graph.listitem": AppBskyGraphListitem.Record;
  "app.bsky.graph.starterpack": AppBskyGraphStarterpack.Record;
  "app.bsky.labeler.service": AppBskyLabelerService.Record;
  "chat.bsky.actor.declaration": ChatBskyActorDeclaration.Record;
}

export declare interface Queries {
  "app.bsky.actor.getPreferences": {
    output: AppBskyActorGetPreferences.Output;
  };
  "app.bsky.actor.getProfile": {
    params: AppBskyActorGetProfile.Params;
    output: AppBskyActorGetProfile.Output;
  };
  "app.bsky.actor.getProfiles": {
    params: AppBskyActorGetProfiles.Params;
    output: AppBskyActorGetProfiles.Output;
  };
  "app.bsky.actor.getSuggestions": {
    params: AppBskyActorGetSuggestions.Params;
    output: AppBskyActorGetSuggestions.Output;
  };
  "app.bsky.actor.searchActors": {
    params: AppBskyActorSearchActors.Params;
    output: AppBskyActorSearchActors.Output;
  };
  "app.bsky.actor.searchActorsTypeahead": {
    params: AppBskyActorSearchActorsTypeahead.Params;
    output: AppBskyActorSearchActorsTypeahead.Output;
  };
  "app.bsky.feed.describeFeedGenerator": {
    output: AppBskyFeedDescribeFeedGenerator.Output;
  };
  "app.bsky.feed.getActorFeeds": {
    params: AppBskyFeedGetActorFeeds.Params;
    output: AppBskyFeedGetActorFeeds.Output;
  };
  "app.bsky.feed.getActorLikes": {
    params: AppBskyFeedGetActorLikes.Params;
    output: AppBskyFeedGetActorLikes.Output;
  };
  "app.bsky.feed.getAuthorFeed": {
    params: AppBskyFeedGetAuthorFeed.Params;
    output: AppBskyFeedGetAuthorFeed.Output;
  };
  "app.bsky.feed.getFeed": {
    params: AppBskyFeedGetFeed.Params;
    output: AppBskyFeedGetFeed.Output;
  };
  "app.bsky.feed.getFeedGenerator": {
    params: AppBskyFeedGetFeedGenerator.Params;
    output: AppBskyFeedGetFeedGenerator.Output;
  };
  "app.bsky.feed.getFeedGenerators": {
    params: AppBskyFeedGetFeedGenerators.Params;
    output: AppBskyFeedGetFeedGenerators.Output;
  };
  "app.bsky.feed.getFeedSkeleton": {
    params: AppBskyFeedGetFeedSkeleton.Params;
    output: AppBskyFeedGetFeedSkeleton.Output;
  };
  "app.bsky.feed.getLikes": {
    params: AppBskyFeedGetLikes.Params;
    output: AppBskyFeedGetLikes.Output;
  };
  "app.bsky.feed.getListFeed": {
    params: AppBskyFeedGetListFeed.Params;
    output: AppBskyFeedGetListFeed.Output;
  };
  "app.bsky.feed.getPosts": {
    params: AppBskyFeedGetPosts.Params;
    output: AppBskyFeedGetPosts.Output;
  };
  "app.bsky.feed.getPostThread": {
    params: AppBskyFeedGetPostThread.Params;
    output: AppBskyFeedGetPostThread.Output;
  };
  "app.bsky.feed.getQuotes": {
    params: AppBskyFeedGetQuotes.Params;
    output: AppBskyFeedGetQuotes.Output;
  };
  "app.bsky.feed.getRepostedBy": {
    params: AppBskyFeedGetRepostedBy.Params;
    output: AppBskyFeedGetRepostedBy.Output;
  };
  "app.bsky.feed.getSuggestedFeeds": {
    params: AppBskyFeedGetSuggestedFeeds.Params;
    output: AppBskyFeedGetSuggestedFeeds.Output;
  };
  "app.bsky.feed.getTimeline": {
    params: AppBskyFeedGetTimeline.Params;
    output: AppBskyFeedGetTimeline.Output;
  };
  "app.bsky.feed.searchPosts": {
    params: AppBskyFeedSearchPosts.Params;
    output: AppBskyFeedSearchPosts.Output;
  };
  "app.bsky.graph.getActorStarterPacks": {
    params: AppBskyGraphGetActorStarterPacks.Params;
    output: AppBskyGraphGetActorStarterPacks.Output;
  };
  "app.bsky.graph.getBlocks": {
    params: AppBskyGraphGetBlocks.Params;
    output: AppBskyGraphGetBlocks.Output;
  };
  "app.bsky.graph.getFollowers": {
    params: AppBskyGraphGetFollowers.Params;
    output: AppBskyGraphGetFollowers.Output;
  };
  "app.bsky.graph.getFollows": {
    params: AppBskyGraphGetFollows.Params;
    output: AppBskyGraphGetFollows.Output;
  };
  "app.bsky.graph.getKnownFollowers": {
    params: AppBskyGraphGetKnownFollowers.Params;
    output: AppBskyGraphGetKnownFollowers.Output;
  };
  "app.bsky.graph.getList": {
    params: AppBskyGraphGetList.Params;
    output: AppBskyGraphGetList.Output;
  };
  "app.bsky.graph.getListBlocks": {
    params: AppBskyGraphGetListBlocks.Params;
    output: AppBskyGraphGetListBlocks.Output;
  };
  "app.bsky.graph.getListMutes": {
    params: AppBskyGraphGetListMutes.Params;
    output: AppBskyGraphGetListMutes.Output;
  };
  "app.bsky.graph.getLists": {
    params: AppBskyGraphGetLists.Params;
    output: AppBskyGraphGetLists.Output;
  };
  "app.bsky.graph.getMutes": {
    params: AppBskyGraphGetMutes.Params;
    output: AppBskyGraphGetMutes.Output;
  };
  "app.bsky.graph.getRelationships": {
    params: AppBskyGraphGetRelationships.Params;
    output: AppBskyGraphGetRelationships.Output;
  };
  "app.bsky.graph.getStarterPack": {
    params: AppBskyGraphGetStarterPack.Params;
    output: AppBskyGraphGetStarterPack.Output;
  };
  "app.bsky.graph.getStarterPacks": {
    params: AppBskyGraphGetStarterPacks.Params;
    output: AppBskyGraphGetStarterPacks.Output;
  };
  "app.bsky.graph.getSuggestedFollowsByActor": {
    params: AppBskyGraphGetSuggestedFollowsByActor.Params;
    output: AppBskyGraphGetSuggestedFollowsByActor.Output;
  };
  "app.bsky.graph.searchStarterPacks": {
    params: AppBskyGraphSearchStarterPacks.Params;
    output: AppBskyGraphSearchStarterPacks.Output;
  };
  "app.bsky.labeler.getServices": {
    params: AppBskyLabelerGetServices.Params;
    output: AppBskyLabelerGetServices.Output;
  };
  "app.bsky.notification.getUnreadCount": {
    params: AppBskyNotificationGetUnreadCount.Params;
    output: AppBskyNotificationGetUnreadCount.Output;
  };
  "app.bsky.notification.listNotifications": {
    params: AppBskyNotificationListNotifications.Params;
    output: AppBskyNotificationListNotifications.Output;
  };
  "app.bsky.unspecced.getConfig": {
    output: AppBskyUnspeccedGetConfig.Output;
  };
  "app.bsky.unspecced.getPopularFeedGenerators": {
    params: AppBskyUnspeccedGetPopularFeedGenerators.Params;
    output: AppBskyUnspeccedGetPopularFeedGenerators.Output;
  };
  "app.bsky.unspecced.getSuggestionsSkeleton": {
    params: AppBskyUnspeccedGetSuggestionsSkeleton.Params;
    output: AppBskyUnspeccedGetSuggestionsSkeleton.Output;
  };
  "app.bsky.unspecced.getTaggedSuggestions": {
    output: AppBskyUnspeccedGetTaggedSuggestions.Output;
  };
  "app.bsky.unspecced.searchActorsSkeleton": {
    params: AppBskyUnspeccedSearchActorsSkeleton.Params;
    output: AppBskyUnspeccedSearchActorsSkeleton.Output;
  };
  "app.bsky.unspecced.searchPostsSkeleton": {
    params: AppBskyUnspeccedSearchPostsSkeleton.Params;
    output: AppBskyUnspeccedSearchPostsSkeleton.Output;
  };
  "app.bsky.unspecced.searchStarterPacksSkeleton": {
    params: AppBskyUnspeccedSearchStarterPacksSkeleton.Params;
    output: AppBskyUnspeccedSearchStarterPacksSkeleton.Output;
  };
  "app.bsky.video.getJobStatus": {
    params: AppBskyVideoGetJobStatus.Params;
    output: AppBskyVideoGetJobStatus.Output;
  };
  "app.bsky.video.getUploadLimits": {
    output: AppBskyVideoGetUploadLimits.Output;
  };
  "chat.bsky.actor.exportAccountData": {
    output: ChatBskyActorExportAccountData.Output;
  };
  "chat.bsky.convo.getConvo": {
    params: ChatBskyConvoGetConvo.Params;
    output: ChatBskyConvoGetConvo.Output;
  };
  "chat.bsky.convo.getConvoForMembers": {
    params: ChatBskyConvoGetConvoForMembers.Params;
    output: ChatBskyConvoGetConvoForMembers.Output;
  };
  "chat.bsky.convo.getLog": {
    params: ChatBskyConvoGetLog.Params;
    output: ChatBskyConvoGetLog.Output;
  };
  "chat.bsky.convo.getMessages": {
    params: ChatBskyConvoGetMessages.Params;
    output: ChatBskyConvoGetMessages.Output;
  };
  "chat.bsky.convo.listConvos": {
    params: ChatBskyConvoListConvos.Params;
    output: ChatBskyConvoListConvos.Output;
  };
  "chat.bsky.moderation.getActorMetadata": {
    params: ChatBskyModerationGetActorMetadata.Params;
    output: ChatBskyModerationGetActorMetadata.Output;
  };
  "chat.bsky.moderation.getMessageContext": {
    params: ChatBskyModerationGetMessageContext.Params;
    output: ChatBskyModerationGetMessageContext.Output;
  };
  "com.atproto.admin.getAccountInfo": {
    params: ComAtprotoAdminGetAccountInfo.Params;
    output: ComAtprotoAdminGetAccountInfo.Output;
  };
  "com.atproto.admin.getAccountInfos": {
    params: ComAtprotoAdminGetAccountInfos.Params;
    output: ComAtprotoAdminGetAccountInfos.Output;
  };
  "com.atproto.admin.getInviteCodes": {
    params: ComAtprotoAdminGetInviteCodes.Params;
    output: ComAtprotoAdminGetInviteCodes.Output;
  };
  "com.atproto.admin.getSubjectStatus": {
    params: ComAtprotoAdminGetSubjectStatus.Params;
    output: ComAtprotoAdminGetSubjectStatus.Output;
  };
  "com.atproto.admin.searchAccounts": {
    params: ComAtprotoAdminSearchAccounts.Params;
    output: ComAtprotoAdminSearchAccounts.Output;
  };
  "com.atproto.identity.getRecommendedDidCredentials": {
    output: ComAtprotoIdentityGetRecommendedDidCredentials.Output;
  };
  "com.atproto.identity.resolveHandle": {
    params: ComAtprotoIdentityResolveHandle.Params;
    output: ComAtprotoIdentityResolveHandle.Output;
  };
  "com.atproto.label.queryLabels": {
    params: ComAtprotoLabelQueryLabels.Params;
    output: ComAtprotoLabelQueryLabels.Output;
  };
  "com.atproto.repo.describeRepo": {
    params: ComAtprotoRepoDescribeRepo.Params;
    output: ComAtprotoRepoDescribeRepo.Output;
  };
  "com.atproto.repo.getRecord": {
    params: ComAtprotoRepoGetRecord.Params;
    output: ComAtprotoRepoGetRecord.Output;
  };
  "com.atproto.repo.listMissingBlobs": {
    params: ComAtprotoRepoListMissingBlobs.Params;
    output: ComAtprotoRepoListMissingBlobs.Output;
  };
  "com.atproto.repo.listRecords": {
    params: ComAtprotoRepoListRecords.Params;
    output: ComAtprotoRepoListRecords.Output;
  };
  "com.atproto.server.checkAccountStatus": {
    output: ComAtprotoServerCheckAccountStatus.Output;
  };
  "com.atproto.server.describeServer": {
    output: ComAtprotoServerDescribeServer.Output;
  };
  "com.atproto.server.getAccountInviteCodes": {
    params: ComAtprotoServerGetAccountInviteCodes.Params;
    output: ComAtprotoServerGetAccountInviteCodes.Output;
  };
  "com.atproto.server.getServiceAuth": {
    params: ComAtprotoServerGetServiceAuth.Params;
    output: ComAtprotoServerGetServiceAuth.Output;
  };
  "com.atproto.server.getSession": {
    output: ComAtprotoServerGetSession.Output;
  };
  "com.atproto.server.listAppPasswords": {
    output: ComAtprotoServerListAppPasswords.Output;
  };
  "com.atproto.sync.getBlob": {
    params: ComAtprotoSyncGetBlob.Params;
    output: ComAtprotoSyncGetBlob.Output;
  };
  "com.atproto.sync.getBlocks": {
    params: ComAtprotoSyncGetBlocks.Params;
    output: ComAtprotoSyncGetBlocks.Output;
  };
  "com.atproto.sync.getCheckout": {
    params: ComAtprotoSyncGetCheckout.Params;
    output: ComAtprotoSyncGetCheckout.Output;
  };
  "com.atproto.sync.getHead": {
    params: ComAtprotoSyncGetHead.Params;
    output: ComAtprotoSyncGetHead.Output;
  };
  "com.atproto.sync.getLatestCommit": {
    params: ComAtprotoSyncGetLatestCommit.Params;
    output: ComAtprotoSyncGetLatestCommit.Output;
  };
  "com.atproto.sync.getRecord": {
    params: ComAtprotoSyncGetRecord.Params;
    output: ComAtprotoSyncGetRecord.Output;
  };
  "com.atproto.sync.getRepo": {
    params: ComAtprotoSyncGetRepo.Params;
    output: ComAtprotoSyncGetRepo.Output;
  };
  "com.atproto.sync.getRepoStatus": {
    params: ComAtprotoSyncGetRepoStatus.Params;
    output: ComAtprotoSyncGetRepoStatus.Output;
  };
  "com.atproto.sync.listBlobs": {
    params: ComAtprotoSyncListBlobs.Params;
    output: ComAtprotoSyncListBlobs.Output;
  };
  "com.atproto.sync.listRepos": {
    params: ComAtprotoSyncListRepos.Params;
    output: ComAtprotoSyncListRepos.Output;
  };
  "com.atproto.temp.checkSignupQueue": {
    output: ComAtprotoTempCheckSignupQueue.Output;
  };
  "com.atproto.temp.fetchLabels": {
    params: ComAtprotoTempFetchLabels.Params;
    output: ComAtprotoTempFetchLabels.Output;
  };
  "tools.ozone.communication.listTemplates": {
    output: ToolsOzoneCommunicationListTemplates.Output;
  };
  "tools.ozone.moderation.getEvent": {
    params: ToolsOzoneModerationGetEvent.Params;
    output: ToolsOzoneModerationGetEvent.Output;
  };
  "tools.ozone.moderation.getRecord": {
    params: ToolsOzoneModerationGetRecord.Params;
    output: ToolsOzoneModerationGetRecord.Output;
  };
  "tools.ozone.moderation.getRecords": {
    params: ToolsOzoneModerationGetRecords.Params;
    output: ToolsOzoneModerationGetRecords.Output;
  };
  "tools.ozone.moderation.getRepo": {
    params: ToolsOzoneModerationGetRepo.Params;
    output: ToolsOzoneModerationGetRepo.Output;
  };
  "tools.ozone.moderation.getRepos": {
    params: ToolsOzoneModerationGetRepos.Params;
    output: ToolsOzoneModerationGetRepos.Output;
  };
  "tools.ozone.moderation.queryEvents": {
    params: ToolsOzoneModerationQueryEvents.Params;
    output: ToolsOzoneModerationQueryEvents.Output;
  };
  "tools.ozone.moderation.queryStatuses": {
    params: ToolsOzoneModerationQueryStatuses.Params;
    output: ToolsOzoneModerationQueryStatuses.Output;
  };
  "tools.ozone.moderation.searchRepos": {
    params: ToolsOzoneModerationSearchRepos.Params;
    output: ToolsOzoneModerationSearchRepos.Output;
  };
  "tools.ozone.server.getConfig": {
    output: ToolsOzoneServerGetConfig.Output;
  };
  "tools.ozone.set.getValues": {
    params: ToolsOzoneSetGetValues.Params;
    output: ToolsOzoneSetGetValues.Output;
  };
  "tools.ozone.set.querySets": {
    params: ToolsOzoneSetQuerySets.Params;
    output: ToolsOzoneSetQuerySets.Output;
  };
  "tools.ozone.setting.listOptions": {
    params: ToolsOzoneSettingListOptions.Params;
    output: ToolsOzoneSettingListOptions.Output;
  };
  "tools.ozone.signature.findCorrelation": {
    params: ToolsOzoneSignatureFindCorrelation.Params;
    output: ToolsOzoneSignatureFindCorrelation.Output;
  };
  "tools.ozone.signature.findRelatedAccounts": {
    params: ToolsOzoneSignatureFindRelatedAccounts.Params;
    output: ToolsOzoneSignatureFindRelatedAccounts.Output;
  };
  "tools.ozone.signature.searchAccounts": {
    params: ToolsOzoneSignatureSearchAccounts.Params;
    output: ToolsOzoneSignatureSearchAccounts.Output;
  };
  "tools.ozone.team.listMembers": {
    params: ToolsOzoneTeamListMembers.Params;
    output: ToolsOzoneTeamListMembers.Output;
  };
}

export declare interface Procedures {
  "app.bsky.actor.putPreferences": {
    input: AppBskyActorPutPreferences.Input;
  };
  "app.bsky.feed.sendInteractions": {
    input: AppBskyFeedSendInteractions.Input;
    output: AppBskyFeedSendInteractions.Output;
  };
  "app.bsky.graph.muteActor": {
    input: AppBskyGraphMuteActor.Input;
  };
  "app.bsky.graph.muteActorList": {
    input: AppBskyGraphMuteActorList.Input;
  };
  "app.bsky.graph.muteThread": {
    input: AppBskyGraphMuteThread.Input;
  };
  "app.bsky.graph.unmuteActor": {
    input: AppBskyGraphUnmuteActor.Input;
  };
  "app.bsky.graph.unmuteActorList": {
    input: AppBskyGraphUnmuteActorList.Input;
  };
  "app.bsky.graph.unmuteThread": {
    input: AppBskyGraphUnmuteThread.Input;
  };
  "app.bsky.notification.putPreferences": {
    input: AppBskyNotificationPutPreferences.Input;
  };
  "app.bsky.notification.registerPush": {
    input: AppBskyNotificationRegisterPush.Input;
  };
  "app.bsky.notification.updateSeen": {
    input: AppBskyNotificationUpdateSeen.Input;
  };
  "app.bsky.video.uploadVideo": {
    input: AppBskyVideoUploadVideo.Input;
    output: AppBskyVideoUploadVideo.Output;
  };
  "chat.bsky.actor.deleteAccount": {
    output: ChatBskyActorDeleteAccount.Output;
  };
  "chat.bsky.convo.deleteMessageForSelf": {
    input: ChatBskyConvoDeleteMessageForSelf.Input;
    output: ChatBskyConvoDeleteMessageForSelf.Output;
  };
  "chat.bsky.convo.leaveConvo": {
    input: ChatBskyConvoLeaveConvo.Input;
    output: ChatBskyConvoLeaveConvo.Output;
  };
  "chat.bsky.convo.muteConvo": {
    input: ChatBskyConvoMuteConvo.Input;
    output: ChatBskyConvoMuteConvo.Output;
  };
  "chat.bsky.convo.sendMessage": {
    input: ChatBskyConvoSendMessage.Input;
    output: ChatBskyConvoSendMessage.Output;
  };
  "chat.bsky.convo.sendMessageBatch": {
    input: ChatBskyConvoSendMessageBatch.Input;
    output: ChatBskyConvoSendMessageBatch.Output;
  };
  "chat.bsky.convo.unmuteConvo": {
    input: ChatBskyConvoUnmuteConvo.Input;
    output: ChatBskyConvoUnmuteConvo.Output;
  };
  "chat.bsky.convo.updateRead": {
    input: ChatBskyConvoUpdateRead.Input;
    output: ChatBskyConvoUpdateRead.Output;
  };
  "chat.bsky.moderation.updateActorAccess": {
    input: ChatBskyModerationUpdateActorAccess.Input;
  };
  "com.atproto.admin.deleteAccount": {
    input: ComAtprotoAdminDeleteAccount.Input;
  };
  "com.atproto.admin.disableAccountInvites": {
    input: ComAtprotoAdminDisableAccountInvites.Input;
  };
  "com.atproto.admin.disableInviteCodes": {
    input: ComAtprotoAdminDisableInviteCodes.Input;
  };
  "com.atproto.admin.enableAccountInvites": {
    input: ComAtprotoAdminEnableAccountInvites.Input;
  };
  "com.atproto.admin.sendEmail": {
    input: ComAtprotoAdminSendEmail.Input;
    output: ComAtprotoAdminSendEmail.Output;
  };
  "com.atproto.admin.updateAccountEmail": {
    input: ComAtprotoAdminUpdateAccountEmail.Input;
  };
  "com.atproto.admin.updateAccountHandle": {
    input: ComAtprotoAdminUpdateAccountHandle.Input;
  };
  "com.atproto.admin.updateAccountPassword": {
    input: ComAtprotoAdminUpdateAccountPassword.Input;
  };
  "com.atproto.admin.updateSubjectStatus": {
    input: ComAtprotoAdminUpdateSubjectStatus.Input;
    output: ComAtprotoAdminUpdateSubjectStatus.Output;
  };
  "com.atproto.identity.requestPlcOperationSignature": {};
  "com.atproto.identity.signPlcOperation": {
    input: ComAtprotoIdentitySignPlcOperation.Input;
    output: ComAtprotoIdentitySignPlcOperation.Output;
  };
  "com.atproto.identity.submitPlcOperation": {
    input: ComAtprotoIdentitySubmitPlcOperation.Input;
  };
  "com.atproto.identity.updateHandle": {
    input: ComAtprotoIdentityUpdateHandle.Input;
  };
  "com.atproto.moderation.createReport": {
    input: ComAtprotoModerationCreateReport.Input;
    output: ComAtprotoModerationCreateReport.Output;
  };
  "com.atproto.repo.applyWrites": {
    input: ComAtprotoRepoApplyWrites.Input;
    output: ComAtprotoRepoApplyWrites.Output;
  };
  "com.atproto.repo.createRecord": {
    input: ComAtprotoRepoCreateRecord.Input;
    output: ComAtprotoRepoCreateRecord.Output;
  };
  "com.atproto.repo.deleteRecord": {
    input: ComAtprotoRepoDeleteRecord.Input;
    output: ComAtprotoRepoDeleteRecord.Output;
  };
  "com.atproto.repo.importRepo": {
    input: ComAtprotoRepoImportRepo.Input;
  };
  "com.atproto.repo.putRecord": {
    input: ComAtprotoRepoPutRecord.Input;
    output: ComAtprotoRepoPutRecord.Output;
  };
  "com.atproto.repo.uploadBlob": {
    input: ComAtprotoRepoUploadBlob.Input;
    output: ComAtprotoRepoUploadBlob.Output;
  };
  "com.atproto.server.activateAccount": {};
  "com.atproto.server.confirmEmail": {
    input: ComAtprotoServerConfirmEmail.Input;
  };
  "com.atproto.server.createAccount": {
    input: ComAtprotoServerCreateAccount.Input;
    output: ComAtprotoServerCreateAccount.Output;
  };
  "com.atproto.server.createAppPassword": {
    input: ComAtprotoServerCreateAppPassword.Input;
    output: ComAtprotoServerCreateAppPassword.Output;
  };
  "com.atproto.server.createInviteCode": {
    input: ComAtprotoServerCreateInviteCode.Input;
    output: ComAtprotoServerCreateInviteCode.Output;
  };
  "com.atproto.server.createInviteCodes": {
    input: ComAtprotoServerCreateInviteCodes.Input;
    output: ComAtprotoServerCreateInviteCodes.Output;
  };
  "com.atproto.server.createSession": {
    input: ComAtprotoServerCreateSession.Input;
    output: ComAtprotoServerCreateSession.Output;
  };
  "com.atproto.server.deactivateAccount": {
    input: ComAtprotoServerDeactivateAccount.Input;
  };
  "com.atproto.server.deleteAccount": {
    input: ComAtprotoServerDeleteAccount.Input;
  };
  "com.atproto.server.deleteSession": {};
  "com.atproto.server.refreshSession": {
    output: ComAtprotoServerRefreshSession.Output;
  };
  "com.atproto.server.requestAccountDelete": {};
  "com.atproto.server.requestEmailConfirmation": {};
  "com.atproto.server.requestEmailUpdate": {
    output: ComAtprotoServerRequestEmailUpdate.Output;
  };
  "com.atproto.server.requestPasswordReset": {
    input: ComAtprotoServerRequestPasswordReset.Input;
  };
  "com.atproto.server.reserveSigningKey": {
    input: ComAtprotoServerReserveSigningKey.Input;
    output: ComAtprotoServerReserveSigningKey.Output;
  };
  "com.atproto.server.resetPassword": {
    input: ComAtprotoServerResetPassword.Input;
  };
  "com.atproto.server.revokeAppPassword": {
    input: ComAtprotoServerRevokeAppPassword.Input;
  };
  "com.atproto.server.updateEmail": {
    input: ComAtprotoServerUpdateEmail.Input;
  };
  "com.atproto.sync.notifyOfUpdate": {
    input: ComAtprotoSyncNotifyOfUpdate.Input;
  };
  "com.atproto.sync.requestCrawl": {
    input: ComAtprotoSyncRequestCrawl.Input;
  };
  "com.atproto.temp.addReservedHandle": {
    input: ComAtprotoTempAddReservedHandle.Input;
    output: ComAtprotoTempAddReservedHandle.Output;
  };
  "com.atproto.temp.requestPhoneVerification": {
    input: ComAtprotoTempRequestPhoneVerification.Input;
  };
  "tools.ozone.communication.createTemplate": {
    input: ToolsOzoneCommunicationCreateTemplate.Input;
    output: ToolsOzoneCommunicationCreateTemplate.Output;
  };
  "tools.ozone.communication.deleteTemplate": {
    input: ToolsOzoneCommunicationDeleteTemplate.Input;
  };
  "tools.ozone.communication.updateTemplate": {
    input: ToolsOzoneCommunicationUpdateTemplate.Input;
    output: ToolsOzoneCommunicationUpdateTemplate.Output;
  };
  "tools.ozone.moderation.emitEvent": {
    input: ToolsOzoneModerationEmitEvent.Input;
    output: ToolsOzoneModerationEmitEvent.Output;
  };
  "tools.ozone.set.addValues": {
    input: ToolsOzoneSetAddValues.Input;
  };
  "tools.ozone.set.deleteSet": {
    input: ToolsOzoneSetDeleteSet.Input;
    output: ToolsOzoneSetDeleteSet.Output;
  };
  "tools.ozone.set.deleteValues": {
    input: ToolsOzoneSetDeleteValues.Input;
  };
  "tools.ozone.set.upsertSet": {
    input: ToolsOzoneSetUpsertSet.Input;
    output: ToolsOzoneSetUpsertSet.Output;
  };
  "tools.ozone.setting.removeOptions": {
    input: ToolsOzoneSettingRemoveOptions.Input;
    output: ToolsOzoneSettingRemoveOptions.Output;
  };
  "tools.ozone.setting.upsertOption": {
    input: ToolsOzoneSettingUpsertOption.Input;
    output: ToolsOzoneSettingUpsertOption.Output;
  };
  "tools.ozone.team.addMember": {
    input: ToolsOzoneTeamAddMember.Input;
    output: ToolsOzoneTeamAddMember.Output;
  };
  "tools.ozone.team.deleteMember": {
    input: ToolsOzoneTeamDeleteMember.Input;
  };
  "tools.ozone.team.updateMember": {
    input: ToolsOzoneTeamUpdateMember.Input;
    output: ToolsOzoneTeamUpdateMember.Output;
  };
}

export declare interface Subscriptions {
  "com.atproto.label.subscribeLabels": {
    params: ComAtprotoLabelSubscribeLabels.Params;
    message: ComAtprotoLabelSubscribeLabels.Message;
    errors: ComAtprotoLabelSubscribeLabels.Errors;
  };
  "com.atproto.sync.subscribeRepos": {
    params: ComAtprotoSyncSubscribeRepos.Params;
    message: ComAtprotoSyncSubscribeRepos.Message;
    errors: ComAtprotoSyncSubscribeRepos.Errors;
  };
}
