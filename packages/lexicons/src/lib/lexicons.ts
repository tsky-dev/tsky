/* eslint-disable */
// This file is automatically generated by @tsky/lex-cli, do not edit!

/**
 * @module
 * Contains type declarations for Bluesky lexicons
 * @generated
 * Generated on: 2026-01-28T04:11:07.415Z
 * Version: main
 * Source: https://github.com/bluesky-social/atproto/tree/2830daeaa6f580fbf777a0f832d64a6579616dc7/lexicons
 */

/** Base type with optional type field */
export interface TypedBase {
  $type?: string;
}

/** Base type for all record types */
export interface RecordBase {
  $type: string;
}

/** Makes $type required and specific */
export type Typed<T extends TypedBase, Type extends string> = Omit<
  T,
  "$type"
> & {
  $type: Type;
};

/** Creates a union of objects discriminated by $type */
export type TypeUnion<T extends TypedBase> = T extends any
  ? Typed<T, string>
  : never;

/** Type guard for records */
export function isRecord(value: unknown): value is RecordBase {
  return (
    typeof value === "object" &&
    value !== null &&
    "$type" in value &&
    typeof value.$type === "string"
  );
}

/** Base AT Protocol schema types */
export declare namespace At {
  /** CID string */
  type CID = string;

  /** DID of a user */
  type DID = `did:${string}`;

  /** User handle */
  type Handle = string;

  /** URI string */
  type Uri = string;

  /** TID string */
  type TID = string;

  /** RKEY string */
  type RKEY = string;

  /** Object containing a CID string */
  interface CIDLink {
    $link: CID;
  }

  /** Object containing a base64-encoded bytes */
  interface Bytes {
    $bytes: string;
  }

  /** Blob interface */
  interface Blob<T extends string = string> extends RecordBase {
    $type: "blob";
    mimeType: T;
    ref: {
      $link: string;
    };
    size: number;
  }

  /** Individual permission entry */
  interface Permission {
    resource: string;
    lxm?: string[];
    action?: string[];
    collection?: string[];
    inheritAud?: boolean;
  }

  /** Set of permissions */
  interface PermissionSet {
    title?: string;
    detail?: string;
    permissions: Permission[];
  }
}
export declare namespace AppBskyActorDefs {
  interface AdultContentPref extends TypedBase {
    /** \@default false */
    enabled: boolean;
  }
  /** If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress. */
  interface BskyAppProgressGuide extends TypedBase {
    /** Maximum string length: 100 */
    guide: string;
  }
  /** A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this. */
  interface BskyAppStatePref extends TypedBase {
    activeProgressGuide?: BskyAppProgressGuide;
    /**
     * Storage for NUXs the user has encountered.
     * Maximum array length: 100
     */
    nuxs?: AppBskyActorDefs.Nux[];
    /**
     * An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.
     * Maximum array length: 1000
     * Maximum string length: 100
     */
    queuedNudges?: string[];
  }
  interface ContentLabelPref extends TypedBase {
    label: string;
    visibility: "hide" | "ignore" | "show" | "warn" | (string & {});
    /** Which labeler does this preference apply to? If undefined, applies globally. */
    labelerDid?: At.DID;
  }
  /** Read-only preference containing value(s) inferred from the user's declared birthdate. Absence of this preference object in the response indicates that the user has not made a declaration. */
  interface DeclaredAgePref extends TypedBase {
    /** Indicates if the user has declared that they are over 13 years of age. */
    isOverAge13?: boolean;
    /** Indicates if the user has declared that they are over 16 years of age. */
    isOverAge16?: boolean;
    /** Indicates if the user has declared that they are over 18 years of age. */
    isOverAge18?: boolean;
  }
  interface FeedViewPref extends TypedBase {
    /** The URI of the feed, or an identifier which describes the feed. */
    feed: string;
    /** Hide quote posts in the feed. */
    hideQuotePosts?: boolean;
    /** Hide replies in the feed. */
    hideReplies?: boolean;
    /** Hide replies in the feed if they do not have this number of likes. */
    hideRepliesByLikeCount?: number;
    /**
     * Hide replies in the feed if they are not by followed users.
     * \@default true
     */
    hideRepliesByUnfollowed?: boolean;
    /** Hide reposts in the feed. */
    hideReposts?: boolean;
  }
  interface HiddenPostsPref extends TypedBase {
    /** A list of URIs of posts the account owner has hidden. */
    items: At.Uri[];
  }
  interface InterestsPref extends TypedBase {
    /**
     * A list of tags which describe the account owner's interests gathered during onboarding.
     * Maximum array length: 100
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tags: string[];
  }
  /** The subject's followers whom you also follow */
  interface KnownFollowers extends TypedBase {
    count: number;
    /**
     * Minimum array length: 0
     * Maximum array length: 5
     */
    followers: ProfileViewBasic[];
  }
  interface LabelerPrefItem extends TypedBase {
    did: At.DID;
  }
  interface LabelersPref extends TypedBase {
    labelers: LabelerPrefItem[];
  }
  /** Preferences for live events. */
  interface LiveEventPreferences extends TypedBase {
    /** A list of feed IDs that the user has hidden from live events. */
    hiddenFeedIds?: string[];
    /**
     * Whether to hide all feeds from live events.
     * \@default false
     */
    hideAllFeeds?: boolean;
  }
  /** A word that the account owner has muted. */
  interface MutedWord extends TypedBase {
    /** The intended targets of the muted word. */
    targets: AppBskyActorDefs.MutedWordTarget[];
    /**
     * The muted word itself.
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    value: string;
    /**
     * Groups of users to apply the muted word to. If undefined, applies to all users.
     * \@default "all"
     */
    actorTarget?: "all" | "exclude-following" | (string & {});
    /** The date and time at which the muted word will expire and no longer be applied. */
    expiresAt?: string;
    id?: string;
  }
  interface MutedWordsPref extends TypedBase {
    /** A list of words the account owner has muted. */
    items: AppBskyActorDefs.MutedWord[];
  }
  /**
   * Maximum string length: 640
   * Maximum grapheme length: 64
   */
  type MutedWordTarget = "content" | "tag" | (string & {});
  /** A new user experiences (NUX) storage object */
  interface Nux extends TypedBase {
    /** \@default false */
    completed: boolean;
    /** Maximum string length: 100 */
    id: string;
    /**
     * Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    data?: string;
    /** The date and time at which the NUX will expire and should be considered completed. */
    expiresAt?: string;
  }
  interface PersonalDetailsPref extends TypedBase {
    /** The birth date of account owner. */
    birthDate?: string;
  }
  /** Default post interaction settings for the account. These values should be applied as default values when creating new posts. These refs should mirror the threadgate and postgate records exactly. */
  interface PostInteractionSettingsPref extends TypedBase {
    /**
     * Matches postgate record. List of rules defining who can embed this users posts. If value is an empty array or is undefined, no particular rules apply and anyone can embed.
     * Maximum array length: 5
     */
    postgateEmbeddingRules?: TypeUnion<AppBskyFeedPostgate.DisableRule>[];
    /**
     * Matches threadgate record. List of rules defining who can reply to this users posts. If value is an empty array, no one can reply. If value is undefined, anyone can reply.
     * Maximum array length: 5
     */
    threadgateAllowRules?: TypeUnion<
      | AppBskyFeedThreadgate.FollowerRule
      | AppBskyFeedThreadgate.FollowingRule
      | AppBskyFeedThreadgate.ListRule
      | AppBskyFeedThreadgate.MentionRule
    >[];
  }
  type Preferences = TypeUnion<
    | AdultContentPref
    | BskyAppStatePref
    | ContentLabelPref
    | DeclaredAgePref
    | FeedViewPref
    | HiddenPostsPref
    | InterestsPref
    | LabelersPref
    | LiveEventPreferences
    | MutedWordsPref
    | PersonalDetailsPref
    | PostInteractionSettingsPref
    | SavedFeedsPref
    | SavedFeedsPrefV2
    | ThreadViewPref
    | VerificationPrefs
  >[];
  interface ProfileAssociated extends TypedBase {
    activitySubscription?: ProfileAssociatedActivitySubscription;
    chat?: ProfileAssociatedChat;
    feedgens?: number;
    germ?: ProfileAssociatedGerm;
    labeler?: boolean;
    lists?: number;
    starterPacks?: number;
  }
  interface ProfileAssociatedActivitySubscription extends TypedBase {
    allowSubscriptions: "followers" | "mutuals" | "none" | (string & {});
  }
  interface ProfileAssociatedChat extends TypedBase {
    allowIncoming: "all" | "following" | "none" | (string & {});
  }
  interface ProfileAssociatedGerm extends TypedBase {
    messageMeUrl: string;
    showButtonTo: "everyone" | "usersIFollow" | (string & {});
  }
  interface ProfileView extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    createdAt?: string;
    /** Debug information for internal development */
    debug?: unknown;
    /**
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    indexedAt?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    pronouns?: string;
    status?: StatusView;
    verification?: VerificationState;
    viewer?: ViewerState;
  }
  interface ProfileViewBasic extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    createdAt?: string;
    /** Debug information for internal development */
    debug?: unknown;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    pronouns?: string;
    status?: StatusView;
    verification?: VerificationState;
    viewer?: ViewerState;
  }
  interface ProfileViewDetailed extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    banner?: string;
    createdAt?: string;
    /** Debug information for internal development */
    debug?: unknown;
    /**
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    followersCount?: number;
    followsCount?: number;
    indexedAt?: string;
    joinedViaStarterPack?: AppBskyGraphDefs.StarterPackViewBasic;
    labels?: ComAtprotoLabelDefs.Label[];
    pinnedPost?: ComAtprotoRepoStrongRef.Main;
    postsCount?: number;
    pronouns?: string;
    status?: StatusView;
    verification?: VerificationState;
    viewer?: ViewerState;
    website?: string;
  }
  interface SavedFeed extends TypedBase {
    id: string;
    pinned: boolean;
    type: "feed" | "list" | "timeline" | (string & {});
    value: string;
  }
  interface SavedFeedsPref extends TypedBase {
    pinned: At.Uri[];
    saved: At.Uri[];
    timelineIndex?: number;
  }
  interface SavedFeedsPrefV2 extends TypedBase {
    items: AppBskyActorDefs.SavedFeed[];
  }
  interface StatusView extends TypedBase {
    record: unknown;
    /** The status for the account. */
    status: "app.bsky.actor.status#live" | (string & {});
    cid?: At.CID;
    /** An optional embed associated with the status. */
    embed?: TypeUnion<AppBskyEmbedExternal.View>;
    /** The date when this status will expire. The application might choose to no longer return the status after expiration. */
    expiresAt?: string;
    /** True if the status is not expired, false if it is expired. Only present if expiration was set. */
    isActive?: boolean;
    /** True if the user's go-live access has been disabled by a moderator, false otherwise. */
    isDisabled?: boolean;
    uri?: At.Uri;
  }
  interface ThreadViewPref extends TypedBase {
    /** Sorting mode for threads. */
    sort?:
      | "hotness"
      | "most-likes"
      | "newest"
      | "oldest"
      | "random"
      | (string & {});
  }
  /** Preferences for how verified accounts appear in the app. */
  interface VerificationPrefs extends TypedBase {
    /**
     * Hide the blue check badges for verified accounts and trusted verifiers.
     * \@default false
     */
    hideBadges?: boolean;
  }
  /** Represents the verification information about the user this object is attached to. */
  interface VerificationState extends TypedBase {
    /** The user's status as a trusted verifier. */
    trustedVerifierStatus: "invalid" | "none" | "valid" | (string & {});
    /** All verifications issued by trusted verifiers on behalf of this user. Verifications by untrusted verifiers are not included. */
    verifications: VerificationView[];
    /** The user's status as a verified account. */
    verifiedStatus: "invalid" | "none" | "valid" | (string & {});
  }
  /** An individual verification for an associated subject. */
  interface VerificationView extends TypedBase {
    /** Timestamp when the verification was created. */
    createdAt: string;
    /** The user who issued this verification. */
    issuer: At.DID;
    /** True if the verification passes validation, otherwise false. */
    isValid: boolean;
    /** The AT-URI of the verification record. */
    uri: At.Uri;
  }
  /** Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests. */
  interface ViewerState extends TypedBase {
    /** This property is present only in selected cases, as an optimization. */
    activitySubscription?: AppBskyNotificationDefs.ActivitySubscription;
    blockedBy?: boolean;
    blocking?: At.Uri;
    blockingByList?: AppBskyGraphDefs.ListViewBasic;
    followedBy?: At.Uri;
    following?: At.Uri;
    /** This property is present only in selected cases, as an optimization. */
    knownFollowers?: KnownFollowers;
    muted?: boolean;
    mutedByList?: AppBskyGraphDefs.ListViewBasic;
  }
}

/** Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth. */
export declare namespace AppBskyActorGetPreferences {
  type Input = undefined;
  interface Output extends TypedBase {
    preferences: AppBskyActorDefs.Preferences;
  }
}

/** Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth. */
export declare namespace AppBskyActorGetProfile {
  interface Params extends TypedBase {
    /** Handle or DID of account to fetch profile of. */
    actor: string;
  }
  type Input = undefined;
  type Output = AppBskyActorDefs.ProfileViewDetailed;
}

/** Get detailed profile views of multiple actors. */
export declare namespace AppBskyActorGetProfiles {
  interface Params extends TypedBase {
    /** Maximum array length: 25 */
    actors: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    profiles: AppBskyActorDefs.ProfileViewDetailed[];
  }
}

/** Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding. */
export declare namespace AppBskyActorGetSuggestions {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileView[];
    cursor?: string;
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: number;
  }
}

export declare namespace AppBskyActorProfile {
  /** A declaration of a Bluesky account profile. */
  interface Record extends RecordBase {
    $type: "app.bsky.actor.profile";
    /** Small image to be displayed next to posts from account. AKA, 'profile picture' */
    avatar?: At.Blob;
    /** Larger horizontal image to display behind profile view. */
    banner?: At.Blob;
    createdAt?: string;
    /**
     * Free-form profile description text.
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    joinedViaStarterPack?: ComAtprotoRepoStrongRef.Main;
    /** Self-label values, specific to the Bluesky application, on the overall account. */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
    pinnedPost?: ComAtprotoRepoStrongRef.Main;
    /**
     * Free-form pronouns text.
     * Maximum string length: 200
     * Maximum grapheme length: 20
     */
    pronouns?: string;
    website?: string;
  }
  type Main = Record;
}

/** Set the private preferences attached to the account. */
export declare namespace AppBskyActorPutPreferences {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    preferences: AppBskyActorDefs.Preferences;
  }
  type Output = undefined;
}

/** Find actors (profiles) matching search criteria. Does not require auth. */
export declare namespace AppBskyActorSearchActors {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q?: string;
    /**
     * DEPRECATED: use 'q' instead.
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth. */
export declare namespace AppBskyActorSearchActorsTypeahead {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 10
     */
    limit?: number;
    /** Search query prefix; not a full query string. */
    q?: string;
    /**
     * DEPRECATED: use 'q' instead.
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileViewBasic[];
  }
}

export declare namespace AppBskyActorStatus {
  /** A declaration of a Bluesky account status. */
  interface Record extends RecordBase {
    $type: "app.bsky.actor.status";
    createdAt: string;
    /** The status for the account. */
    status: "app.bsky.actor.status#live" | (string & {});
    /**
     * The duration of the status in minutes. Applications can choose to impose minimum and maximum limits.
     * Minimum: 1
     */
    durationMinutes?: number;
    /** An optional embed associated with the status. */
    embed?: TypeUnion<AppBskyEmbedExternal.Main>;
  }
  type Main = Record;
  type Live = "app.bsky.actor.status#live";
}

/** Initiate Age Assurance for an account. */
export declare namespace AppBskyAgeassuranceBegin {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** An ISO 3166-1 alpha-2 code of the user's location. */
    countryCode: string;
    /** The user's email address to receive Age Assurance instructions. */
    email: string;
    /** The user's preferred language for communication during the Age Assurance process. */
    language: string;
    /** An optional ISO 3166-2 code of the user's region or state within the country. */
    regionCode?: string;
  }
  type Output = AppBskyAgeassuranceDefs.State;
  interface Errors extends TypedBase {
    InvalidEmail: {};
    DidTooLong: {};
    InvalidInitiation: {};
    RegionNotSupported: {};
  }
}

export declare namespace AppBskyAgeassuranceDefs {
  /** The access level granted based on Age Assurance data we've processed. */
  type Access = "full" | "none" | "safe" | "unknown" | (string & {});
  interface Config extends TypedBase {
    /** The per-region Age Assurance configuration. */
    regions: AppBskyAgeassuranceDefs.ConfigRegion[];
  }
  /** The Age Assurance configuration for a specific region. */
  interface ConfigRegion extends TypedBase {
    /** The ISO 3166-1 alpha-2 country code this configuration applies to. */
    countryCode: string;
    /** The minimum age (as a whole integer) required to use Bluesky in this region. */
    minAccessAge: number;
    /** The ordered list of Age Assurance rules that apply to this region. Rules should be applied in order, and the first matching rule determines the access level granted. The rules array should always include a default rule as the last item. */
    rules: TypeUnion<
      | ConfigRegionRuleDefault
      | ConfigRegionRuleIfAccountNewerThan
      | ConfigRegionRuleIfAccountOlderThan
      | ConfigRegionRuleIfAssuredOverAge
      | ConfigRegionRuleIfAssuredUnderAge
      | ConfigRegionRuleIfDeclaredOverAge
      | ConfigRegionRuleIfDeclaredUnderAge
    >[];
    /** The ISO 3166-2 region code this configuration applies to. If omitted, the configuration applies to the entire country. */
    regionCode?: string;
  }
  /** Age Assurance rule that applies by default. */
  interface ConfigRegionRuleDefault extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
  }
  /** Age Assurance rule that applies if the account is equal-to or newer than a certain date. */
  interface ConfigRegionRuleIfAccountNewerThan extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    /** The date threshold as a datetime string. */
    date: string;
  }
  /** Age Assurance rule that applies if the account is older than a certain date. */
  interface ConfigRegionRuleIfAccountOlderThan extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    /** The date threshold as a datetime string. */
    date: string;
  }
  /** Age Assurance rule that applies if the user has been assured to be equal-to or over a certain age. */
  interface ConfigRegionRuleIfAssuredOverAge extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    /** The age threshold as a whole integer. */
    age: number;
  }
  /** Age Assurance rule that applies if the user has been assured to be under a certain age. */
  interface ConfigRegionRuleIfAssuredUnderAge extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    /** The age threshold as a whole integer. */
    age: number;
  }
  /** Age Assurance rule that applies if the user has declared themselves equal-to or over a certain age. */
  interface ConfigRegionRuleIfDeclaredOverAge extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    /** The age threshold as a whole integer. */
    age: number;
  }
  /** Age Assurance rule that applies if the user has declared themselves under a certain age. */
  interface ConfigRegionRuleIfDeclaredUnderAge extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    /** The age threshold as a whole integer. */
    age: number;
  }
  /** Object used to store Age Assurance data in stash. */
  interface Event extends TypedBase {
    /** The access level granted based on Age Assurance data we've processed. */
    access: "full" | "none" | "safe" | "unknown" | (string & {});
    /** The unique identifier for this instance of the Age Assurance flow, in UUID format. */
    attemptId: string;
    /** The ISO 3166-1 alpha-2 country code provided when beginning the Age Assurance flow. */
    countryCode: string;
    /** The date and time of this write operation. */
    createdAt: string;
    /** The status of the Age Assurance process. */
    status: "assured" | "blocked" | "pending" | "unknown" | (string & {});
    /** The IP address used when completing the Age Assurance flow. */
    completeIp?: string;
    /** The user agent used when completing the Age Assurance flow. */
    completeUa?: string;
    /** The email used for Age Assurance. */
    email?: string;
    /** The IP address used when initiating the Age Assurance flow. */
    initIp?: string;
    /** The user agent used when initiating the Age Assurance flow. */
    initUa?: string;
    /** The ISO 3166-2 region code provided when beginning the Age Assurance flow. */
    regionCode?: string;
  }
  /** The user's computed Age Assurance state. */
  interface State extends TypedBase {
    access: AppBskyAgeassuranceDefs.Access;
    status: AppBskyAgeassuranceDefs.Status;
    /** The timestamp when this state was last updated. */
    lastInitiatedAt?: string;
  }
  /** Additional metadata needed to compute Age Assurance state client-side. */
  interface StateMetadata extends TypedBase {
    /** The account creation timestamp. */
    accountCreatedAt?: string;
  }
  /** The status of the Age Assurance process. */
  type Status = "assured" | "blocked" | "pending" | "unknown" | (string & {});
}

/** Returns Age Assurance configuration for use on the client. */
export declare namespace AppBskyAgeassuranceGetConfig {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = AppBskyAgeassuranceDefs.Config;
}

/** Returns server-computed Age Assurance state, if available, and any additional metadata needed to compute Age Assurance state client-side. */
export declare namespace AppBskyAgeassuranceGetState {
  interface Params extends TypedBase {
    countryCode: string;
    regionCode?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    metadata: AppBskyAgeassuranceDefs.StateMetadata;
    state: AppBskyAgeassuranceDefs.State;
  }
}

export declare namespace AppBskyAuthCreatePosts {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthDeleteContent {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthFullApp {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthManageFeedDeclarations {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthManageLabelerService {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthManageModeration {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthManageNotifications {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthManageProfile {
  type Main = At.PermissionSet;
}

export declare namespace AppBskyAuthViewAll {
  type Main = At.PermissionSet;
}

/** Creates a private bookmark for the specified record. Currently, only `app.bsky.feed.post` records are supported. Requires authentication. */
export declare namespace AppBskyBookmarkCreateBookmark {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    UnsupportedCollection: {};
  }
}

export declare namespace AppBskyBookmarkDefs {
  /** Object used to store bookmark data in stash. */
  interface Bookmark extends TypedBase {
    /** A strong ref to the record to be bookmarked. Currently, only `app.bsky.feed.post` records are supported. */
    subject: ComAtprotoRepoStrongRef.Main;
  }
  interface BookmarkView extends TypedBase {
    item: TypeUnion<
      | AppBskyFeedDefs.BlockedPost
      | AppBskyFeedDefs.NotFoundPost
      | AppBskyFeedDefs.PostView
    >;
    /** A strong ref to the bookmarked record. */
    subject: ComAtprotoRepoStrongRef.Main;
    createdAt?: string;
  }
}

/** Deletes a private bookmark for the specified record. Currently, only `app.bsky.feed.post` records are supported. Requires authentication. */
export declare namespace AppBskyBookmarkDeleteBookmark {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    uri: At.Uri;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    UnsupportedCollection: {};
  }
}

/** Gets views of records bookmarked by the authenticated user. Requires authentication. */
export declare namespace AppBskyBookmarkGetBookmarks {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    bookmarks: AppBskyBookmarkDefs.BookmarkView[];
    cursor?: string;
  }
}

export declare namespace AppBskyContactDefs {
  /** Associates a profile with the positional index of the contact import input in the call to `app.bsky.contact.importContacts`, so clients can know which phone caused a particular match. */
  interface MatchAndContactIndex extends TypedBase {
    /**
     * The index of this match in the import contact input.
     * Minimum: 0
     * Maximum: 999
     */
    contactIndex: number;
    /** Profile of the matched user. */
    match: AppBskyActorDefs.ProfileView;
  }
  /** A stash object to be sent via bsync representing a notification to be created. */
  interface Notification extends TypedBase {
    /** The DID of who this notification comes from. */
    from: At.DID;
    /** The DID of who this notification should go to. */
    to: At.DID;
  }
  interface SyncStatus extends TypedBase {
    /**
     * Number of existing contact matches resulting of the user imports and of their imported contacts having imported the user. Matches stop being counted when the user either follows the matched contact or dismisses the match.
     * Minimum: 0
     */
    matchesCount: number;
    /** Last date when contacts where imported. */
    syncedAt: string;
  }
}

/** Removes a match that was found via contact import. It shouldn't appear again if the same contact is re-imported. Requires authentication. */
export declare namespace AppBskyContactDismissMatch {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The subject's DID to dismiss the match with. */
    subject: At.DID;
  }
  interface Output extends TypedBase {}
  interface Errors extends TypedBase {
    InvalidDid: {};
    InternalError: {};
  }
}

/** Returns the matched contacts (contacts that were mutually imported). Excludes dismissed matches. Requires authentication. */
export declare namespace AppBskyContactGetMatches {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    matches: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    InvalidDid: {};
    InvalidLimit: {};
    InvalidCursor: {};
    InternalError: {};
  }
}

/** Gets the user's current contact import status. Requires authentication. */
export declare namespace AppBskyContactGetSyncStatus {
  type Input = undefined;
  interface Output extends TypedBase {
    /** If present, indicates the user has imported their contacts. If not present, indicates the user never used the feature or called `app.bsky.contact.removeData` and didn't import again since. */
    syncStatus?: AppBskyContactDefs.SyncStatus;
  }
  interface Errors extends TypedBase {
    InvalidDid: {};
    InternalError: {};
  }
}

/** Import contacts for securely matching with other users. This follows the protocol explained in https://docs.bsky.app/blog/contact-import-rfc. Requires authentication. */
export declare namespace AppBskyContactImportContacts {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * List of phone numbers in global E.164 format (e.g., '+12125550123'). Phone numbers that cannot be normalized into a valid phone number will be discarded. Should not repeat the 'phone' input used in `app.bsky.contact.verifyPhone`.
     * Minimum array length: 1
     * Maximum array length: 1000
     */
    contacts: string[];
    /** JWT to authenticate the call. Use the JWT received as a response to the call to `app.bsky.contact.verifyPhone`. */
    token: string;
  }
  interface Output extends TypedBase {
    /** The users that matched during import and their indexes on the input contacts, so the client can correlate with its local list. */
    matchesAndContactIndexes: AppBskyContactDefs.MatchAndContactIndex[];
  }
  interface Errors extends TypedBase {
    InvalidDid: {};
    InvalidContacts: {};
    TooManyContacts: {};
    InvalidToken: {};
    InternalError: {};
  }
}

/** Removes all stored hashes used for contact matching, existing matches, and sync status. Requires authentication. */
export declare namespace AppBskyContactRemoveData {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {}
  interface Output extends TypedBase {}
  interface Errors extends TypedBase {
    InvalidDid: {};
    InternalError: {};
  }
}

/** System endpoint to send notifications related to contact imports. Requires role authentication. */
export declare namespace AppBskyContactSendNotification {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The DID of who this notification comes from. */
    from: At.DID;
    /** The DID of who this notification should go to. */
    to: At.DID;
  }
  interface Output extends TypedBase {}
}

/** Starts a phone verification flow. The phone passed will receive a code via SMS that should be passed to `app.bsky.contact.verifyPhone`. Requires authentication. */
export declare namespace AppBskyContactStartPhoneVerification {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The phone number to receive the code via SMS. */
    phone: string;
  }
  interface Output extends TypedBase {}
  interface Errors extends TypedBase {
    RateLimitExceeded: {};
    InvalidDid: {};
    InvalidPhone: {};
    InternalError: {};
  }
}

/** Verifies control over a phone number with a code received via SMS and starts a contact import session. Requires authentication. */
export declare namespace AppBskyContactVerifyPhone {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The code received via SMS as a result of the call to `app.bsky.contact.startPhoneVerification`. */
    code: string;
    /** The phone number to verify. Should be the same as the one passed to `app.bsky.contact.startPhoneVerification`. */
    phone: string;
  }
  interface Output extends TypedBase {
    /** JWT to be used in a call to `app.bsky.contact.importContacts`. It is only valid for a single call. */
    token: string;
  }
  interface Errors extends TypedBase {
    RateLimitExceeded: {};
    InvalidDid: {};
    InvalidPhone: {};
    InvalidCode: {};
    InternalError: {};
  }
}

/** Inserts a draft using private storage (stash). An upper limit of drafts might be enforced. Requires authentication. */
export declare namespace AppBskyDraftCreateDraft {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    draft: AppBskyDraftDefs.Draft;
  }
  interface Output extends TypedBase {
    /** The ID of the created draft. */
    id: string;
  }
  interface Errors extends TypedBase {
    DraftLimitReached: {};
  }
}

export declare namespace AppBskyDraftDefs {
  /** A draft containing an array of draft posts. */
  interface Draft extends TypedBase {
    /**
     * Array of draft posts that compose this draft.
     * Minimum array length: 1
     * Maximum array length: 100
     */
    posts: DraftPost[];
    /**
     * Indicates human language of posts primary text content.
     * Maximum array length: 3
     */
    langs?: string[];
    /**
     * Embedding rules for the postgates to be created when this draft is published.
     * Maximum array length: 5
     */
    postgateEmbeddingRules?: TypeUnion<AppBskyFeedPostgate.DisableRule>[];
    /**
     * Allow-rules for the threadgate to be created when this draft is published.
     * Maximum array length: 5
     */
    threadgateAllow?: TypeUnion<
      | AppBskyFeedThreadgate.FollowerRule
      | AppBskyFeedThreadgate.FollowingRule
      | AppBskyFeedThreadgate.ListRule
      | AppBskyFeedThreadgate.MentionRule
    >[];
  }
  interface DraftEmbedCaption extends TypedBase {
    /** Maximum string length: 10000 */
    content: string;
    lang: string;
  }
  interface DraftEmbedExternal extends TypedBase {
    uri: string;
  }
  interface DraftEmbedImage extends TypedBase {
    localRef: DraftEmbedLocalRef;
    /** Maximum grapheme length: 2000 */
    alt?: string;
  }
  interface DraftEmbedLocalRef extends TypedBase {
    /**
     * Local, on-device ref to file to be embedded. Embeds are currently device-bound for drafts.
     * Minimum string length: 1
     * Maximum string length: 1024
     */
    path: string;
  }
  interface DraftEmbedRecord extends TypedBase {
    record: ComAtprotoRepoStrongRef.Main;
  }
  interface DraftEmbedVideo extends TypedBase {
    localRef: DraftEmbedLocalRef;
    /** Maximum grapheme length: 2000 */
    alt?: string;
    /** Maximum array length: 20 */
    captions?: DraftEmbedCaption[];
  }
  /** One of the posts that compose a draft. */
  interface DraftPost extends TypedBase {
    /**
     * The primary post content.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    text: string;
    /** Maximum array length: 1 */
    embedExternals?: DraftEmbedExternal[];
    /** Maximum array length: 4 */
    embedImages?: DraftEmbedImage[];
    /** Maximum array length: 1 */
    embedRecords?: DraftEmbedRecord[];
    /** Maximum array length: 1 */
    embedVideos?: DraftEmbedVideo[];
    /** Self-label values for this post. Effectively content warnings. */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
  }
  /** View to present drafts data to users. */
  interface DraftView extends TypedBase {
    /** The time the draft was created. */
    createdAt: string;
    draft: Draft;
    /** A TID to be used as a draft identifier. */
    id: At.TID;
    /** The time the draft was last updated. */
    updatedAt: string;
  }
  /** A draft with an identifier, used to store drafts in private storage (stash). */
  interface DraftWithId extends TypedBase {
    draft: Draft;
    /** A TID to be used as a draft identifier. */
    id: At.TID;
  }
}

/** Deletes a draft by ID. Requires authentication. */
export declare namespace AppBskyDraftDeleteDraft {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    id: At.TID;
  }
  type Output = undefined;
}

/** Gets views of user drafts. Requires authentication. */
export declare namespace AppBskyDraftGetDrafts {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    drafts: AppBskyDraftDefs.DraftView[];
    cursor?: string;
  }
}

/** Updates a draft using private storage (stash). If the draft ID points to a non-existing ID, the update will be silently ignored. This is done because updates don't enforce draft limit, so it accepts all writes, but will ignore invalid ones. Requires authentication. */
export declare namespace AppBskyDraftUpdateDraft {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    draft: AppBskyDraftDefs.DraftWithId;
  }
  type Output = undefined;
}

export declare namespace AppBskyEmbedDefs {
  /** width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit. */
  interface AspectRatio extends TypedBase {
    /** Minimum: 1 */
    height: number;
    /** Minimum: 1 */
    width: number;
  }
}

export declare namespace AppBskyEmbedExternal {
  /** A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post). */
  interface Main extends TypedBase {
    external: External;
  }
  interface External extends TypedBase {
    description: string;
    title: string;
    uri: string;
    thumb?: At.Blob;
  }
  interface View extends TypedBase {
    external: ViewExternal;
  }
  interface ViewExternal extends TypedBase {
    description: string;
    title: string;
    uri: string;
    thumb?: string;
  }
}

export declare namespace AppBskyEmbedImages {
  interface Main extends TypedBase {
    /** Maximum array length: 4 */
    images: Image[];
  }
  interface Image extends TypedBase {
    /** Alt text description of the image, for accessibility. */
    alt: string;
    image: At.Blob;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
  }
  interface View extends TypedBase {
    /** Maximum array length: 4 */
    images: ViewImage[];
  }
  interface ViewImage extends TypedBase {
    /** Alt text description of the image, for accessibility. */
    alt: string;
    /** Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View. */
    fullsize: string;
    /** Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View. */
    thumb: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
  }
}

export declare namespace AppBskyEmbedRecord {
  interface Main extends TypedBase {
    record: ComAtprotoRepoStrongRef.Main;
  }
  interface View extends TypedBase {
    record: TypeUnion<
      | ViewBlocked
      | ViewDetached
      | ViewNotFound
      | ViewRecord
      | AppBskyFeedDefs.GeneratorView
      | AppBskyGraphDefs.ListView
      | AppBskyGraphDefs.StarterPackViewBasic
      | AppBskyLabelerDefs.LabelerView
    >;
  }
  interface ViewBlocked extends TypedBase {
    author: AppBskyFeedDefs.BlockedAuthor;
    blocked: boolean;
    uri: At.Uri;
  }
  interface ViewDetached extends TypedBase {
    detached: boolean;
    uri: At.Uri;
  }
  interface ViewNotFound extends TypedBase {
    notFound: boolean;
    uri: At.Uri;
  }
  interface ViewRecord extends TypedBase {
    author: AppBskyActorDefs.ProfileViewBasic;
    cid: At.CID;
    indexedAt: string;
    uri: At.Uri;
    /** The record data itself. */
    value: unknown;
    embeds?: TypeUnion<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedRecord.View
      | AppBskyEmbedRecordWithMedia.View
      | AppBskyEmbedVideo.View
    >[];
    labels?: ComAtprotoLabelDefs.Label[];
    likeCount?: number;
    quoteCount?: number;
    replyCount?: number;
    repostCount?: number;
  }
}

export declare namespace AppBskyEmbedRecordWithMedia {
  interface Main extends TypedBase {
    media: TypeUnion<
      | AppBskyEmbedExternal.Main
      | AppBskyEmbedImages.Main
      | AppBskyEmbedVideo.Main
    >;
    record: AppBskyEmbedRecord.Main;
  }
  interface View extends TypedBase {
    media: TypeUnion<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedVideo.View
    >;
    record: AppBskyEmbedRecord.View;
  }
}

export declare namespace AppBskyEmbedVideo {
  interface Main extends TypedBase {
    /** The mp4 video file. May be up to 100mb, formerly limited to 50mb. */
    video: At.Blob;
    /**
     * Alt text description of the video, for accessibility.
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    alt?: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
    /** Maximum array length: 20 */
    captions?: Caption[];
    /** A hint to the client about how to present the video. */
    presentation?: "default" | "gif" | (string & {});
  }
  interface Caption extends TypedBase {
    file: At.Blob;
    lang: string;
  }
  interface View extends TypedBase {
    cid: At.CID;
    playlist: string;
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    alt?: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
    /** A hint to the client about how to present the video. */
    presentation?: "default" | "gif" | (string & {});
    thumbnail?: string;
  }
}

export declare namespace AppBskyFeedDefs {
  interface BlockedAuthor extends TypedBase {
    did: At.DID;
    viewer?: AppBskyActorDefs.ViewerState;
  }
  interface BlockedPost extends TypedBase {
    author: BlockedAuthor;
    blocked: boolean;
    uri: At.Uri;
  }
  type ClickthroughAuthor = "app.bsky.feed.defs#clickthroughAuthor";
  type ClickthroughEmbed = "app.bsky.feed.defs#clickthroughEmbed";
  type ClickthroughItem = "app.bsky.feed.defs#clickthroughItem";
  type ClickthroughReposter = "app.bsky.feed.defs#clickthroughReposter";
  type ContentModeUnspecified = "app.bsky.feed.defs#contentModeUnspecified";
  type ContentModeVideo = "app.bsky.feed.defs#contentModeVideo";
  interface FeedViewPost extends TypedBase {
    post: PostView;
    /**
     * Context provided by feed generator that may be passed back alongside interactions.
     * Maximum string length: 2000
     */
    feedContext?: string;
    reason?: TypeUnion<ReasonPin | ReasonRepost>;
    reply?: ReplyRef;
    /**
     * Unique identifier per request that may be passed back alongside interactions.
     * Maximum string length: 100
     */
    reqId?: string;
  }
  interface GeneratorView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    did: At.DID;
    displayName: string;
    indexedAt: string;
    uri: At.Uri;
    acceptsInteractions?: boolean;
    avatar?: string;
    contentMode?:
      | "app.bsky.feed.defs#contentModeUnspecified"
      | "app.bsky.feed.defs#contentModeVideo"
      | (string & {});
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: GeneratorViewerState;
  }
  interface GeneratorViewerState extends TypedBase {
    like?: At.Uri;
  }
  interface Interaction extends TypedBase {
    event?:
      | "app.bsky.feed.defs#clickthroughAuthor"
      | "app.bsky.feed.defs#clickthroughEmbed"
      | "app.bsky.feed.defs#clickthroughItem"
      | "app.bsky.feed.defs#clickthroughReposter"
      | "app.bsky.feed.defs#interactionLike"
      | "app.bsky.feed.defs#interactionQuote"
      | "app.bsky.feed.defs#interactionReply"
      | "app.bsky.feed.defs#interactionRepost"
      | "app.bsky.feed.defs#interactionSeen"
      | "app.bsky.feed.defs#interactionShare"
      | "app.bsky.feed.defs#requestLess"
      | "app.bsky.feed.defs#requestMore"
      | (string & {});
    /**
     * Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.
     * Maximum string length: 2000
     */
    feedContext?: string;
    item?: At.Uri;
    /**
     * Unique identifier per request that may be passed back alongside interactions.
     * Maximum string length: 100
     */
    reqId?: string;
  }
  type InteractionLike = "app.bsky.feed.defs#interactionLike";
  type InteractionQuote = "app.bsky.feed.defs#interactionQuote";
  type InteractionReply = "app.bsky.feed.defs#interactionReply";
  type InteractionRepost = "app.bsky.feed.defs#interactionRepost";
  type InteractionSeen = "app.bsky.feed.defs#interactionSeen";
  type InteractionShare = "app.bsky.feed.defs#interactionShare";
  interface NotFoundPost extends TypedBase {
    notFound: boolean;
    uri: At.Uri;
  }
  interface PostView extends TypedBase {
    author: AppBskyActorDefs.ProfileViewBasic;
    cid: At.CID;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    bookmarkCount?: number;
    /** Debug information for internal development */
    debug?: unknown;
    embed?: TypeUnion<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedRecord.View
      | AppBskyEmbedRecordWithMedia.View
      | AppBskyEmbedVideo.View
    >;
    labels?: ComAtprotoLabelDefs.Label[];
    likeCount?: number;
    quoteCount?: number;
    replyCount?: number;
    repostCount?: number;
    threadgate?: ThreadgateView;
    viewer?: ViewerState;
  }
  interface ReasonPin extends TypedBase {}
  interface ReasonRepost extends TypedBase {
    by: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    cid?: At.CID;
    uri?: At.Uri;
  }
  interface ReplyRef extends TypedBase {
    parent: TypeUnion<BlockedPost | NotFoundPost | PostView>;
    root: TypeUnion<BlockedPost | NotFoundPost | PostView>;
    /** When parent is a reply to another post, this is the author of that post. */
    grandparentAuthor?: AppBskyActorDefs.ProfileViewBasic;
  }
  type RequestLess = "app.bsky.feed.defs#requestLess";
  type RequestMore = "app.bsky.feed.defs#requestMore";
  interface SkeletonFeedPost extends TypedBase {
    post: At.Uri;
    /**
     * Context that will be passed through to client and may be passed to feed generator back alongside interactions.
     * Maximum string length: 2000
     */
    feedContext?: string;
    reason?: TypeUnion<SkeletonReasonPin | SkeletonReasonRepost>;
  }
  interface SkeletonReasonPin extends TypedBase {}
  interface SkeletonReasonRepost extends TypedBase {
    repost: At.Uri;
  }
  /** Metadata about this post within the context of the thread it is in. */
  interface ThreadContext extends TypedBase {
    rootAuthorLike?: At.Uri;
  }
  interface ThreadgateView extends TypedBase {
    cid?: At.CID;
    lists?: AppBskyGraphDefs.ListViewBasic[];
    record?: unknown;
    uri?: At.Uri;
  }
  interface ThreadViewPost extends TypedBase {
    post: PostView;
    parent?: TypeUnion<BlockedPost | NotFoundPost | ThreadViewPost>;
    replies?: TypeUnion<BlockedPost | NotFoundPost | ThreadViewPost>[];
    threadContext?: ThreadContext;
  }
  /** Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests. */
  interface ViewerState extends TypedBase {
    bookmarked?: boolean;
    embeddingDisabled?: boolean;
    like?: At.Uri;
    pinned?: boolean;
    replyDisabled?: boolean;
    repost?: At.Uri;
    threadMuted?: boolean;
  }
}

/** Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View). */
export declare namespace AppBskyFeedDescribeFeedGenerator {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    did: At.DID;
    feeds: Feed[];
    links?: Links;
  }
  interface Feed extends TypedBase {
    uri: At.Uri;
  }
  interface Links extends TypedBase {
    privacyPolicy?: string;
    termsOfService?: string;
  }
}

export declare namespace AppBskyFeedGenerator {
  /** Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.generator";
    createdAt: string;
    did: At.DID;
    /**
     * Maximum string length: 240
     * Maximum grapheme length: 24
     */
    displayName: string;
    /** Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions */
    acceptsInteractions?: boolean;
    avatar?: At.Blob;
    contentMode?:
      | "app.bsky.feed.defs#contentModeUnspecified"
      | "app.bsky.feed.defs#contentModeVideo"
      | (string & {});
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    /** Self-label values */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
  }
  type Main = Record;
}

/** Get a list of feeds (feed generator records) created by the actor (in the actor's repo). */
export declare namespace AppBskyFeedGetActorFeeds {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a list of posts liked by an actor. Requires auth, actor must be the requesting account. */
export declare namespace AppBskyFeedGetActorLikes {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    BlockedActor: {};
    BlockedByActor: {};
  }
}

/** Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth. */
export declare namespace AppBskyFeedGetAuthorFeed {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Combinations of post/repost types to include in response.
     * \@default "posts_with_replies"
     */
    filter?:
      | "posts_and_author_threads"
      | "posts_no_replies"
      | "posts_with_media"
      | "posts_with_replies"
      | "posts_with_video"
      | (string & {});
    /** \@default false */
    includePins?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    BlockedActor: {};
    BlockedByActor: {};
  }
}

/** Get a hydrated feed from an actor's selected feed generator. Implemented by App View. */
export declare namespace AppBskyFeedGetFeed {
  interface Params extends TypedBase {
    feed: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    UnknownFeed: {};
  }
}

/** Get information about a feed generator. Implemented by AppView. */
export declare namespace AppBskyFeedGetFeedGenerator {
  interface Params extends TypedBase {
    /** AT-URI of the feed generator record. */
    feed: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** Indicates whether the feed generator service has been online recently, or else seems to be inactive. */
    isOnline: boolean;
    /** Indicates whether the feed generator service is compatible with the record declaration. */
    isValid: boolean;
    view: AppBskyFeedDefs.GeneratorView;
  }
}

/** Get information about a list of feed generators. */
export declare namespace AppBskyFeedGetFeedGenerators {
  interface Params extends TypedBase {
    feeds: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
  }
}

/** Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service. */
export declare namespace AppBskyFeedGetFeedSkeleton {
  interface Params extends TypedBase {
    /** Reference to feed generator record describing the specific feed being requested. */
    feed: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.SkeletonFeedPost[];
    cursor?: string;
    /**
     * Unique identifier per request that may be passed back alongside interactions.
     * Maximum string length: 100
     */
    reqId?: string;
  }
  interface Errors extends TypedBase {
    UnknownFeed: {};
  }
}

/** Get like records which reference a subject (by AT-URI and CID). */
export declare namespace AppBskyFeedGetLikes {
  interface Params extends TypedBase {
    /** AT-URI of the subject (eg, a post record). */
    uri: At.Uri;
    /** CID of the subject record (aka, specific version of record), to filter likes. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    likes: Like[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
  interface Like extends TypedBase {
    actor: AppBskyActorDefs.ProfileView;
    createdAt: string;
    indexedAt: string;
  }
}

/** Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth. */
export declare namespace AppBskyFeedGetListFeed {
  interface Params extends TypedBase {
    /** Reference (AT-URI) to the list record. */
    list: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    UnknownList: {};
  }
}

/** Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'. */
export declare namespace AppBskyFeedGetPosts {
  interface Params extends TypedBase {
    /**
     * List of post AT-URIs to return hydrated views for.
     * Maximum array length: 25
     */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyFeedDefs.PostView[];
  }
}

/** Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests. */
export declare namespace AppBskyFeedGetPostThread {
  interface Params extends TypedBase {
    /** Reference (AT-URI) to post record. */
    uri: At.Uri;
    /**
     * How many levels of reply depth should be included in response.
     * Minimum: 0
     * Maximum: 1000
     * \@default 6
     */
    depth?: number;
    /**
     * How many levels of parent (and grandparent, etc) post to include.
     * Minimum: 0
     * Maximum: 1000
     * \@default 80
     */
    parentHeight?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    thread: TypeUnion<
      | AppBskyFeedDefs.BlockedPost
      | AppBskyFeedDefs.NotFoundPost
      | AppBskyFeedDefs.ThreadViewPost
    >;
    threadgate?: AppBskyFeedDefs.ThreadgateView;
  }
  interface Errors extends TypedBase {
    NotFound: {};
  }
}

/** Get a list of quotes for a given post. */
export declare namespace AppBskyFeedGetQuotes {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of post record */
    uri: At.Uri;
    /** If supplied, filters to quotes of specific version (by CID) of the post record. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyFeedDefs.PostView[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
}

/** Get a list of reposts for a given post. */
export declare namespace AppBskyFeedGetRepostedBy {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of post record */
    uri: At.Uri;
    /** If supplied, filters to reposts of specific version (by CID) of the post record. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repostedBy: AppBskyActorDefs.ProfileView[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
}

/** Get a list of suggested feeds (feed generators) for the requesting account. */
export declare namespace AppBskyFeedGetSuggestedFeeds {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed. */
export declare namespace AppBskyFeedGetTimeline {
  interface Params extends TypedBase {
    /** Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism. */
    algorithm?: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
}

export declare namespace AppBskyFeedLike {
  /** Record declaring a 'like' of a piece of subject content. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.like";
    createdAt: string;
    subject: ComAtprotoRepoStrongRef.Main;
    via?: ComAtprotoRepoStrongRef.Main;
  }
  type Main = Record;
}

export declare namespace AppBskyFeedPost {
  /** Record containing a Bluesky post. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.post";
    /** Client-declared timestamp when this post was originally created. */
    createdAt: string;
    /**
     * The primary post content. May be an empty string, if there are embeds.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    text: string;
    embed?: TypeUnion<
      | AppBskyEmbedExternal.Main
      | AppBskyEmbedImages.Main
      | AppBskyEmbedRecord.Main
      | AppBskyEmbedRecordWithMedia.Main
      | AppBskyEmbedVideo.Main
    >;
    /**
     * DEPRECATED: replaced by app.bsky.richtext.facet.
     * \@deprecated
     */
    entities?: Entity[];
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
    /** Self-label values for this post. Effectively content warnings. */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
    /**
     * Indicates human language of post primary text content.
     * Maximum array length: 3
     */
    langs?: string[];
    reply?: ReplyRef;
    /**
     * Additional hashtags, in addition to any included in post text and facets.
     * Maximum array length: 8
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tags?: string[];
  }
  type Main = Record;
  /**
   * Deprecated: use facets instead.
   * \@deprecated
   */
  interface Entity extends TypedBase {
    index: TextSlice;
    /** Expected values are 'mention' and 'link'. */
    type: string;
    value: string;
  }
  interface ReplyRef extends TypedBase {
    parent: ComAtprotoRepoStrongRef.Main;
    root: ComAtprotoRepoStrongRef.Main;
  }
  /**
   * Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.
   * \@deprecated
   */
  interface TextSlice extends TypedBase {
    /** Minimum: 0 */
    end: number;
    /** Minimum: 0 */
    start: number;
  }
}

export declare namespace AppBskyFeedPostgate {
  /** Record defining interaction rules for a post. The record key (rkey) of the postgate record must match the record key of the post, and that record must be in the same repository. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.postgate";
    createdAt: string;
    /** Reference (AT-URI) to the post record. */
    post: At.Uri;
    /**
     * List of AT-URIs embedding this post that the author has detached from.
     * Maximum array length: 50
     */
    detachedEmbeddingUris?: At.Uri[];
    /**
     * List of rules defining who can embed this post. If value is an empty array or is undefined, no particular rules apply and anyone can embed.
     * Maximum array length: 5
     */
    embeddingRules?: TypeUnion<DisableRule>[];
  }
  type Main = Record;
  /** Disables embedding of this post. */
  interface DisableRule extends TypedBase {}
}

export declare namespace AppBskyFeedRepost {
  /** Record representing a 'repost' of an existing Bluesky post. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.repost";
    createdAt: string;
    subject: ComAtprotoRepoStrongRef.Main;
    via?: ComAtprotoRepoStrongRef.Main;
  }
  type Main = Record;
}

/** Find posts matching search criteria, returning views of those posts. Note that this API endpoint may require authentication (eg, not public) for some service providers and implementations. */
export declare namespace AppBskyFeedSearchPosts {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Filter to posts by the given account. Handles are resolved to DID before query-time. */
    author?: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /** Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization. */
    domain?: string;
    /** Filter to posts in the given language. Expected to be based on post language field, though server may override language detection. */
    lang?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions. */
    mentions?: string;
    /** Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD). */
    since?: string;
    /**
     * Specifies the ranking order of results.
     * \@default "latest"
     */
    sort?: "latest" | "top" | (string & {});
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag?: string[];
    /** Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD). */
    until?: string;
    /** Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching. */
    url?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyFeedDefs.PostView[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

/** Send information about interactions with feed items back to the feed generator that served them. */
export declare namespace AppBskyFeedSendInteractions {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    interactions: AppBskyFeedDefs.Interaction[];
  }
  interface Output extends TypedBase {}
}

export declare namespace AppBskyFeedThreadgate {
  /** Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.threadgate";
    createdAt: string;
    /** Reference (AT-URI) to the post record. */
    post: At.Uri;
    /**
     * List of rules defining who can reply to this post. If value is an empty array, no one can reply. If value is undefined, anyone can reply.
     * Maximum array length: 5
     */
    allow?: TypeUnion<FollowerRule | FollowingRule | ListRule | MentionRule>[];
    /**
     * List of hidden reply URIs.
     * Maximum array length: 300
     */
    hiddenReplies?: At.Uri[];
  }
  type Main = Record;
  /** Allow replies from actors who follow you. */
  interface FollowerRule extends TypedBase {}
  /** Allow replies from actors you follow. */
  interface FollowingRule extends TypedBase {}
  /** Allow replies from actors on a list. */
  interface ListRule extends TypedBase {
    list: At.Uri;
  }
  /** Allow replies from actors mentioned in your post. */
  interface MentionRule extends TypedBase {}
}

export declare namespace AppBskyGraphBlock {
  /** Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.block";
    createdAt: string;
    /** DID of the account to be blocked. */
    subject: At.DID;
  }
  type Main = Record;
}

export declare namespace AppBskyGraphDefs {
  type Curatelist = "app.bsky.graph.defs#curatelist";
  interface ListItemView extends TypedBase {
    subject: AppBskyActorDefs.ProfileView;
    uri: At.Uri;
  }
  type ListPurpose =
    | "app.bsky.graph.defs#curatelist"
    | "app.bsky.graph.defs#modlist"
    | "app.bsky.graph.defs#referencelist"
    | (string & {});
  interface ListView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    purpose: ListPurpose;
    uri: At.Uri;
    avatar?: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
    viewer?: ListViewerState;
  }
  interface ListViewBasic extends TypedBase {
    cid: At.CID;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    purpose: ListPurpose;
    uri: At.Uri;
    avatar?: string;
    indexedAt?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
    viewer?: ListViewerState;
  }
  interface ListViewerState extends TypedBase {
    blocked?: At.Uri;
    muted?: boolean;
  }
  type Modlist = "app.bsky.graph.defs#modlist";
  /** indicates that a handle or DID could not be resolved */
  interface NotFoundActor extends TypedBase {
    actor: string;
    notFound: boolean;
  }
  type Referencelist = "app.bsky.graph.defs#referencelist";
  /** lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object) */
  interface Relationship extends TypedBase {
    did: At.DID;
    /** if the actor is blocked by this DID, contains the AT-URI of the block record */
    blockedBy?: At.Uri;
    /** if the actor is blocked by this DID via a block list, contains the AT-URI of the listblock record */
    blockedByList?: At.Uri;
    /** if the actor blocks this DID, this is the AT-URI of the block record */
    blocking?: At.Uri;
    /** if the actor blocks this DID via a block list, this is the AT-URI of the listblock record */
    blockingByList?: At.Uri;
    /** if the actor is followed by this DID, contains the AT-URI of the follow record */
    followedBy?: At.Uri;
    /** if the actor follows this DID, this is the AT-URI of the follow record */
    following?: At.Uri;
  }
  interface StarterPackView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    /** Maximum array length: 3 */
    feeds?: AppBskyFeedDefs.GeneratorView[];
    /** Minimum: 0 */
    joinedAllTimeCount?: number;
    /** Minimum: 0 */
    joinedWeekCount?: number;
    labels?: ComAtprotoLabelDefs.Label[];
    list?: ListViewBasic;
    /** Maximum array length: 12 */
    listItemsSample?: ListItemView[];
  }
  interface StarterPackViewBasic extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    /** Minimum: 0 */
    joinedAllTimeCount?: number;
    /** Minimum: 0 */
    joinedWeekCount?: number;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
  }
}

export declare namespace AppBskyGraphFollow {
  /** Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.follow";
    createdAt: string;
    subject: At.DID;
    via?: ComAtprotoRepoStrongRef.Main;
  }
  type Main = Record;
}

/** Get a list of starter packs created by the actor. */
export declare namespace AppBskyGraphGetActorStarterPacks {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
    cursor?: string;
  }
}

/** Enumerates which accounts the requesting account is currently blocking. Requires auth. */
export declare namespace AppBskyGraphGetBlocks {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    blocks: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerates accounts which follow a specified account (actor). */
export declare namespace AppBskyGraphGetFollowers {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    followers: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Enumerates accounts which a specified account (actor) follows. */
export declare namespace AppBskyGraphGetFollows {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    follows: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Enumerates accounts which follow a specified account (actor) and are followed by the viewer. */
export declare namespace AppBskyGraphGetKnownFollowers {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    followers: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Gets a 'view' (with additional context) of a specified list. */
export declare namespace AppBskyGraphGetList {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of the list record to hydrate. */
    list: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    items: AppBskyGraphDefs.ListItemView[];
    list: AppBskyGraphDefs.ListView;
    cursor?: string;
  }
}

/** Get mod lists that the requesting account (actor) is blocking. Requires auth. */
export declare namespace AppBskyGraphGetListBlocks {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetListMutes {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates the lists created by a specified account (actor). */
export declare namespace AppBskyGraphGetLists {
  interface Params extends TypedBase {
    /** The account (actor) to enumerate lists from. */
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Optional filter by list purpose. If not specified, all supported types are returned. */
    purposes?: ("curatelist" | "modlist" | (string & {}))[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates the lists created by the session user, and includes membership information about `actor` in those lists. Only supports curation and moderation lists (no reference lists, used in starter packs). Requires auth. */
export declare namespace AppBskyGraphGetListsWithMembership {
  interface Params extends TypedBase {
    /** The account (actor) to check for membership. */
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Optional filter by list purpose. If not specified, all supported types are returned. */
    purposes?: ("curatelist" | "modlist" | (string & {}))[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    listsWithMembership: ListWithMembership[];
    cursor?: string;
  }
  /** A list and an optional list item indicating membership of a target user to that list. */
  interface ListWithMembership extends TypedBase {
    list: AppBskyGraphDefs.ListView;
    listItem?: AppBskyGraphDefs.ListItemView;
  }
}

/** Enumerates accounts that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetMutes {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    mutes: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerates public relationships between one account, and a list of other accounts. Does not require auth. */
export declare namespace AppBskyGraphGetRelationships {
  interface Params extends TypedBase {
    /** Primary account requesting relationships for. */
    actor: string;
    /**
     * List of 'other' accounts to be related back to the primary.
     * Maximum array length: 30
     */
    others?: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    relationships: TypeUnion<
      AppBskyGraphDefs.NotFoundActor | AppBskyGraphDefs.Relationship
    >[];
    actor?: At.DID;
  }
  interface Errors extends TypedBase {
    ActorNotFound: {};
  }
}

/** Gets a view of a starter pack. */
export declare namespace AppBskyGraphGetStarterPack {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of the starter pack record. */
    starterPack: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPack: AppBskyGraphDefs.StarterPackView;
  }
}

/** Get views for a list of starter packs. */
export declare namespace AppBskyGraphGetStarterPacks {
  interface Params extends TypedBase {
    /** Maximum array length: 25 */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
  }
}

/** Enumerates the starter packs created by the session user, and includes membership information about `actor` in those starter packs. Requires auth. */
export declare namespace AppBskyGraphGetStarterPacksWithMembership {
  interface Params extends TypedBase {
    /** The account (actor) to check for membership. */
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacksWithMembership: StarterPackWithMembership[];
    cursor?: string;
  }
  /** A starter pack and an optional list item indicating membership of a target user to that starter pack. */
  interface StarterPackWithMembership extends TypedBase {
    starterPack: AppBskyGraphDefs.StarterPackView;
    listItem?: AppBskyGraphDefs.ListItemView;
  }
}

/** Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account. */
export declare namespace AppBskyGraphGetSuggestedFollowsByActor {
  interface Params extends TypedBase {
    actor: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    suggestions: AppBskyActorDefs.ProfileView[];
    /**
     * If true, response has fallen-back to generic results, and is not scoped using relativeToDid
     * \@default false
     */
    isFallback?: boolean;
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: number;
  }
}

export declare namespace AppBskyGraphList {
  /** Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.list";
    createdAt: string;
    /**
     * Display name for list; can not be empty.
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    /** Defines the purpose of the list (aka, moderation-oriented or curration-oriented) */
    purpose: AppBskyGraphDefs.ListPurpose;
    avatar?: At.Blob;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
  }
  type Main = Record;
}

export declare namespace AppBskyGraphListblock {
  /** Record representing a block relationship against an entire an entire list of accounts (actors). */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.listblock";
    createdAt: string;
    /** Reference (AT-URI) to the mod list record. */
    subject: At.Uri;
  }
  type Main = Record;
}

export declare namespace AppBskyGraphListitem {
  /** Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.listitem";
    createdAt: string;
    /** Reference (AT-URI) to the list record (app.bsky.graph.list). */
    list: At.Uri;
    /** The account which is included on the list. */
    subject: At.DID;
  }
  type Main = Record;
}

/** Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActor {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    actor: string;
  }
  type Output = undefined;
}

/** Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActorList {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    list: At.Uri;
  }
  type Output = undefined;
}

/** Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteThread {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    root: At.Uri;
  }
  type Output = undefined;
}

/** Find starter packs matching search criteria. Does not require auth. */
export declare namespace AppBskyGraphSearchStarterPacks {
  interface Params extends TypedBase {
    /** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
    cursor?: string;
  }
}

export declare namespace AppBskyGraphStarterpack {
  /** Record defining a starter pack of actors and feeds for new users. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.starterpack";
    createdAt: string;
    /** Reference (AT-URI) to the list record. */
    list: At.Uri;
    /**
     * Display name for starter pack; can not be empty.
     * Minimum string length: 1
     * Maximum string length: 500
     * Maximum grapheme length: 50
     */
    name: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    /** Maximum array length: 3 */
    feeds?: FeedItem[];
  }
  type Main = Record;
  interface FeedItem extends TypedBase {
    uri: At.Uri;
  }
}

/** Unmutes the specified account. Requires auth. */
export declare namespace AppBskyGraphUnmuteActor {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    actor: string;
  }
  type Output = undefined;
}

/** Unmutes the specified list of accounts. Requires auth. */
export declare namespace AppBskyGraphUnmuteActorList {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    list: At.Uri;
  }
  type Output = undefined;
}

/** Unmutes the specified thread. Requires auth. */
export declare namespace AppBskyGraphUnmuteThread {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    root: At.Uri;
  }
  type Output = undefined;
}

export declare namespace AppBskyGraphVerification {
  /** Record declaring a verification relationship between two accounts. Verifications are only considered valid by an app if issued by an account the app considers trusted. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.verification";
    /** Date of when the verification was created. */
    createdAt: string;
    /** Display name of the subject the verification applies to at the moment of verifying, which might not be the same at the time of viewing. The verification is only valid if the current displayName matches the one at the time of verifying. */
    displayName: string;
    /** Handle of the subject the verification applies to at the moment of verifying, which might not be the same at the time of viewing. The verification is only valid if the current handle matches the one at the time of verifying. */
    handle: At.Handle;
    /** DID of the subject the verification applies to. */
    subject: At.DID;
  }
  type Main = Record;
}

export declare namespace AppBskyLabelerDefs {
  interface LabelerPolicies extends TypedBase {
    /** The label values which this labeler publishes. May include global or custom labels. */
    labelValues: ComAtprotoLabelDefs.LabelValue[];
    /** Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler. */
    labelValueDefinitions?: ComAtprotoLabelDefs.LabelValueDefinition[];
  }
  interface LabelerView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: LabelerViewerState;
  }
  interface LabelerViewDetailed extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    policies: AppBskyLabelerDefs.LabelerPolicies;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    /** The set of report reason 'codes' which are in-scope for this service to review and action. These usually align to policy categories. If not defined (distinct from empty array), all reason types are allowed. */
    reasonTypes?: ComAtprotoModerationDefs.ReasonType[];
    /** Set of record types (collection NSIDs) which can be reported to this service. If not defined (distinct from empty array), default is any record type. */
    subjectCollections?: string[];
    /** The set of subject types (account, record, etc) this service accepts reports on. */
    subjectTypes?: ComAtprotoModerationDefs.SubjectType[];
    viewer?: LabelerViewerState;
  }
  interface LabelerViewerState extends TypedBase {
    like?: At.Uri;
  }
}

/** Get information about a list of labeler services. */
export declare namespace AppBskyLabelerGetServices {
  interface Params extends TypedBase {
    dids: At.DID[];
    /** \@default false */
    detailed?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    views: TypeUnion<
      AppBskyLabelerDefs.LabelerView | AppBskyLabelerDefs.LabelerViewDetailed
    >[];
  }
}

export declare namespace AppBskyLabelerService {
  /** A declaration of the existence of labeler service. */
  interface Record extends RecordBase {
    $type: "app.bsky.labeler.service";
    createdAt: string;
    policies: AppBskyLabelerDefs.LabelerPolicies;
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
    /** The set of report reason 'codes' which are in-scope for this service to review and action. These usually align to policy categories. If not defined (distinct from empty array), all reason types are allowed. */
    reasonTypes?: ComAtprotoModerationDefs.ReasonType[];
    /** Set of record types (collection NSIDs) which can be reported to this service. If not defined (distinct from empty array), default is any record type. */
    subjectCollections?: string[];
    /** The set of subject types (account, record, etc) this service accepts reports on. */
    subjectTypes?: ComAtprotoModerationDefs.SubjectType[];
  }
  type Main = Record;
}

export declare namespace AppBskyNotificationDeclaration {
  /** A declaration of the user's choices related to notifications that can be produced by them. */
  interface Record extends RecordBase {
    $type: "app.bsky.notification.declaration";
    /** A declaration of the user's preference for allowing activity subscriptions from other users. Absence of a record implies 'followers'. */
    allowSubscriptions: "followers" | "mutuals" | "none" | (string & {});
  }
  type Main = Record;
}

export declare namespace AppBskyNotificationDefs {
  interface ActivitySubscription extends TypedBase {
    post: boolean;
    reply: boolean;
  }
  interface ChatPreference extends TypedBase {
    include: "accepted" | "all" | (string & {});
    push: boolean;
  }
  interface FilterablePreference extends TypedBase {
    include: "all" | "follows" | (string & {});
    list: boolean;
    push: boolean;
  }
  interface Preference extends TypedBase {
    list: boolean;
    push: boolean;
  }
  interface Preferences extends TypedBase {
    chat: ChatPreference;
    follow: FilterablePreference;
    like: FilterablePreference;
    likeViaRepost: FilterablePreference;
    mention: FilterablePreference;
    quote: FilterablePreference;
    reply: FilterablePreference;
    repost: FilterablePreference;
    repostViaRepost: FilterablePreference;
    starterpackJoined: Preference;
    subscribedPost: Preference;
    unverified: Preference;
    verified: Preference;
  }
  interface RecordDeleted extends TypedBase {}
  /** Object used to store activity subscription data in stash. */
  interface SubjectActivitySubscription extends TypedBase {
    activitySubscription: ActivitySubscription;
    subject: At.DID;
  }
}

/** Get notification-related preferences for an account. Requires auth. */
export declare namespace AppBskyNotificationGetPreferences {
  type Input = undefined;
  interface Output extends TypedBase {
    preferences: AppBskyNotificationDefs.Preferences;
  }
}

/** Count the number of unread notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationGetUnreadCount {
  interface Params extends TypedBase {
    priority?: boolean;
    seenAt?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    count: number;
  }
}

/** Enumerate all accounts to which the requesting account is subscribed to receive notifications for. Requires auth. */
export declare namespace AppBskyNotificationListActivitySubscriptions {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    subscriptions: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerate notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationListNotifications {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    priority?: boolean;
    /**
     * Notification reasons to include in response.
     * A reason that matches the reason property of #notification.
     */
    reasons?: string[];
    seenAt?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    notifications: Notification[];
    cursor?: string;
    priority?: boolean;
    seenAt?: string;
  }
  interface Notification extends TypedBase {
    author: AppBskyActorDefs.ProfileView;
    cid: At.CID;
    indexedAt: string;
    isRead: boolean;
    /** The reason why this notification was delivered - e.g. your post was liked, or you received a new follower. */
    reason:
      | "contact-match"
      | "follow"
      | "like"
      | "like-via-repost"
      | "mention"
      | "quote"
      | "reply"
      | "repost"
      | "repost-via-repost"
      | "starterpack-joined"
      | "subscribed-post"
      | "unverified"
      | "verified"
      | (string & {});
    record: unknown;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    reasonSubject?: At.Uri;
  }
}

/** Puts an activity subscription entry. The key should be omitted for creation and provided for updates. Requires auth. */
export declare namespace AppBskyNotificationPutActivitySubscription {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    activitySubscription: AppBskyNotificationDefs.ActivitySubscription;
    subject: At.DID;
  }
  interface Output extends TypedBase {
    subject: At.DID;
    activitySubscription?: AppBskyNotificationDefs.ActivitySubscription;
  }
}

/** Set notification-related preferences for an account. Requires auth. */
export declare namespace AppBskyNotificationPutPreferences {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    priority: boolean;
  }
  type Output = undefined;
}

/** Set notification-related preferences for an account. Requires auth. */
export declare namespace AppBskyNotificationPutPreferencesV2 {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    chat?: AppBskyNotificationDefs.ChatPreference;
    follow?: AppBskyNotificationDefs.FilterablePreference;
    like?: AppBskyNotificationDefs.FilterablePreference;
    likeViaRepost?: AppBskyNotificationDefs.FilterablePreference;
    mention?: AppBskyNotificationDefs.FilterablePreference;
    quote?: AppBskyNotificationDefs.FilterablePreference;
    reply?: AppBskyNotificationDefs.FilterablePreference;
    repost?: AppBskyNotificationDefs.FilterablePreference;
    repostViaRepost?: AppBskyNotificationDefs.FilterablePreference;
    starterpackJoined?: AppBskyNotificationDefs.Preference;
    subscribedPost?: AppBskyNotificationDefs.Preference;
    unverified?: AppBskyNotificationDefs.Preference;
    verified?: AppBskyNotificationDefs.Preference;
  }
  interface Output extends TypedBase {
    preferences: AppBskyNotificationDefs.Preferences;
  }
}

/** Register to receive push notifications, via a specified service, for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationRegisterPush {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    appId: string;
    platform: "android" | "ios" | "web" | (string & {});
    serviceDid: At.DID;
    token: string;
    /** Set to true when the actor is age restricted */
    ageRestricted?: boolean;
  }
  type Output = undefined;
}

/** The inverse of registerPush - inform a specified service that push notifications should no longer be sent to the given token for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationUnregisterPush {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    appId: string;
    platform: "android" | "ios" | "web" | (string & {});
    serviceDid: At.DID;
    token: string;
  }
  type Output = undefined;
}

/** Notify server that the requesting account has seen notifications. Requires auth. */
export declare namespace AppBskyNotificationUpdateSeen {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    seenAt: string;
  }
  type Output = undefined;
}

export declare namespace AppBskyRichtextFacet {
  /** Annotation of a sub-string within rich text. */
  interface Main extends TypedBase {
    features: TypeUnion<Link | Mention | Tag>[];
    index: ByteSlice;
  }
  /** Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets. */
  interface ByteSlice extends TypedBase {
    /** Minimum: 0 */
    byteEnd: number;
    /** Minimum: 0 */
    byteStart: number;
  }
  /** Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL. */
  interface Link extends TypedBase {
    uri: string;
  }
  /** Facet feature for mention of another account. The text is usually a handle, including a '\@' prefix, but the facet reference is a DID. */
  interface Mention extends TypedBase {
    did: At.DID;
  }
  /** Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags'). */
  interface Tag extends TypedBase {
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag: string;
  }
}

export declare namespace AppBskyUnspeccedDefs {
  /** Object used to store age assurance data in stash. */
  interface AgeAssuranceEvent extends TypedBase {
    /** The unique identifier for this instance of the age assurance flow, in UUID format. */
    attemptId: string;
    /** The date and time of this write operation. */
    createdAt: string;
    /** The status of the age assurance process. */
    status: "assured" | "pending" | "unknown" | (string & {});
    /** The IP address used when completing the AA flow. */
    completeIp?: string;
    /** The user agent used when completing the AA flow. */
    completeUa?: string;
    /** The email used for AA. */
    email?: string;
    /** The IP address used when initiating the AA flow. */
    initIp?: string;
    /** The user agent used when initiating the AA flow. */
    initUa?: string;
  }
  /** The computed state of the age assurance process, returned to the user in question on certain authenticated requests. */
  interface AgeAssuranceState extends TypedBase {
    /** The status of the age assurance process. */
    status: "assured" | "blocked" | "pending" | "unknown" | (string & {});
    /** The timestamp when this state was last updated. */
    lastInitiatedAt?: string;
  }
  interface SkeletonSearchActor extends TypedBase {
    did: At.DID;
  }
  interface SkeletonSearchPost extends TypedBase {
    uri: At.Uri;
  }
  interface SkeletonSearchStarterPack extends TypedBase {
    uri: At.Uri;
  }
  interface SkeletonTrend extends TypedBase {
    dids: At.DID[];
    displayName: string;
    link: string;
    postCount: number;
    startedAt: string;
    topic: string;
    category?: string;
    status?: "hot" | (string & {});
  }
  interface ThreadItemBlocked extends TypedBase {
    author: AppBskyFeedDefs.BlockedAuthor;
  }
  interface ThreadItemNotFound extends TypedBase {}
  interface ThreadItemNoUnauthenticated extends TypedBase {}
  interface ThreadItemPost extends TypedBase {
    /** The threadgate created by the author indicates this post as a reply to be hidden for everyone consuming the thread. */
    hiddenByThreadgate: boolean;
    /** This post has more parents that were not present in the response. This is just a boolean, without the number of parents. */
    moreParents: boolean;
    /** This post has more replies that were not present in the response. This is a numeric value, which is best-effort and might not be accurate. */
    moreReplies: number;
    /** This is by an account muted by the viewer requesting it. */
    mutedByViewer: boolean;
    /** This post is part of a contiguous thread by the OP from the thread root. Many different OP threads can happen in the same thread. */
    opThread: boolean;
    post: AppBskyFeedDefs.PostView;
  }
  interface TrendingTopic extends TypedBase {
    link: string;
    topic: string;
    description?: string;
    displayName?: string;
  }
  interface TrendView extends TypedBase {
    actors: AppBskyActorDefs.ProfileViewBasic[];
    displayName: string;
    link: string;
    postCount: number;
    startedAt: string;
    topic: string;
    category?: string;
    status?: "hot" | (string & {});
  }
}

/** Returns the current state of the age assurance process for an account. This is used to check if the user has completed age assurance or if further action is required. */
export declare namespace AppBskyUnspeccedGetAgeAssuranceState {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = AppBskyUnspeccedDefs.AgeAssuranceState;
}

/** Get miscellaneous runtime configuration. */
export declare namespace AppBskyUnspeccedGetConfig {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    checkEmailConfirmed?: boolean;
    liveNow?: LiveNowConfig[];
  }
  interface LiveNowConfig extends TypedBase {
    did: At.DID;
    domains: string[];
  }
}

/** Get a list of suggested starterpacks for onboarding */
export declare namespace AppBskyUnspeccedGetOnboardingSuggestedStarterPacks {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackView[];
  }
}

/** Get a skeleton of suggested starterpacks for onboarding. Intended to be called and hydrated by app.bsky.unspecced.getOnboardingSuggestedStarterPacks */
export declare namespace AppBskyUnspeccedGetOnboardingSuggestedStarterPacksSkeleton {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: At.Uri[];
  }
}

/** An unspecced view of globally popular feed generators. */
export declare namespace AppBskyUnspeccedGetPopularFeedGenerators {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    query?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** (NOTE: this endpoint is under development and WILL change without notice. Don't use it until it is moved out of `unspecced` or your application WILL break) Get additional posts under a thread e.g. replies hidden by threadgate. Based on an anchor post at any depth of the tree, returns top-level replies below that anchor. It does not include ancestors nor the anchor itself. This should be called after exhausting `app.bsky.unspecced.getPostThreadV2`. Does not require auth, but additional metadata and filtering will be applied for authed requests. */
export declare namespace AppBskyUnspeccedGetPostThreadOtherV2 {
  interface Params extends TypedBase {
    /** Reference (AT-URI) to post record. This is the anchor post. */
    anchor: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** A flat list of other thread items. The depth of each item is indicated by the depth property inside the item. */
    thread: ThreadItem[];
  }
  interface ThreadItem extends TypedBase {
    /** The nesting level of this item in the thread. Depth 0 means the anchor item. Items above have negative depths, items below have positive depths. */
    depth: number;
    uri: At.Uri;
    value: TypeUnion<AppBskyUnspeccedDefs.ThreadItemPost>;
  }
}

/** (NOTE: this endpoint is under development and WILL change without notice. Don't use it until it is moved out of `unspecced` or your application WILL break) Get posts in a thread. It is based in an anchor post at any depth of the tree, and returns posts above it (recursively resolving the parent, without further branching to their replies) and below it (recursive replies, with branching to their replies). Does not require auth, but additional metadata and filtering will be applied for authed requests. */
export declare namespace AppBskyUnspeccedGetPostThreadV2 {
  interface Params extends TypedBase {
    /** Reference (AT-URI) to post record. This is the anchor post, and the thread will be built around it. It can be any post in the tree, not necessarily a root post. */
    anchor: At.Uri;
    /**
     * Whether to include parents above the anchor.
     * \@default true
     */
    above?: boolean;
    /**
     * How many levels of replies to include below the anchor.
     * Minimum: 0
     * Maximum: 20
     * \@default 6
     */
    below?: number;
    /**
     * Maximum of replies to include at each level of the thread, except for the direct replies to the anchor, which are (NOTE: currently, during unspecced phase) all returned (NOTE: later they might be paginated).
     * Minimum: 0
     * Maximum: 100
     * \@default 10
     */
    branchingFactor?: number;
    /**
     * Sorting for the thread replies.
     * \@default "oldest"
     */
    sort?: "newest" | "oldest" | "top" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** Whether this thread has additional replies. If true, a call can be made to the `getPostThreadOtherV2` endpoint to retrieve them. */
    hasOtherReplies: boolean;
    /** A flat list of thread items. The depth of each item is indicated by the depth property inside the item. */
    thread: ThreadItem[];
    threadgate?: AppBskyFeedDefs.ThreadgateView;
  }
  interface ThreadItem extends TypedBase {
    /** The nesting level of this item in the thread. Depth 0 means the anchor item. Items above have negative depths, items below have positive depths. */
    depth: number;
    uri: At.Uri;
    value: TypeUnion<
      | AppBskyUnspeccedDefs.ThreadItemBlocked
      | AppBskyUnspeccedDefs.ThreadItemNotFound
      | AppBskyUnspeccedDefs.ThreadItemNoUnauthenticated
      | AppBskyUnspeccedDefs.ThreadItemPost
    >;
  }
}

/** Get a list of suggested feeds */
export declare namespace AppBskyUnspeccedGetSuggestedFeeds {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
  }
}

/** Get a skeleton of suggested feeds. Intended to be called and hydrated by app.bsky.unspecced.getSuggestedFeeds */
export declare namespace AppBskyUnspeccedGetSuggestedFeedsSkeleton {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: At.Uri[];
  }
}

/** Get a list of suggested starterpacks */
export declare namespace AppBskyUnspeccedGetSuggestedStarterPacks {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackView[];
  }
}

/** Get a skeleton of suggested starterpacks. Intended to be called and hydrated by app.bsky.unspecced.getSuggestedStarterpacks */
export declare namespace AppBskyUnspeccedGetSuggestedStarterPacksSkeleton {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: At.Uri[];
  }
}

/** Get a list of suggested users */
export declare namespace AppBskyUnspeccedGetSuggestedUsers {
  interface Params extends TypedBase {
    /** Category of users to get suggestions for. */
    category?: string;
    /**
     * Minimum: 1
     * Maximum: 50
     * \@default 25
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileView[];
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: string;
  }
}

/** Get a skeleton of suggested users. Intended to be called and hydrated by app.bsky.unspecced.getSuggestedUsers */
export declare namespace AppBskyUnspeccedGetSuggestedUsersSkeleton {
  interface Params extends TypedBase {
    /** Category of users to get suggestions for. */
    category?: string;
    /**
     * Minimum: 1
     * Maximum: 50
     * \@default 25
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    dids: At.DID[];
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: string;
  }
}

/** Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions */
export declare namespace AppBskyUnspeccedGetSuggestionsSkeleton {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer. */
    relativeToDid?: At.DID;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
    cursor?: string;
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: number;
    /** DID of the account these suggestions are relative to. If this is returned undefined, suggestions are based on the viewer. */
    relativeToDid?: At.DID;
  }
}

/** Get a list of suggestions (feeds and users) tagged with categories */
export declare namespace AppBskyUnspeccedGetTaggedSuggestions {
  type Input = undefined;
  interface Output extends TypedBase {
    suggestions: Suggestion[];
  }
  interface Suggestion extends TypedBase {
    subject: string;
    subjectType: "actor" | "feed" | (string & {});
    tag: string;
  }
}

/** Get a list of trending topics */
export declare namespace AppBskyUnspeccedGetTrendingTopics {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    suggested: AppBskyUnspeccedDefs.TrendingTopic[];
    topics: AppBskyUnspeccedDefs.TrendingTopic[];
  }
}

/** Get the current trends on the network */
export declare namespace AppBskyUnspeccedGetTrends {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    trends: AppBskyUnspeccedDefs.TrendView[];
  }
}

/** Get the skeleton of trends on the network. Intended to be called and then hydrated through app.bsky.unspecced.getTrends */
export declare namespace AppBskyUnspeccedGetTrendsSkeleton {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    trends: AppBskyUnspeccedDefs.SkeletonTrend[];
  }
}

/** Initiate age assurance for an account. This is a one-time action that will start the process of verifying the user's age. */
export declare namespace AppBskyUnspeccedInitAgeAssurance {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** An ISO 3166-1 alpha-2 code of the user's location. */
    countryCode: string;
    /** The user's email address to receive assurance instructions. */
    email: string;
    /** The user's preferred language for communication during the assurance process. */
    language: string;
  }
  type Output = AppBskyUnspeccedDefs.AgeAssuranceState;
  interface Errors extends TypedBase {
    InvalidEmail: {};
    DidTooLong: {};
    InvalidInitiation: {};
  }
}

/** Backend Actors (profile) search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchActorsSkeleton {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax. */
    q: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** If true, acts as fast/simple 'typeahead' query. */
    typeahead?: boolean;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

/** Backend Posts search, returns only skeleton */
export declare namespace AppBskyUnspeccedSearchPostsSkeleton {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Filter to posts by the given account. Handles are resolved to DID before query-time. */
    author?: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /** Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization. */
    domain?: string;
    /** Filter to posts in the given language. Expected to be based on post language field, though server may override language detection. */
    lang?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions. */
    mentions?: string;
    /** Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD). */
    since?: string;
    /**
     * Specifies the ranking order of results.
     * \@default "latest"
     */
    sort?: "latest" | "top" | (string & {});
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag?: string[];
    /** Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD). */
    until?: string;
    /** Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching. */
    url?: string;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyUnspeccedDefs.SkeletonSearchPost[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

/** Backend Starter Pack search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchStarterPacksSkeleton {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyUnspeccedDefs.SkeletonSearchStarterPack[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

export declare namespace AppBskyVideoDefs {
  interface JobStatus extends TypedBase {
    did: At.DID;
    jobId: string;
    /** The state of the video processing job. All values not listed as a known value indicate that the job is in process. */
    state: "JOB_STATE_COMPLETED" | "JOB_STATE_FAILED" | (string & {});
    blob?: At.Blob;
    error?: string;
    message?: string;
    /**
     * Progress within the current processing state.
     * Minimum: 0
     * Maximum: 100
     */
    progress?: number;
  }
}

/** Get status details for a video processing job. */
export declare namespace AppBskyVideoGetJobStatus {
  interface Params extends TypedBase {
    jobId: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    jobStatus: AppBskyVideoDefs.JobStatus;
  }
}

/** Get video upload limits for the authenticated user. */
export declare namespace AppBskyVideoGetUploadLimits {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    canUpload: boolean;
    error?: string;
    message?: string;
    remainingDailyBytes?: number;
    remainingDailyVideos?: number;
  }
}

/** Upload a video to be processed then stored on the PDS. */
export declare namespace AppBskyVideoUploadVideo {
  interface Params extends TypedBase {}
  type Input = Blob | ArrayBufferView;
  interface Output extends TypedBase {
    jobStatus: AppBskyVideoDefs.JobStatus;
  }
}

export declare namespace ChatBskyActorDeclaration {
  /** A declaration of a Bluesky chat account. */
  interface Record extends RecordBase {
    $type: "chat.bsky.actor.declaration";
    allowIncoming: "all" | "following" | "none" | (string & {});
  }
  type Main = Record;
}

export declare namespace ChatBskyActorDefs {
  interface ProfileViewBasic extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: AppBskyActorDefs.ProfileAssociated;
    avatar?: string;
    /** Set to true when the actor cannot actively participate in conversations */
    chatDisabled?: boolean;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    verification?: AppBskyActorDefs.VerificationState;
    viewer?: AppBskyActorDefs.ViewerState;
  }
}

export declare namespace ChatBskyActorDeleteAccount {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {}
}

export declare namespace ChatBskyActorExportAccountData {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = Uint8Array;
}

export declare namespace ChatBskyAuthFullChatClient {
  type Main = At.PermissionSet;
}

export declare namespace ChatBskyConvoAcceptConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    /** Rev when the convo was accepted. If not present, the convo was already accepted. */
    rev?: string;
  }
}

/** Adds an emoji reaction to a message. Requires authentication. It is idempotent, so multiple calls from the same user with the same emoji result in a single reaction. */
export declare namespace ChatBskyConvoAddReaction {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    messageId: string;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     * Maximum grapheme length: 1
     */
    value: string;
  }
  interface Output extends TypedBase {
    message: ChatBskyConvoDefs.MessageView;
  }
  interface Errors extends TypedBase {
    ReactionMessageDeleted: {};
    ReactionLimitReached: {};
    ReactionInvalidValue: {};
  }
}

export declare namespace ChatBskyConvoDefs {
  interface ConvoView extends TypedBase {
    id: string;
    members: ChatBskyActorDefs.ProfileViewBasic[];
    muted: boolean;
    rev: string;
    unreadCount: number;
    lastMessage?: TypeUnion<DeletedMessageView | MessageView>;
    lastReaction?: TypeUnion<MessageAndReactionView>;
    status?: "accepted" | "request" | (string & {});
  }
  interface DeletedMessageView extends TypedBase {
    id: string;
    rev: string;
    sender: MessageViewSender;
    sentAt: string;
  }
  interface LogAcceptConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogAddReaction extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    reaction: ReactionView;
    rev: string;
  }
  interface LogBeginConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogCreateMessage extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogDeleteMessage extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogLeaveConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogMuteConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogReadMessage extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogRemoveReaction extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    reaction: ReactionView;
    rev: string;
  }
  interface LogUnmuteConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface MessageAndReactionView extends TypedBase {
    message: MessageView;
    reaction: ReactionView;
  }
  interface MessageInput extends TypedBase {
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    text: string;
    embed?: TypeUnion<AppBskyEmbedRecord.Main>;
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
  }
  interface MessageRef extends TypedBase {
    convoId: string;
    did: At.DID;
    messageId: string;
  }
  interface MessageView extends TypedBase {
    id: string;
    rev: string;
    sender: MessageViewSender;
    sentAt: string;
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    text: string;
    embed?: TypeUnion<AppBskyEmbedRecord.View>;
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
    /** Reactions to this message, in ascending order of creation time. */
    reactions?: ReactionView[];
  }
  interface MessageViewSender extends TypedBase {
    did: At.DID;
  }
  interface ReactionView extends TypedBase {
    createdAt: string;
    sender: ReactionViewSender;
    value: string;
  }
  interface ReactionViewSender extends TypedBase {
    did: At.DID;
  }
}

export declare namespace ChatBskyConvoDeleteMessageForSelf {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    messageId: string;
  }
  type Output = ChatBskyConvoDefs.DeletedMessageView;
}

export declare namespace ChatBskyConvoGetConvo {
  interface Params extends TypedBase {
    convoId: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

/** Get whether the requester and the other members can chat. If an existing convo is found for these members, it is returned. */
export declare namespace ChatBskyConvoGetConvoAvailability {
  interface Params extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 10
     */
    members: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    canChat: boolean;
    convo?: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoGetConvoForMembers {
  interface Params extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 10
     */
    members: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoGetLog {
  interface Params extends TypedBase {
    cursor?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    logs: TypeUnion<
      | ChatBskyConvoDefs.LogAcceptConvo
      | ChatBskyConvoDefs.LogAddReaction
      | ChatBskyConvoDefs.LogBeginConvo
      | ChatBskyConvoDefs.LogCreateMessage
      | ChatBskyConvoDefs.LogDeleteMessage
      | ChatBskyConvoDefs.LogLeaveConvo
      | ChatBskyConvoDefs.LogMuteConvo
      | ChatBskyConvoDefs.LogReadMessage
      | ChatBskyConvoDefs.LogRemoveReaction
      | ChatBskyConvoDefs.LogUnmuteConvo
    >[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoGetMessages {
  interface Params extends TypedBase {
    convoId: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    messages: TypeUnion<
      ChatBskyConvoDefs.DeletedMessageView | ChatBskyConvoDefs.MessageView
    >[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoLeaveConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    convoId: string;
    rev: string;
  }
}

export declare namespace ChatBskyConvoListConvos {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    readState?: "unread" | (string & {});
    status?: "accepted" | "request" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    convos: ChatBskyConvoDefs.ConvoView[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoMuteConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

/** Removes an emoji reaction from a message. Requires authentication. It is idempotent, so multiple calls from the same user with the same emoji result in that reaction not being present, even if it already wasn't. */
export declare namespace ChatBskyConvoRemoveReaction {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    messageId: string;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     * Maximum grapheme length: 1
     */
    value: string;
  }
  interface Output extends TypedBase {
    message: ChatBskyConvoDefs.MessageView;
  }
  interface Errors extends TypedBase {
    ReactionMessageDeleted: {};
    ReactionInvalidValue: {};
  }
}

export declare namespace ChatBskyConvoSendMessage {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    message: ChatBskyConvoDefs.MessageInput;
  }
  type Output = ChatBskyConvoDefs.MessageView;
}

export declare namespace ChatBskyConvoSendMessageBatch {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Maximum array length: 100 */
    items: BatchItem[];
  }
  interface Output extends TypedBase {
    items: ChatBskyConvoDefs.MessageView[];
  }
  interface BatchItem extends TypedBase {
    convoId: string;
    message: ChatBskyConvoDefs.MessageInput;
  }
}

export declare namespace ChatBskyConvoUnmuteConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoUpdateAllRead {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    status?: "accepted" | "request" | (string & {});
  }
  interface Output extends TypedBase {
    /** The count of updated convos. */
    updatedCount: number;
  }
}

export declare namespace ChatBskyConvoUpdateRead {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    messageId?: string;
  }
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyModerationGetActorMetadata {
  interface Params extends TypedBase {
    actor: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    all: Metadata;
    day: Metadata;
    month: Metadata;
  }
  interface Metadata extends TypedBase {
    convos: number;
    convosStarted: number;
    messagesReceived: number;
    messagesSent: number;
  }
}

export declare namespace ChatBskyModerationGetMessageContext {
  interface Params extends TypedBase {
    messageId: string;
    /** \@default 5 */
    after?: number;
    /** \@default 5 */
    before?: number;
    /** Conversation that the message is from. NOTE: this field will eventually be required. */
    convoId?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    messages: TypeUnion<
      ChatBskyConvoDefs.DeletedMessageView | ChatBskyConvoDefs.MessageView
    >[];
  }
}

export declare namespace ChatBskyModerationUpdateActorAccess {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    actor: At.DID;
    allowAccess: boolean;
    ref?: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoAdminDefs {
  interface AccountView extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    deactivatedAt?: string;
    email?: string;
    emailConfirmedAt?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invites?: ComAtprotoServerDefs.InviteCode[];
    invitesDisabled?: boolean;
    relatedRecords?: unknown[];
    threatSignatures?: ThreatSignature[];
  }
  interface RepoBlobRef extends TypedBase {
    cid: At.CID;
    did: At.DID;
    recordUri?: At.Uri;
  }
  interface RepoRef extends TypedBase {
    did: At.DID;
  }
  interface StatusAttr extends TypedBase {
    applied: boolean;
    ref?: string;
  }
  interface ThreatSignature extends TypedBase {
    property: string;
    value: string;
  }
}

/** Delete a user account as an administrator. */
export declare namespace ComAtprotoAdminDeleteAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
  }
  type Output = undefined;
}

/** Disable an account from receiving new invite codes, but does not invalidate existing codes. */
export declare namespace ComAtprotoAdminDisableAccountInvites {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    account: At.DID;
    /** Optional reason for disabled invites. */
    note?: string;
  }
  type Output = undefined;
}

/** Disable some set of codes and/or all codes associated with a set of users. */
export declare namespace ComAtprotoAdminDisableInviteCodes {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    accounts?: string[];
    codes?: string[];
  }
  type Output = undefined;
}

/** Re-enable an account's ability to receive invite codes. */
export declare namespace ComAtprotoAdminEnableAccountInvites {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    account: At.DID;
    /** Optional reason for enabled invites. */
    note?: string;
  }
  type Output = undefined;
}

/** Get details about an account. */
export declare namespace ComAtprotoAdminGetAccountInfo {
  interface Params extends TypedBase {
    did: At.DID;
  }
  type Input = undefined;
  type Output = ComAtprotoAdminDefs.AccountView;
}

/** Get details about some accounts. */
export declare namespace ComAtprotoAdminGetAccountInfos {
  interface Params extends TypedBase {
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    infos: ComAtprotoAdminDefs.AccountView[];
  }
}

/** Get an admin view of invite codes. */
export declare namespace ComAtprotoAdminGetInviteCodes {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 500
     * \@default 100
     */
    limit?: number;
    /** \@default "recent" */
    sort?: "recent" | "usage" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    codes: ComAtprotoServerDefs.InviteCode[];
    cursor?: string;
  }
}

/** Get the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminGetSubjectStatus {
  interface Params extends TypedBase {
    blob?: At.CID;
    did?: At.DID;
    uri?: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    subject: TypeUnion<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    deactivated?: ComAtprotoAdminDefs.StatusAttr;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
}

/** Get list of accounts that matches your search query. */
export declare namespace ComAtprotoAdminSearchAccounts {
  interface Params extends TypedBase {
    cursor?: string;
    email?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    accounts: ComAtprotoAdminDefs.AccountView[];
    cursor?: string;
  }
}

/** Send email to a user's account email address. */
export declare namespace ComAtprotoAdminSendEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    content: string;
    recipientDid: At.DID;
    senderDid: At.DID;
    /** Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers */
    comment?: string;
    subject?: string;
  }
  interface Output extends TypedBase {
    sent: boolean;
  }
}

/** Administrative action to update an account's email. */
export declare namespace ComAtprotoAdminUpdateAccountEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The handle or DID of the repo. */
    account: string;
    email: string;
  }
  type Output = undefined;
}

/** Administrative action to update an account's handle. */
export declare namespace ComAtprotoAdminUpdateAccountHandle {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    handle: At.Handle;
  }
  type Output = undefined;
}

/** Update the password for a user account as an administrator. */
export declare namespace ComAtprotoAdminUpdateAccountPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    password: string;
  }
  type Output = undefined;
}

/** Administrative action to update an account's signing key in their Did document. */
export declare namespace ComAtprotoAdminUpdateAccountSigningKey {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    /** Did-key formatted public key */
    signingKey: At.DID;
  }
  type Output = undefined;
}

/** Update the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminUpdateSubjectStatus {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    subject: TypeUnion<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    deactivated?: ComAtprotoAdminDefs.StatusAttr;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
  interface Output extends TypedBase {
    subject: TypeUnion<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
}

export declare namespace ComAtprotoIdentityDefs {
  interface IdentityInfo extends TypedBase {
    did: At.DID;
    /** The complete DID document for the identity. */
    didDoc: unknown;
    /** The validated handle of the account; or 'handle.invalid' if the handle did not bi-directionally match the DID document. */
    handle: At.Handle;
  }
}

/** Describe the credentials that should be included in the DID doc of an account that is migrating to this service. */
export declare namespace ComAtprotoIdentityGetRecommendedDidCredentials {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    alsoKnownAs?: string[];
    /** Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs. */
    rotationKeys?: string[];
    services?: unknown;
    verificationMethods?: unknown;
  }
}

/** Request that the server re-resolve an identity (DID and handle). The server may ignore this request, or require authentication, depending on the role, implementation, and policy of the server. */
export declare namespace ComAtprotoIdentityRefreshIdentity {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    identifier: string;
  }
  type Output = ComAtprotoIdentityDefs.IdentityInfo;
  interface Errors extends TypedBase {
    HandleNotFound: {};
    DidNotFound: {};
    DidDeactivated: {};
  }
}

/** Request an email with a code to in order to request a signed PLC operation. Requires Auth. */
export declare namespace ComAtprotoIdentityRequestPlcOperationSignature {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Resolves DID to DID document. Does not bi-directionally verify handle. */
export declare namespace ComAtprotoIdentityResolveDid {
  interface Params extends TypedBase {
    /** DID to resolve. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** The complete DID document for the identity. */
    didDoc: unknown;
  }
  interface Errors extends TypedBase {
    DidNotFound: {};
    DidDeactivated: {};
  }
}

/** Resolves an atproto handle (hostname) to a DID. Does not necessarily bi-directionally verify against the the DID document. */
export declare namespace ComAtprotoIdentityResolveHandle {
  interface Params extends TypedBase {
    /** The handle to resolve. */
    handle: At.Handle;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    did: At.DID;
  }
  interface Errors extends TypedBase {
    HandleNotFound: {};
  }
}

/** Resolves an identity (DID or Handle) to a full identity (DID document and verified handle). */
export declare namespace ComAtprotoIdentityResolveIdentity {
  interface Params extends TypedBase {
    /** Handle or DID to resolve. */
    identifier: string;
  }
  type Input = undefined;
  type Output = ComAtprotoIdentityDefs.IdentityInfo;
  interface Errors extends TypedBase {
    HandleNotFound: {};
    DidNotFound: {};
    DidDeactivated: {};
  }
}

/** Signs a PLC operation to update some value(s) in the requesting DID's document. */
export declare namespace ComAtprotoIdentitySignPlcOperation {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    alsoKnownAs?: string[];
    rotationKeys?: string[];
    services?: unknown;
    /** A token received through com.atproto.identity.requestPlcOperationSignature */
    token?: string;
    verificationMethods?: unknown;
  }
  interface Output extends TypedBase {
    /** A signed DID PLC operation. */
    operation: unknown;
  }
}

/** Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry */
export declare namespace ComAtprotoIdentitySubmitPlcOperation {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    operation: unknown;
  }
  type Output = undefined;
}

/** Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth. */
export declare namespace ComAtprotoIdentityUpdateHandle {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The new handle. */
    handle: At.Handle;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoLabelDefs {
  /** Metadata tag on an atproto resource (eg, repo or record). */
  interface Label extends TypedBase {
    /** Timestamp when this label was created. */
    cts: string;
    /** DID of the actor who created this label. */
    src: At.DID;
    /** AT URI of the record, repository (account), or other resource that this label applies to. */
    uri: string;
    /**
     * The short string name of the value or type of this label.
     * Maximum string length: 128
     */
    val: string;
    /** Optionally, CID specifying the specific version of 'uri' resource this label applies to. */
    cid?: At.CID;
    /** Timestamp at which this label expires (no longer applies). */
    exp?: string;
    /** If true, this is a negation label, overwriting a previous label. */
    neg?: boolean;
    /** Signature of dag-cbor encoded label. */
    sig?: At.Bytes;
    /** The AT Protocol version of the label object. */
    ver?: number;
  }
  type LabelValue =
    | "!hide"
    | "!no-promote"
    | "!no-unauthenticated"
    | "!warn"
    | "dmca-violation"
    | "doxxing"
    | "gore"
    | "nsfl"
    | "nudity"
    | "porn"
    | "sexual"
    | (string & {});
  /** Declares a label value and its expected interpretations and behaviors. */
  interface LabelValueDefinition extends TypedBase {
    /** What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing. */
    blurs: "content" | "media" | "none" | (string & {});
    /**
     * The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).
     * Maximum string length: 100
     * Maximum grapheme length: 100
     */
    identifier: string;
    locales: LabelValueDefinitionStrings[];
    /** How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing. */
    severity: "alert" | "inform" | "none" | (string & {});
    /** Does the user need to have adult content enabled in order to configure this label? */
    adultOnly?: boolean;
    /**
     * The default setting for this label.
     * \@default "warn"
     */
    defaultSetting?: "hide" | "ignore" | "warn" | (string & {});
  }
  /** Strings which describe the label in the UI, localized into a specific language. */
  interface LabelValueDefinitionStrings extends TypedBase {
    /**
     * A longer description of what the label means and why it might be applied.
     * Maximum string length: 100000
     * Maximum grapheme length: 10000
     */
    description: string;
    /** The code of the language these strings are written in. */
    lang: string;
    /**
     * A short human-readable name for the label.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    name: string;
  }
  /** Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel. */
  interface SelfLabel extends TypedBase {
    /**
     * The short string name of the value or type of this label.
     * Maximum string length: 128
     */
    val: string;
  }
  /** Metadata tags on an atproto record, published by the author within the record. */
  interface SelfLabels extends TypedBase {
    /** Maximum array length: 10 */
    values: SelfLabel[];
  }
}

/** Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth. */
export declare namespace ComAtprotoLabelQueryLabels {
  interface Params extends TypedBase {
    /** List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI. */
    uriPatterns: string[];
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 250
     * \@default 50
     */
    limit?: number;
    /** Optional list of label sources (DIDs) to filter on. */
    sources?: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    labels: ComAtprotoLabelDefs.Label[];
    cursor?: string;
  }
}

export declare namespace ComAtprotoLabelSubscribeLabels {
  interface Params extends TypedBase {
    /** The last known event seq number to backfill from. */
    cursor?: number;
  }
  type Message = TypeUnion<Info | Labels>;
  interface Errors extends TypedBase {
    FutureCursor: {};
  }
  interface Info extends TypedBase {
    name: "OutdatedCursor" | (string & {});
    message?: string;
  }
  interface Labels extends TypedBase {
    labels: ComAtprotoLabelDefs.Label[];
    seq: number;
  }
}

/** Resolves an atproto lexicon (NSID) to a schema. */
export declare namespace ComAtprotoLexiconResolveLexicon {
  interface Params extends TypedBase {
    /** The lexicon NSID to resolve. */
    nsid: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** The CID of the lexicon schema record. */
    cid: At.CID;
    /** The resolved lexicon schema record. */
    schema: ComAtprotoLexiconSchema.Main;
    /** The AT-URI of the lexicon schema record. */
    uri: At.Uri;
  }
  interface Errors extends TypedBase {
    LexiconNotFound: {};
  }
}

export declare namespace ComAtprotoLexiconSchema {
  /** Representation of Lexicon schemas themselves, when published as atproto records. Note that the schema language is not defined in Lexicon; this meta schema currently only includes a single version field ('lexicon'). See the atproto specifications for description of the other expected top-level fields ('id', 'defs', etc). */
  interface Record extends RecordBase {
    $type: "com.atproto.lexicon.schema";
    /** Indicates the 'version' of the Lexicon language. Must be '1' for the current atproto/Lexicon schema system. */
    lexicon: number;
  }
  type Main = Record;
}

/** Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth. */
export declare namespace ComAtprotoModerationCreateReport {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Indicates the broad category of violation the report is for. */
    reasonType: ComAtprotoModerationDefs.ReasonType;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    modTool?: ModTool;
    /**
     * Additional context about the content and violation.
     * Maximum string length: 20000
     * Maximum grapheme length: 2000
     */
    reason?: string;
  }
  interface Output extends TypedBase {
    createdAt: string;
    id: number;
    reasonType: ComAtprotoModerationDefs.ReasonType;
    reportedBy: At.DID;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /**
     * Maximum string length: 20000
     * Maximum grapheme length: 2000
     */
    reason?: string;
  }
  /** Moderation tool information for tracing the source of the action */
  interface ModTool extends TypedBase {
    /** Name/identifier of the source (e.g., 'bsky-app/android', 'bsky-web/chrome') */
    name: string;
    /** Additional arbitrary metadata about the source */
    meta?: unknown;
  }
}

export declare namespace ComAtprotoModerationDefs {
  type ReasonAppeal = "com.atproto.moderation.defs#reasonAppeal";
  type ReasonMisleading = "com.atproto.moderation.defs#reasonMisleading";
  type ReasonOther = "com.atproto.moderation.defs#reasonOther";
  type ReasonRude = "com.atproto.moderation.defs#reasonRude";
  type ReasonSexual = "com.atproto.moderation.defs#reasonSexual";
  type ReasonSpam = "com.atproto.moderation.defs#reasonSpam";
  type ReasonType =
    | "com.atproto.moderation.defs#reasonAppeal"
    | "com.atproto.moderation.defs#reasonMisleading"
    | "com.atproto.moderation.defs#reasonOther"
    | "com.atproto.moderation.defs#reasonRude"
    | "com.atproto.moderation.defs#reasonSexual"
    | "com.atproto.moderation.defs#reasonSpam"
    | "com.atproto.moderation.defs#reasonViolation"
    | "tools.ozone.report.defs#reasonAppeal"
    | "tools.ozone.report.defs#reasonChildSafetyCSAM"
    | "tools.ozone.report.defs#reasonChildSafetyGroom"
    | "tools.ozone.report.defs#reasonChildSafetyHarassment"
    | "tools.ozone.report.defs#reasonChildSafetyOther"
    | "tools.ozone.report.defs#reasonChildSafetyPrivacy"
    | "tools.ozone.report.defs#reasonHarassmentDoxxing"
    | "tools.ozone.report.defs#reasonHarassmentHateSpeech"
    | "tools.ozone.report.defs#reasonHarassmentOther"
    | "tools.ozone.report.defs#reasonHarassmentTargeted"
    | "tools.ozone.report.defs#reasonHarassmentTroll"
    | "tools.ozone.report.defs#reasonMisleadingBot"
    | "tools.ozone.report.defs#reasonMisleadingElections"
    | "tools.ozone.report.defs#reasonMisleadingImpersonation"
    | "tools.ozone.report.defs#reasonMisleadingOther"
    | "tools.ozone.report.defs#reasonMisleadingScam"
    | "tools.ozone.report.defs#reasonMisleadingSpam"
    | "tools.ozone.report.defs#reasonOther"
    | "tools.ozone.report.defs#reasonRuleBanEvasion"
    | "tools.ozone.report.defs#reasonRuleOther"
    | "tools.ozone.report.defs#reasonRuleProhibitedSales"
    | "tools.ozone.report.defs#reasonRuleSiteSecurity"
    | "tools.ozone.report.defs#reasonSelfHarmContent"
    | "tools.ozone.report.defs#reasonSelfHarmED"
    | "tools.ozone.report.defs#reasonSelfHarmOther"
    | "tools.ozone.report.defs#reasonSelfHarmStunts"
    | "tools.ozone.report.defs#reasonSelfHarmSubstances"
    | "tools.ozone.report.defs#reasonSexualAbuseContent"
    | "tools.ozone.report.defs#reasonSexualAnimal"
    | "tools.ozone.report.defs#reasonSexualDeepfake"
    | "tools.ozone.report.defs#reasonSexualNCII"
    | "tools.ozone.report.defs#reasonSexualOther"
    | "tools.ozone.report.defs#reasonSexualUnlabeled"
    | "tools.ozone.report.defs#reasonViolenceAnimal"
    | "tools.ozone.report.defs#reasonViolenceExtremistContent"
    | "tools.ozone.report.defs#reasonViolenceGlorification"
    | "tools.ozone.report.defs#reasonViolenceGraphicContent"
    | "tools.ozone.report.defs#reasonViolenceOther"
    | "tools.ozone.report.defs#reasonViolenceThreats"
    | "tools.ozone.report.defs#reasonViolenceTrafficking"
    | (string & {});
  type ReasonViolation = "com.atproto.moderation.defs#reasonViolation";
  /** Tag describing a type of subject that might be reported. */
  type SubjectType = "account" | "chat" | "record" | (string & {});
}

/** Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoApplyWrites {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    writes: TypeUnion<Create | Delete | Update>[];
    /** If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations. */
    swapCommit?: At.CID;
    /** Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output extends TypedBase {
    commit?: ComAtprotoRepoDefs.CommitMeta;
    results?: TypeUnion<CreateResult | DeleteResult | UpdateResult>[];
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
  /** Operation which creates a new record. */
  interface Create extends TypedBase {
    collection: string;
    value: unknown;
    /** NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility. */
    rkey?: At.RKEY;
  }
  interface CreateResult extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  /** Operation which deletes an existing record. */
  interface Delete extends TypedBase {
    collection: string;
    rkey: At.RKEY;
  }
  interface DeleteResult extends TypedBase {}
  /** Operation which updates an existing record. */
  interface Update extends TypedBase {
    collection: string;
    rkey: At.RKEY;
    value: unknown;
  }
  interface UpdateResult extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
}

/** Create a single new repository record. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoCreateRecord {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The record itself. Must contain a $type field. */
    record: unknown;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey?: At.RKEY;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    commit?: ComAtprotoRepoDefs.CommitMeta;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
}

export declare namespace ComAtprotoRepoDefs {
  interface CommitMeta extends TypedBase {
    cid: At.CID;
    rev: At.TID;
  }
}

/** Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoDeleteRecord {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey: At.RKEY;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Compare and swap with the previous record by CID. */
    swapRecord?: At.CID;
  }
  interface Output extends TypedBase {
    commit?: ComAtprotoRepoDefs.CommitMeta;
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
}

/** Get information about an account and repository, including the list of collections. Does not require auth. */
export declare namespace ComAtprotoRepoDescribeRepo {
  interface Params extends TypedBase {
    /** The handle or DID of the repo. */
    repo: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** List of all the collections (NSIDs) for which this repo contains at least one record. */
    collections: string[];
    did: At.DID;
    /** The complete DID document for this account. */
    didDoc: unknown;
    handle: At.Handle;
    /** Indicates if handle is currently valid (resolves bi-directionally) */
    handleIsCorrect: boolean;
  }
}

/** Get a single record from a repository. Does not require auth. */
export declare namespace ComAtprotoRepoGetRecord {
  interface Params extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The handle or DID of the repo. */
    repo: string;
    /** The Record Key. */
    rkey: At.RKEY;
    /** The CID of the version of the record. If not specified, then return the most recent version. */
    cid?: At.CID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    uri: At.Uri;
    value: unknown;
    cid?: At.CID;
  }
  interface Errors extends TypedBase {
    RecordNotFound: {};
  }
}

/** Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set. */
export declare namespace ComAtprotoRepoImportRepo {
  interface Params extends TypedBase {}
  type Input = Blob | ArrayBufferView;
  type Output = undefined;
}

/** Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow. */
export declare namespace ComAtprotoRepoListMissingBlobs {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    blobs: RecordBlob[];
    cursor?: string;
  }
  interface RecordBlob extends TypedBase {
    cid: At.CID;
    recordUri: At.Uri;
  }
}

/** List a range of records in a repository, matching a specific collection. Does not require auth. */
export declare namespace ComAtprotoRepoListRecords {
  interface Params extends TypedBase {
    /** The NSID of the record type. */
    collection: string;
    /** The handle or DID of the repo. */
    repo: string;
    cursor?: string;
    /**
     * The number of records to return.
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Flag to reverse the order of the returned records. */
    reverse?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    records: Record[];
    cursor?: string;
  }
  interface Record extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    value: unknown;
  }
}

/** Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoPutRecord {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The record to write. */
    record: unknown;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey: At.RKEY;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation */
    swapRecord?: At.CID | null;
    /** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    commit?: ComAtprotoRepoDefs.CommitMeta;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
}

export declare namespace ComAtprotoRepoStrongRef {
  interface Main extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
  }
}

/** Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoUploadBlob {
  interface Params extends TypedBase {}
  type Input = Blob | ArrayBufferView;
  interface Output extends TypedBase {
    blob: At.Blob;
  }
}

/** Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup. */
export declare namespace ComAtprotoServerActivateAccount {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself. */
export declare namespace ComAtprotoServerCheckAccountStatus {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    activated: boolean;
    expectedBlobs: number;
    importedBlobs: number;
    indexedRecords: number;
    privateStateValues: number;
    repoBlocks: number;
    repoCommit: At.CID;
    repoRev: string;
    validDid: boolean;
  }
}

/** Confirm an email using a token from com.atproto.server.requestEmailConfirmation. */
export declare namespace ComAtprotoServerConfirmEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    email: string;
    token: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    AccountNotFound: {};
    ExpiredToken: {};
    InvalidToken: {};
    InvalidEmail: {};
  }
}

/** Create an account. Implemented by PDS. */
export declare namespace ComAtprotoServerCreateAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Requested handle for the account. */
    handle: At.Handle;
    /** Pre-existing atproto DID, being imported to a new account. */
    did?: At.DID;
    email?: string;
    inviteCode?: string;
    /** Initial account password. May need to meet instance-specific password strength requirements. */
    password?: string;
    /** A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented. */
    plcOp?: unknown;
    /** DID PLC rotation key (aka, recovery key) to be included in PLC creation operation. */
    recoveryKey?: string;
    verificationCode?: string;
    verificationPhone?: string;
  }
  /** Account login session returned on successful account creation. */
  interface Output extends TypedBase {
    accessJwt: string;
    /** The DID of the new account. */
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    /** Complete DID document. */
    didDoc?: unknown;
  }
  interface Errors extends TypedBase {
    InvalidHandle: {};
    InvalidPassword: {};
    InvalidInviteCode: {};
    HandleNotAvailable: {};
    UnsupportedDomain: {};
    UnresolvableDid: {};
    IncompatibleDidDoc: {};
  }
}

/** Create an App Password. */
export declare namespace ComAtprotoServerCreateAppPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** A short name for the App Password, to help distinguish them. */
    name: string;
    /** If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients. */
    privileged?: boolean;
  }
  type Output = AppPassword;
  interface Errors extends TypedBase {
    AccountTakedown: {};
  }
  interface AppPassword extends TypedBase {
    createdAt: string;
    name: string;
    password: string;
    privileged?: boolean;
  }
}

/** Create an invite code. */
export declare namespace ComAtprotoServerCreateInviteCode {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    useCount: number;
    forAccount?: At.DID;
  }
  interface Output extends TypedBase {
    code: string;
  }
}

/** Create invite codes. */
export declare namespace ComAtprotoServerCreateInviteCodes {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** \@default 1 */
    codeCount: number;
    useCount: number;
    forAccounts?: At.DID[];
  }
  interface Output extends TypedBase {
    codes: AccountCodes[];
  }
  interface AccountCodes extends TypedBase {
    account: string;
    codes: string[];
  }
}

/** Create an authentication session. */
export declare namespace ComAtprotoServerCreateSession {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Handle or other identifier supported by the server for the authenticating user. */
    identifier: string;
    password: string;
    /** When true, instead of throwing error for takendown accounts, a valid response with a narrow scoped token will be returned */
    allowTakendown?: boolean;
    authFactorToken?: string;
  }
  interface Output extends TypedBase {
    accessJwt: string;
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors extends TypedBase {
    AccountTakedown: {};
    AuthFactorTokenRequired: {};
  }
}

/** Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host. */
export declare namespace ComAtprotoServerDeactivateAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** A recommendation to server as to how long they should hold onto the deactivated account before deleting. */
    deleteAfter?: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoServerDefs {
  interface InviteCode extends TypedBase {
    available: number;
    code: string;
    createdAt: string;
    createdBy: string;
    disabled: boolean;
    forAccount: string;
    uses: InviteCodeUse[];
  }
  interface InviteCodeUse extends TypedBase {
    usedAt: string;
    usedBy: At.DID;
  }
}

/** Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth. */
export declare namespace ComAtprotoServerDeleteAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    password: string;
    token: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    ExpiredToken: {};
    InvalidToken: {};
  }
}

/** Delete the current session. Requires auth using the 'refreshJwt' (not the 'accessJwt'). */
export declare namespace ComAtprotoServerDeleteSession {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
  interface Errors extends TypedBase {
    InvalidToken: {};
    ExpiredToken: {};
  }
}

/** Describes the server's account creation requirements and capabilities. Implemented by PDS. */
export declare namespace ComAtprotoServerDescribeServer {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    /** List of domain suffixes that can be used in account handles. */
    availableUserDomains: string[];
    did: At.DID;
    /** Contact information */
    contact?: Contact;
    /** If true, an invite code must be supplied to create an account on this instance. */
    inviteCodeRequired?: boolean;
    /** URLs of service policy documents. */
    links?: Links;
    /** If true, a phone verification token must be supplied to create an account on this instance. */
    phoneVerificationRequired?: boolean;
  }
  interface Contact extends TypedBase {
    email?: string;
  }
  interface Links extends TypedBase {
    privacyPolicy?: string;
    termsOfService?: string;
  }
}

/** Get all invite codes for the current account. Requires auth. */
export declare namespace ComAtprotoServerGetAccountInviteCodes {
  interface Params extends TypedBase {
    /**
     * Controls whether any new 'earned' but not 'created' invites should be created.
     * \@default true
     */
    createAvailable?: boolean;
    /** \@default true */
    includeUsed?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    codes: ComAtprotoServerDefs.InviteCode[];
  }
  interface Errors extends TypedBase {
    DuplicateCreate: {};
  }
}

/** Get a signed token on behalf of the requesting DID for the requested service. */
export declare namespace ComAtprotoServerGetServiceAuth {
  interface Params extends TypedBase {
    /** The DID of the service that the token will be used to authenticate with */
    aud: At.DID;
    /** The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope. */
    exp?: number;
    /** Lexicon (XRPC) method to bind the requested token to */
    lxm?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    token: string;
  }
  interface Errors extends TypedBase {
    BadExpiration: {};
  }
}

/** Get information about the current auth session. Requires auth. */
export declare namespace ComAtprotoServerGetSession {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
}

/** List all App Passwords. */
export declare namespace ComAtprotoServerListAppPasswords {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    passwords: AppPassword[];
  }
  interface Errors extends TypedBase {
    AccountTakedown: {};
  }
  interface AppPassword extends TypedBase {
    createdAt: string;
    name: string;
    privileged?: boolean;
  }
}

/** Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt'). */
export declare namespace ComAtprotoServerRefreshSession {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    accessJwt: string;
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** Hosting status of the account. If not specified, then assume 'active'. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors extends TypedBase {
    AccountTakedown: {};
    InvalidToken: {};
    ExpiredToken: {};
  }
}

/** Initiate a user account deletion via email. */
export declare namespace ComAtprotoServerRequestAccountDelete {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Request an email with a code to confirm ownership of email. */
export declare namespace ComAtprotoServerRequestEmailConfirmation {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Request a token in order to update email. */
export declare namespace ComAtprotoServerRequestEmailUpdate {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    tokenRequired: boolean;
  }
}

/** Initiate a user account password reset via email. */
export declare namespace ComAtprotoServerRequestPasswordReset {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    email: string;
  }
  type Output = undefined;
}

/** Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented. */
export declare namespace ComAtprotoServerReserveSigningKey {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The DID to reserve a key for. */
    did?: At.DID;
  }
  interface Output extends TypedBase {
    /** The public key for the reserved signing key, in did:key serialization. */
    signingKey: string;
  }
}

/** Reset a user account password using a token. */
export declare namespace ComAtprotoServerResetPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    password: string;
    token: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    ExpiredToken: {};
    InvalidToken: {};
  }
}

/** Revoke an App Password by name. */
export declare namespace ComAtprotoServerRevokeAppPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    name: string;
  }
  type Output = undefined;
}

/** Update an account's email. */
export declare namespace ComAtprotoServerUpdateEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    email: string;
    emailAuthFactor?: boolean;
    /** Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed. */
    token?: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    ExpiredToken: {};
    InvalidToken: {};
    TokenRequired: {};
  }
}

export declare namespace ComAtprotoSyncDefs {
  type HostStatus =
    | "active"
    | "banned"
    | "idle"
    | "offline"
    | "throttled"
    | (string & {});
}

/** Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlob {
  interface Params extends TypedBase {
    /** The CID of the blob to fetch */
    cid: At.CID;
    /** The DID of the account. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    BlobNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlocks {
  interface Params extends TypedBase {
    cids: At.CID[];
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    BlockNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/**
 * DEPRECATED - please use com.atproto.sync.getRepo instead
 * \@deprecated
 */
export declare namespace ComAtprotoSyncGetCheckout {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
}

/**
 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
 * \@deprecated
 */
export declare namespace ComAtprotoSyncGetHead {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    root: At.CID;
  }
  interface Errors extends TypedBase {
    HeadNotFound: {};
  }
}

/** Returns information about a specified upstream host, as consumed by the server. Implemented by relays. */
export declare namespace ComAtprotoSyncGetHostStatus {
  interface Params extends TypedBase {
    /** Hostname of the host (eg, PDS or relay) being queried. */
    hostname: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    hostname: string;
    /** Number of accounts on the server which are associated with the upstream host. Note that the upstream may actually have more accounts. */
    accountCount?: number;
    /** Recent repo stream event sequence number. May be delayed from actual stream processing (eg, persisted cursor not in-memory cursor). */
    seq?: number;
    status?: ComAtprotoSyncDefs.HostStatus;
  }
  interface Errors extends TypedBase {
    HostNotFound: {};
  }
}

/** Get the current commit CID & revision of the specified repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetLatestCommit {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    cid: At.CID;
    rev: At.TID;
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetRecord {
  interface Params extends TypedBase {
    collection: string;
    /** The DID of the repo. */
    did: At.DID;
    /** Record Key */
    rkey: At.RKEY;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    RecordNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetRepo {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
    /** The revision ('rev') of the repo to create a diff from. */
    since?: At.TID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncGetRepoStatus {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    active: boolean;
    did: At.DID;
    /** Optional field, the current rev of the repo, if active=true */
    rev?: At.TID;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?:
      | "deactivated"
      | "deleted"
      | "desynchronized"
      | "suspended"
      | "takendown"
      | "throttled"
      | (string & {});
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
  }
}

/** List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncListBlobs {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
    /** Optional revision of the repo to list blobs since. */
    since?: At.TID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    cids: At.CID[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Enumerates upstream hosts (eg, PDS or relay instances) that this service consumes from. Implemented by relays. */
export declare namespace ComAtprotoSyncListHosts {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 200
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** Sort order is not formally specified. Recommended order is by time host was first seen by the server, with oldest first. */
    hosts: Host[];
    cursor?: string;
  }
  interface Host extends TypedBase {
    /** hostname of server; not a URL (no scheme) */
    hostname: string;
    accountCount?: number;
    /** Recent repo stream event sequence number. May be delayed from actual stream processing (eg, persisted cursor not in-memory cursor). */
    seq?: number;
    status?: ComAtprotoSyncDefs.HostStatus;
  }
}

/** Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncListRepos {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: Repo[];
    cursor?: string;
  }
  interface Repo extends TypedBase {
    did: At.DID;
    /** Current repo commit CID */
    head: At.CID;
    rev: At.TID;
    active?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?:
      | "deactivated"
      | "deleted"
      | "desynchronized"
      | "suspended"
      | "takendown"
      | "throttled"
      | (string & {});
  }
}

/** Enumerates all the DIDs which have records with the given collection NSID. */
export declare namespace ComAtprotoSyncListReposByCollection {
  interface Params extends TypedBase {
    collection: string;
    cursor?: string;
    /**
     * Maximum size of response set. Recommend setting a large maximum (1000+) when enumerating large DID lists.
     * Minimum: 1
     * Maximum: 2000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: Repo[];
    cursor?: string;
  }
  interface Repo extends TypedBase {
    did: At.DID;
  }
}

/** Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay. DEPRECATED: just use com.atproto.sync.requestCrawl */
export declare namespace ComAtprotoSyncNotifyOfUpdate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Hostname of the current service (usually a PDS) that is notifying of update. */
    hostname: string;
  }
  type Output = undefined;
}

/** Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth. */
export declare namespace ComAtprotoSyncRequestCrawl {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Hostname of the current service (eg, PDS) that is requesting to be crawled. */
    hostname: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    HostBanned: {};
  }
}

export declare namespace ComAtprotoSyncSubscribeRepos {
  interface Params extends TypedBase {
    /** The last known event seq number to backfill from. */
    cursor?: number;
  }
  type Message = TypeUnion<Account | Commit | Identity | Info | Sync>;
  interface Errors extends TypedBase {
    FutureCursor: {};
    ConsumerTooSlow: {};
  }
  /** Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active. */
  interface Account extends TypedBase {
    /** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
    active: boolean;
    did: At.DID;
    seq: number;
    time: string;
    /** If active=false, this optional field indicates a reason for why the account is not active. */
    status?:
      | "deactivated"
      | "deleted"
      | "desynchronized"
      | "suspended"
      | "takendown"
      | "throttled"
      | (string & {});
  }
  /** Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature. */
  interface Commit extends TypedBase {
    /**
     * DEPRECATED -- will soon always be empty. List of new blobs (by CID) referenced by records in this commit.
     * \@deprecated
     */
    blobs: At.CIDLink[];
    /** CAR file containing relevant blocks, as a diff since the previous repo state. The commit must be included as a block, and the commit block CID must be the first entry in the CAR header 'roots' list. */
    blocks: At.Bytes;
    /** Repo commit object CID. */
    commit: At.CIDLink;
    /**
     * Maximum array length: 200
     * List of repo mutation operations in this commit (eg, records created, updated, or deleted).
     */
    ops: RepoOp[];
    /**
     * DEPRECATED -- unused
     * \@deprecated
     */
    rebase: boolean;
    /** The repo this event comes from. Note that all other message types name this field 'did'. */
    repo: At.DID;
    /** The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event. */
    rev: At.TID;
    /** The stream sequence number of this message. */
    seq: number;
    /** The rev of the last emitted commit from this repo (if any). */
    since: At.TID | null;
    /** Timestamp of when this message was originally broadcast. */
    time: string;
    /**
     * DEPRECATED -- replaced by #sync event and data limits. Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data.
     * \@deprecated
     */
    tooBig: boolean;
    /** The root CID of the MST tree for the previous commit from this repo (indicated by the 'since' revision field in this message). Corresponds to the 'data' field in the repo commit object. NOTE: this field is effectively required for the 'inductive' version of firehose. */
    prevData?: At.CIDLink;
  }
  /** Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache. */
  interface Identity extends TypedBase {
    did: At.DID;
    seq: number;
    time: string;
    /** The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details. */
    handle?: At.Handle;
  }
  interface Info extends TypedBase {
    name: "OutdatedCursor" | (string & {});
    message?: string;
  }
  /** A repo operation, ie a mutation of a single record. */
  interface RepoOp extends TypedBase {
    action: "create" | "delete" | "update" | (string & {});
    /** For creates and updates, the new record CID. For deletions, null. */
    cid: At.CIDLink | null;
    path: string;
    /** For updates and deletes, the previous record CID (required for inductive firehose). For creations, field should not be defined. */
    prev?: At.CIDLink;
  }
  /** Updates the repo to a new state, without necessarily including that state on the firehose. Used to recover from broken commit streams, data loss incidents, or in situations where upstream host does not know recent state of the repository. */
  interface Sync extends TypedBase {
    /** CAR file containing the commit, as a block. The CAR header must include the commit block CID as the first 'root'. */
    blocks: At.Bytes;
    /** The account this repo event corresponds to. Must match that in the commit object. */
    did: At.DID;
    /** The rev of the commit. This value must match that in the commit object. */
    rev: string;
    /** The stream sequence number of this message. */
    seq: number;
    /** Timestamp of when this message was originally broadcast. */
    time: string;
  }
}

/** Add a handle to the set of reserved handles. */
export declare namespace ComAtprotoTempAddReservedHandle {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    handle: string;
  }
  interface Output extends TypedBase {}
}

/** Checks whether the provided handle is available. If the handle is not available, available suggestions will be returned. Optional inputs will be used to generate suggestions. */
export declare namespace ComAtprotoTempCheckHandleAvailability {
  interface Params extends TypedBase {
    /** Tentative handle. Will be checked for availability or used to build handle suggestions. */
    handle: At.Handle;
    /** User-provided birth date. Might be used to build handle suggestions. */
    birthDate?: string;
    /** User-provided email. Might be used to build handle suggestions. */
    email?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** Echo of the input handle. */
    handle: At.Handle;
    result: TypeUnion<ResultAvailable | ResultUnavailable>;
  }
  interface Errors extends TypedBase {
    InvalidEmail: {};
  }
  /** Indicates the provided handle is available. */
  interface ResultAvailable extends TypedBase {}
  /** Indicates the provided handle is unavailable and gives suggestions of available handles. */
  interface ResultUnavailable extends TypedBase {
    /** List of suggested handles based on the provided inputs. */
    suggestions: Suggestion[];
  }
  interface Suggestion extends TypedBase {
    handle: At.Handle;
    /** Method used to build this suggestion. Should be considered opaque to clients. Can be used for metrics. */
    method: string;
  }
}

/** Check accounts location in signup queue. */
export declare namespace ComAtprotoTempCheckSignupQueue {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    activated: boolean;
    estimatedTimeMs?: number;
    placeInQueue?: number;
  }
}

/** Allows finding the oauth permission scope from a reference */
export declare namespace ComAtprotoTempDereferenceScope {
  interface Params extends TypedBase {
    /** The scope reference (starts with 'ref:') */
    scope: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** The full oauth permission scope */
    scope: string;
  }
  interface Errors extends TypedBase {
    InvalidScopeReference: {};
  }
}

/**
 * DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.
 * \@deprecated
 */
export declare namespace ComAtprotoTempFetchLabels {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 250
     * \@default 50
     */
    limit?: number;
    since?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    labels: ComAtprotoLabelDefs.Label[];
  }
}

/** Request a verification code to be sent to the supplied phone number */
export declare namespace ComAtprotoTempRequestPhoneVerification {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    phoneNumber: string;
  }
  type Output = undefined;
}

/** Revoke sessions, password, and app passwords associated with account. May be resolved by a password reset. */
export declare namespace ComAtprotoTempRevokeAccountCredentials {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    account: string;
  }
  type Output = undefined;
}

/** Administrative action to create a new, re-usable communication (email for now) template. */
export declare namespace ToolsOzoneCommunicationCreateTemplate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Content of the template, markdown supported, can contain variable placeholders. */
    contentMarkdown: string;
    /** Name of the template. */
    name: string;
    /** Subject of the message, used in emails. */
    subject: string;
    /** DID of the user who is creating the template. */
    createdBy?: At.DID;
    /** Message language. */
    lang?: string;
  }
  type Output = ToolsOzoneCommunicationDefs.TemplateView;
  interface Errors extends TypedBase {
    DuplicateTemplateName: {};
  }
}

export declare namespace ToolsOzoneCommunicationDefs {
  interface TemplateView extends TypedBase {
    /** Subject of the message, used in emails. */
    contentMarkdown: string;
    createdAt: string;
    disabled: boolean;
    id: string;
    /** DID of the user who last updated the template. */
    lastUpdatedBy: At.DID;
    /** Name of the template. */
    name: string;
    updatedAt: string;
    /** Message language. */
    lang?: string;
    /** Content of the template, can contain markdown and variable placeholders. */
    subject?: string;
  }
}

/** Delete a communication template. */
export declare namespace ToolsOzoneCommunicationDeleteTemplate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    id: string;
  }
  type Output = undefined;
}

/** Get list of all communication templates. */
export declare namespace ToolsOzoneCommunicationListTemplates {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    communicationTemplates: ToolsOzoneCommunicationDefs.TemplateView[];
  }
}

/** Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only. */
export declare namespace ToolsOzoneCommunicationUpdateTemplate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** ID of the template to be updated. */
    id: string;
    /** Content of the template, markdown supported, can contain variable placeholders. */
    contentMarkdown?: string;
    disabled?: boolean;
    /** Message language. */
    lang?: string;
    /** Name of the template. */
    name?: string;
    /** Subject of the message, used in emails. */
    subject?: string;
    /** DID of the user who is updating the template. */
    updatedBy?: At.DID;
  }
  type Output = ToolsOzoneCommunicationDefs.TemplateView;
  interface Errors extends TypedBase {
    DuplicateTemplateName: {};
  }
}

/** Get account history, e.g. log of updated email addresses or other identity information. */
export declare namespace ToolsOzoneHostingGetAccountHistory {
  interface Params extends TypedBase {
    did: At.DID;
    cursor?: string;
    events?: (
      | "accountCreated"
      | "emailConfirmed"
      | "emailUpdated"
      | "handleUpdated"
      | "passwordUpdated"
      | (string & {})
    )[];
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    events: Event[];
    cursor?: string;
  }
  interface AccountCreated extends TypedBase {
    email?: string;
    handle?: At.Handle;
  }
  interface EmailConfirmed extends TypedBase {
    email: string;
  }
  interface EmailUpdated extends TypedBase {
    email: string;
  }
  interface Event extends TypedBase {
    createdAt: string;
    createdBy: string;
    details: TypeUnion<
      | AccountCreated
      | EmailConfirmed
      | EmailUpdated
      | HandleUpdated
      | PasswordUpdated
    >;
  }
  interface HandleUpdated extends TypedBase {
    handle: At.Handle;
  }
  interface PasswordUpdated extends TypedBase {}
}

/** Cancel all pending scheduled moderation actions for specified subjects */
export declare namespace ToolsOzoneModerationCancelScheduledActions {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * Array of DID subjects to cancel scheduled actions for
     * Maximum array length: 100
     */
    subjects: At.DID[];
    /** Optional comment describing the reason for cancellation */
    comment?: string;
  }
  type Output = CancellationResults;
  interface CancellationResults extends TypedBase {
    /** DIDs for which cancellation failed with error details */
    failed: FailedCancellation[];
    /** DIDs for which all pending scheduled actions were successfully cancelled */
    succeeded: At.DID[];
  }
  interface FailedCancellation extends TypedBase {
    did: At.DID;
    error: string;
    errorCode?: string;
  }
}

export declare namespace ToolsOzoneModerationDefs {
  /** Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface AccountEvent extends TypedBase {
    /** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
    active: boolean;
    timestamp: string;
    comment?: string;
    status?:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | "tombstoned"
      | "unknown"
      | (string & {});
  }
  interface AccountHosting extends TypedBase {
    status:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | "unknown"
      | (string & {});
    createdAt?: string;
    deactivatedAt?: string;
    deletedAt?: string;
    reactivatedAt?: string;
    updatedAt?: string;
  }
  /** Statistics about a particular account subject */
  interface AccountStats extends TypedBase {
    /** Total number of appeals against a moderation action on the account */
    appealCount?: number;
    /** Number of times the account was escalated */
    escalateCount?: number;
    /** Total number of reports on the account */
    reportCount?: number;
    /** Number of times the account was suspended */
    suspendCount?: number;
    /** Number of times the account was taken down */
    takedownCount?: number;
  }
  /** Strike information for an account */
  interface AccountStrike extends TypedBase {
    /** Current number of active strikes (excluding expired strikes) */
    activeStrikeCount?: number;
    /** Timestamp of the first strike received */
    firstStrikeAt?: string;
    /** Timestamp of the most recent strike received */
    lastStrikeAt?: string;
    /** Total number of strikes ever received (including expired strikes) */
    totalStrikeCount?: number;
  }
  /** Age assurance info coming directly from users. Only works on DID subjects. */
  interface AgeAssuranceEvent extends TypedBase {
    /** The unique identifier for this instance of the age assurance flow, in UUID format. */
    attemptId: string;
    /** The date and time of this write operation. */
    createdAt: string;
    /** The status of the Age Assurance process. */
    status: "assured" | "pending" | "unknown" | (string & {});
    access?: AppBskyAgeassuranceDefs.Access;
    /** The IP address used when completing the AA flow. */
    completeIp?: string;
    /** The user agent used when completing the AA flow. */
    completeUa?: string;
    /** The ISO 3166-1 alpha-2 country code provided when beginning the Age Assurance flow. */
    countryCode?: string;
    /** The IP address used when initiating the AA flow. */
    initIp?: string;
    /** The user agent used when initiating the AA flow. */
    initUa?: string;
    /** The ISO 3166-2 region code provided when beginning the Age Assurance flow. */
    regionCode?: string;
  }
  /** Age assurance status override by moderators. Only works on DID subjects. */
  interface AgeAssuranceOverrideEvent extends TypedBase {
    /**
     * Comment describing the reason for the override.
     * Minimum string length: 1
     */
    comment: string;
    /** The status to be set for the user decided by a moderator, overriding whatever value the user had previously. Use reset to default to original state. */
    status: "assured" | "blocked" | "reset" | (string & {});
    access?: AppBskyAgeassuranceDefs.Access;
  }
  interface BlobView extends TypedBase {
    cid: At.CID;
    createdAt: string;
    mimeType: string;
    size: number;
    details?: TypeUnion<ImageDetails | VideoDetails>;
    moderation?: Moderation;
  }
  /** Logs cancellation of a scheduled takedown action for an account. */
  interface CancelScheduledTakedownEvent extends TypedBase {
    comment?: string;
  }
  /** Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface IdentityEvent extends TypedBase {
    timestamp: string;
    comment?: string;
    handle?: At.Handle;
    pdsHost?: string;
    tombstone?: boolean;
  }
  interface ImageDetails extends TypedBase {
    height: number;
    width: number;
  }
  interface Moderation extends TypedBase {
    subjectStatus?: SubjectStatusView;
  }
  interface ModerationDetail extends TypedBase {
    subjectStatus?: SubjectStatusView;
  }
  interface ModEventAcknowledge extends TypedBase {
    /** If true, all other reports on content authored by this account will be resolved (acknowledged). */
    acknowledgeAccountSubjects?: boolean;
    comment?: string;
  }
  /** Add a comment to a subject. An empty comment will clear any previously set sticky comment. */
  interface ModEventComment extends TypedBase {
    comment?: string;
    /** Make the comment persistent on the subject */
    sticky?: boolean;
  }
  /** Divert a record's blobs to a 3rd party service for further scanning/tagging */
  interface ModEventDivert extends TypedBase {
    comment?: string;
  }
  /** Keep a log of outgoing email to a user */
  interface ModEventEmail extends TypedBase {
    /** The subject line of the email sent to the user. */
    subjectLine: string;
    /** Additional comment about the outgoing comm. */
    comment?: string;
    /** The content of the email sent to the user. */
    content?: string;
    /** Indicates whether the email was successfully delivered to the user's inbox. */
    isDelivered?: boolean;
    /**
     * Names/Keywords of the policies that necessitated the email.
     * Maximum array length: 5
     */
    policies?: string[];
    /** Severity level of the violation. Normally 'sev-1' that adds strike on repeat offense */
    severityLevel?: string;
    /** Number of strikes to assign to the user for this violation. Normally 0 as an indicator of a warning and only added as a strike on a repeat offense. */
    strikeCount?: number;
    /** When the strike should expire. If not provided, the strike never expires. */
    strikeExpiresAt?: string;
  }
  interface ModEventEscalate extends TypedBase {
    comment?: string;
  }
  /** Apply/Negate labels on a subject */
  interface ModEventLabel extends TypedBase {
    createLabelVals: string[];
    negateLabelVals: string[];
    comment?: string;
    /** Indicates how long the label will remain on the subject. Only applies on labels that are being added. */
    durationInHours?: number;
  }
  /** Mute incoming reports on a subject */
  interface ModEventMute extends TypedBase {
    /** Indicates how long the subject should remain muted. */
    durationInHours: number;
    comment?: string;
  }
  /** Mute incoming reports from an account */
  interface ModEventMuteReporter extends TypedBase {
    comment?: string;
    /** Indicates how long the account should remain muted. Falsy value here means a permanent mute. */
    durationInHours?: number;
  }
  /** Set priority score of the subject. Higher score means higher priority. */
  interface ModEventPriorityScore extends TypedBase {
    /**
     * Minimum: 0
     * Maximum: 100
     */
    score: number;
    comment?: string;
  }
  /** Report a subject */
  interface ModEventReport extends TypedBase {
    reportType: ComAtprotoModerationDefs.ReasonType;
    comment?: string;
    /** Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject. */
    isReporterMuted?: boolean;
  }
  /** Resolve appeal on a subject */
  interface ModEventResolveAppeal extends TypedBase {
    /** Describe resolution. */
    comment?: string;
  }
  /** Revert take down action on a subject */
  interface ModEventReverseTakedown extends TypedBase {
    /** Describe reasoning behind the reversal. */
    comment?: string;
    /**
     * Names/Keywords of the policy infraction for which takedown is being reversed.
     * Maximum array length: 5
     */
    policies?: string[];
    /** Severity level of the violation. Usually set from the last policy infraction's severity. */
    severityLevel?: string;
    /** Number of strikes to subtract from the user's strike count. Usually set from the last policy infraction's severity. */
    strikeCount?: number;
  }
  /** Add/Remove a tag on a subject */
  interface ModEventTag extends TypedBase {
    /** Tags to be added to the subject. If already exists, won't be duplicated. */
    add: string[];
    /** Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated. */
    remove: string[];
    /** Additional comment about added/removed tags. */
    comment?: string;
  }
  /** Take down a subject permanently or temporarily */
  interface ModEventTakedown extends TypedBase {
    /** If true, all other reports on content authored by this account will be resolved (acknowledged). */
    acknowledgeAccountSubjects?: boolean;
    comment?: string;
    /** Indicates how long the takedown should be in effect before automatically expiring. */
    durationInHours?: number;
    /**
     * Names/Keywords of the policies that drove the decision.
     * Maximum array length: 5
     */
    policies?: string[];
    /** Severity level of the violation (e.g., 'sev-0', 'sev-1', 'sev-2', etc.). */
    severityLevel?: string;
    /** Number of strikes to assign to the user for this violation. */
    strikeCount?: number;
    /** When the strike should expire. If not provided, the strike never expires. */
    strikeExpiresAt?: string;
    /** List of services where the takedown should be applied. If empty or not provided, takedown is applied on all configured services. */
    targetServices?: ("appview" | "pds" | (string & {}))[];
  }
  /** Unmute action on a subject */
  interface ModEventUnmute extends TypedBase {
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  /** Unmute incoming reports from an account */
  interface ModEventUnmuteReporter extends TypedBase {
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  interface ModEventView extends TypedBase {
    createdAt: string;
    createdBy: At.DID;
    event: TypeUnion<
      | AccountEvent
      | AgeAssuranceEvent
      | AgeAssuranceOverrideEvent
      | CancelScheduledTakedownEvent
      | IdentityEvent
      | ModEventAcknowledge
      | ModEventComment
      | ModEventDivert
      | ModEventEmail
      | ModEventEscalate
      | ModEventLabel
      | ModEventMute
      | ModEventMuteReporter
      | ModEventPriorityScore
      | ModEventReport
      | ModEventResolveAppeal
      | ModEventReverseTakedown
      | ModEventTag
      | ModEventTakedown
      | ModEventUnmute
      | ModEventUnmuteReporter
      | RecordEvent
      | RevokeAccountCredentialsEvent
      | ScheduleTakedownEvent
    >;
    id: number;
    subject: TypeUnion<
      | ChatBskyConvoDefs.MessageRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    subjectBlobCids: string[];
    creatorHandle?: string;
    modTool?: ModTool;
    subjectHandle?: string;
  }
  interface ModEventViewDetail extends TypedBase {
    createdAt: string;
    createdBy: At.DID;
    event: TypeUnion<
      | AccountEvent
      | AgeAssuranceEvent
      | AgeAssuranceOverrideEvent
      | CancelScheduledTakedownEvent
      | IdentityEvent
      | ModEventAcknowledge
      | ModEventComment
      | ModEventDivert
      | ModEventEmail
      | ModEventEscalate
      | ModEventLabel
      | ModEventMute
      | ModEventMuteReporter
      | ModEventPriorityScore
      | ModEventReport
      | ModEventResolveAppeal
      | ModEventReverseTakedown
      | ModEventTag
      | ModEventTakedown
      | ModEventUnmute
      | ModEventUnmuteReporter
      | RecordEvent
      | RevokeAccountCredentialsEvent
      | ScheduleTakedownEvent
    >;
    id: number;
    subject: TypeUnion<
      RecordView | RecordViewNotFound | RepoView | RepoViewNotFound
    >;
    subjectBlobs: BlobView[];
    modTool?: ModTool;
  }
  /** Moderation tool information for tracing the source of the action */
  interface ModTool extends TypedBase {
    /** Name/identifier of the source (e.g., 'automod', 'ozone/workspace') */
    name: string;
    /** Additional arbitrary metadata about the source */
    meta?: unknown;
  }
  /** Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface RecordEvent extends TypedBase {
    op: "create" | "delete" | "update" | (string & {});
    timestamp: string;
    cid?: At.CID;
    comment?: string;
  }
  interface RecordHosting extends TypedBase {
    status: "deleted" | "unknown" | (string & {});
    createdAt?: string;
    deletedAt?: string;
    updatedAt?: string;
  }
  /** Statistics about a set of record subject items */
  interface RecordsStats extends TypedBase {
    /** Number of items that were appealed at least once */
    appealedCount?: number;
    /** Number of items that were escalated at least once */
    escalatedCount?: number;
    /** Number of item currently in "reviewOpen" or "reviewEscalated" state */
    pendingCount?: number;
    /** Number of item currently in "reviewNone" or "reviewClosed" state */
    processedCount?: number;
    /** Number of items that were reported at least once */
    reportedCount?: number;
    /** Total number of item in the set */
    subjectCount?: number;
    /** Number of item currently taken down */
    takendownCount?: number;
    /** Cumulative sum of the number of reports on the items in the set */
    totalReports?: number;
  }
  interface RecordView extends TypedBase {
    blobCids: At.CID[];
    cid: At.CID;
    indexedAt: string;
    moderation: Moderation;
    repo: RepoView;
    uri: At.Uri;
    value: unknown;
  }
  interface RecordViewDetail extends TypedBase {
    blobs: BlobView[];
    cid: At.CID;
    indexedAt: string;
    moderation: ModerationDetail;
    repo: RepoView;
    uri: At.Uri;
    value: unknown;
    labels?: ComAtprotoLabelDefs.Label[];
  }
  interface RecordViewNotFound extends TypedBase {
    uri: At.Uri;
  }
  interface ReporterStats extends TypedBase {
    /** The total number of reports made by the user on accounts. */
    accountReportCount: number;
    did: At.DID;
    /** The total number of accounts labeled as a result of the user's reports. */
    labeledAccountCount: number;
    /** The total number of records labeled as a result of the user's reports. */
    labeledRecordCount: number;
    /** The total number of reports made by the user on records. */
    recordReportCount: number;
    /** The total number of accounts reported by the user. */
    reportedAccountCount: number;
    /** The total number of records reported by the user. */
    reportedRecordCount: number;
    /** The total number of accounts taken down as a result of the user's reports. */
    takendownAccountCount: number;
    /** The total number of records taken down as a result of the user's reports. */
    takendownRecordCount: number;
  }
  interface RepoView extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    moderation: Moderation;
    relatedRecords: unknown[];
    deactivatedAt?: string;
    email?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invitesDisabled?: boolean;
    threatSignatures?: ComAtprotoAdminDefs.ThreatSignature[];
  }
  interface RepoViewDetail extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    moderation: ModerationDetail;
    relatedRecords: unknown[];
    deactivatedAt?: string;
    email?: string;
    emailConfirmedAt?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invites?: ComAtprotoServerDefs.InviteCode[];
    invitesDisabled?: boolean;
    labels?: ComAtprotoLabelDefs.Label[];
    threatSignatures?: ComAtprotoAdminDefs.ThreatSignature[];
  }
  interface RepoViewNotFound extends TypedBase {
    did: At.DID;
  }
  type ReviewClosed = "tools.ozone.moderation.defs#reviewClosed";
  type ReviewEscalated = "tools.ozone.moderation.defs#reviewEscalated";
  type ReviewNone = "tools.ozone.moderation.defs#reviewNone";
  type ReviewOpen = "tools.ozone.moderation.defs#reviewOpen";
  /** Account credentials revocation by moderators. Only works on DID subjects. */
  interface RevokeAccountCredentialsEvent extends TypedBase {
    /**
     * Comment describing the reason for the revocation.
     * Minimum string length: 1
     */
    comment: string;
  }
  /** View of a scheduled moderation action */
  interface ScheduledActionView extends TypedBase {
    /** Type of action to be executed */
    action: "takedown" | (string & {});
    /** When the scheduled action was created */
    createdAt: string;
    /** DID of the user who created this scheduled action */
    createdBy: At.DID;
    /** Subject DID for the action */
    did: At.DID;
    /** Auto-incrementing row ID */
    id: number;
    /** Current status of the scheduled action */
    status: "cancelled" | "executed" | "failed" | "pending" | (string & {});
    /** Serialized event object that will be propagated to the event when performed */
    eventData?: unknown;
    /** Earliest time to execute the action (for randomized scheduling) */
    executeAfter?: string;
    /** Exact time to execute the action */
    executeAt?: string;
    /** Latest time to execute the action (for randomized scheduling) */
    executeUntil?: string;
    /** ID of the moderation event created when action was successfully executed */
    executionEventId?: number;
    /** When the action was last attempted to be executed */
    lastExecutedAt?: string;
    /** Reason for the last execution failure */
    lastFailureReason?: string;
    /** Whether execution time should be randomized within the specified range */
    randomizeExecution?: boolean;
    /** When the scheduled action was last updated */
    updatedAt?: string;
  }
  /** Logs a scheduled takedown action for an account. */
  interface ScheduleTakedownEvent extends TypedBase {
    comment?: string;
    executeAfter?: string;
    executeAt?: string;
    executeUntil?: string;
  }
  type SubjectReviewState =
    | "tools.ozone.moderation.defs#reviewClosed"
    | "tools.ozone.moderation.defs#reviewEscalated"
    | "tools.ozone.moderation.defs#reviewNone"
    | "tools.ozone.moderation.defs#reviewOpen"
    | (string & {});
  interface SubjectStatusView extends TypedBase {
    /** Timestamp referencing the first moderation status impacting event was emitted on the subject */
    createdAt: string;
    id: number;
    reviewState: SubjectReviewState;
    subject: TypeUnion<
      | ChatBskyConvoDefs.MessageRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    /** Timestamp referencing when the last update was made to the moderation status of the subject */
    updatedAt: string;
    /** Statistics related to the account subject */
    accountStats?: AccountStats;
    /** Strike information for the account (account-level only) */
    accountStrike?: AccountStrike;
    /** Current age assurance state of the subject. */
    ageAssuranceState?:
      | "assured"
      | "blocked"
      | "pending"
      | "reset"
      | "unknown"
      | (string & {});
    /** Whether or not the last successful update to age assurance was made by the user or admin. */
    ageAssuranceUpdatedBy?: "admin" | "user" | (string & {});
    /** True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators. */
    appealed?: boolean;
    /** Sticky comment on the subject. */
    comment?: string;
    hosting?: TypeUnion<AccountHosting | RecordHosting>;
    /** Timestamp referencing when the author of the subject appealed a moderation action */
    lastAppealedAt?: string;
    lastReportedAt?: string;
    lastReviewedAt?: string;
    lastReviewedBy?: At.DID;
    muteReportingUntil?: string;
    muteUntil?: string;
    /**
     * Numeric value representing the level of priority. Higher score means higher priority.
     * Minimum: 0
     * Maximum: 100
     */
    priorityScore?: number;
    /** Statistics related to the record subjects authored by the subject's account */
    recordsStats?: RecordsStats;
    subjectBlobCids?: At.CID[];
    subjectRepoHandle?: string;
    suspendUntil?: string;
    tags?: string[];
    takendown?: boolean;
  }
  /** Detailed view of a subject. For record subjects, the author's repo and profile will be returned. */
  interface SubjectView extends TypedBase {
    subject: string;
    type: ComAtprotoModerationDefs.SubjectType;
    profile?: never;
    record?: RecordViewDetail;
    repo?: RepoViewDetail;
    status?: SubjectStatusView;
  }
  type TimelineEventPlcCreate =
    "tools.ozone.moderation.defs#timelineEventPlcCreate";
  type TimelineEventPlcOperation =
    "tools.ozone.moderation.defs#timelineEventPlcOperation";
  type TimelineEventPlcTombstone =
    "tools.ozone.moderation.defs#timelineEventPlcTombstone";
  interface VideoDetails extends TypedBase {
    height: number;
    length: number;
    width: number;
  }
}

/** Take a moderation action on an actor. */
export declare namespace ToolsOzoneModerationEmitEvent {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    createdBy: At.DID;
    event: TypeUnion<
      | ToolsOzoneModerationDefs.AccountEvent
      | ToolsOzoneModerationDefs.AgeAssuranceEvent
      | ToolsOzoneModerationDefs.AgeAssuranceOverrideEvent
      | ToolsOzoneModerationDefs.CancelScheduledTakedownEvent
      | ToolsOzoneModerationDefs.IdentityEvent
      | ToolsOzoneModerationDefs.ModEventAcknowledge
      | ToolsOzoneModerationDefs.ModEventComment
      | ToolsOzoneModerationDefs.ModEventDivert
      | ToolsOzoneModerationDefs.ModEventEmail
      | ToolsOzoneModerationDefs.ModEventEscalate
      | ToolsOzoneModerationDefs.ModEventLabel
      | ToolsOzoneModerationDefs.ModEventMute
      | ToolsOzoneModerationDefs.ModEventMuteReporter
      | ToolsOzoneModerationDefs.ModEventPriorityScore
      | ToolsOzoneModerationDefs.ModEventReport
      | ToolsOzoneModerationDefs.ModEventResolveAppeal
      | ToolsOzoneModerationDefs.ModEventReverseTakedown
      | ToolsOzoneModerationDefs.ModEventTag
      | ToolsOzoneModerationDefs.ModEventTakedown
      | ToolsOzoneModerationDefs.ModEventUnmute
      | ToolsOzoneModerationDefs.ModEventUnmuteReporter
      | ToolsOzoneModerationDefs.RecordEvent
      | ToolsOzoneModerationDefs.RevokeAccountCredentialsEvent
      | ToolsOzoneModerationDefs.ScheduleTakedownEvent
    >;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /** An optional external ID for the event, used to deduplicate events from external systems. Fails when an event of same type with the same external ID exists for the same subject. */
    externalId?: string;
    modTool?: ToolsOzoneModerationDefs.ModTool;
    subjectBlobCids?: At.CID[];
  }
  type Output = ToolsOzoneModerationDefs.ModEventView;
  interface Errors extends TypedBase {
    SubjectHasAction: {};
    DuplicateExternalId: {};
  }
}

/** Get timeline of all available events of an account. This includes moderation events, account history and did history. */
export declare namespace ToolsOzoneModerationGetAccountTimeline {
  interface Params extends TypedBase {
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    timeline: TimelineItem[];
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
  }
  interface TimelineItem extends TypedBase {
    day: string;
    summary: TimelineItemSummary[];
  }
  interface TimelineItemSummary extends TypedBase {
    count: number;
    eventSubjectType: "account" | "chat" | "record" | (string & {});
    eventType:
      | "tools.ozone.hosting.getAccountHistory#accountCreated"
      | "tools.ozone.hosting.getAccountHistory#emailConfirmed"
      | "tools.ozone.hosting.getAccountHistory#handleUpdated"
      | "tools.ozone.hosting.getAccountHistory#passwordUpdated"
      | "tools.ozone.moderation.defs#accountEvent"
      | "tools.ozone.moderation.defs#ageAssuranceEvent"
      | "tools.ozone.moderation.defs#ageAssuranceOverrideEvent"
      | "tools.ozone.moderation.defs#cancelScheduledTakedownEvent"
      | "tools.ozone.moderation.defs#identityEvent"
      | "tools.ozone.moderation.defs#modEventAcknowledge"
      | "tools.ozone.moderation.defs#modEventComment"
      | "tools.ozone.moderation.defs#modEventDivert"
      | "tools.ozone.moderation.defs#modEventEmail"
      | "tools.ozone.moderation.defs#modEventEscalate"
      | "tools.ozone.moderation.defs#modEventLabel"
      | "tools.ozone.moderation.defs#modEventMute"
      | "tools.ozone.moderation.defs#modEventMuteReporter"
      | "tools.ozone.moderation.defs#modEventPriorityScore"
      | "tools.ozone.moderation.defs#modEventReport"
      | "tools.ozone.moderation.defs#modEventResolveAppeal"
      | "tools.ozone.moderation.defs#modEventReverseTakedown"
      | "tools.ozone.moderation.defs#modEventTag"
      | "tools.ozone.moderation.defs#modEventTakedown"
      | "tools.ozone.moderation.defs#modEventUnmute"
      | "tools.ozone.moderation.defs#modEventUnmuteReporter"
      | "tools.ozone.moderation.defs#recordEvent"
      | "tools.ozone.moderation.defs#revokeAccountCredentialsEvent"
      | "tools.ozone.moderation.defs#scheduleTakedownEvent"
      | "tools.ozone.moderation.defs#timelineEventPlcCreate"
      | "tools.ozone.moderation.defs#timelineEventPlcOperation"
      | "tools.ozone.moderation.defs#timelineEventPlcTombstone"
      | (string & {});
  }
}

/** Get details about a moderation event. */
export declare namespace ToolsOzoneModerationGetEvent {
  interface Params extends TypedBase {
    id: number;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.ModEventViewDetail;
}

/** Get details about a record. */
export declare namespace ToolsOzoneModerationGetRecord {
  interface Params extends TypedBase {
    uri: At.Uri;
    cid?: At.CID;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.RecordViewDetail;
  interface Errors extends TypedBase {
    RecordNotFound: {};
  }
}

/** Get details about some records. */
export declare namespace ToolsOzoneModerationGetRecords {
  interface Params extends TypedBase {
    /** Maximum array length: 100 */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    records: TypeUnion<
      | ToolsOzoneModerationDefs.RecordViewDetail
      | ToolsOzoneModerationDefs.RecordViewNotFound
    >[];
  }
}

/** Get details about a repository. */
export declare namespace ToolsOzoneModerationGetRepo {
  interface Params extends TypedBase {
    did: At.DID;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.RepoViewDetail;
  interface Errors extends TypedBase {
    RepoNotFound: {};
  }
}

/** Get reporter stats for a list of users. */
export declare namespace ToolsOzoneModerationGetReporterStats {
  interface Params extends TypedBase {
    /** Maximum array length: 100 */
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    stats: ToolsOzoneModerationDefs.ReporterStats[];
  }
}

/** Get details about some repositories. */
export declare namespace ToolsOzoneModerationGetRepos {
  interface Params extends TypedBase {
    /** Maximum array length: 100 */
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: TypeUnion<
      | ToolsOzoneModerationDefs.RepoViewDetail
      | ToolsOzoneModerationDefs.RepoViewNotFound
    >[];
  }
}

/** Get details about subjects. */
export declare namespace ToolsOzoneModerationGetSubjects {
  interface Params extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 100
     */
    subjects: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    subjects: ToolsOzoneModerationDefs.SubjectView[];
  }
}

/** List scheduled moderation actions with optional filtering */
export declare namespace ToolsOzoneModerationListScheduledActions {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * Filter actions by status
     * Minimum array length: 1
     */
    statuses: (
      | "cancelled"
      | "executed"
      | "failed"
      | "pending"
      | (string & {})
    )[];
    /** Cursor for pagination */
    cursor?: string;
    /** Filter actions scheduled to execute before this time */
    endsBefore?: string;
    /**
     * Maximum number of results to return
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Filter actions scheduled to execute after this time */
    startsAfter?: string;
    /**
     * Filter actions for specific DID subjects
     * Maximum array length: 100
     */
    subjects?: At.DID[];
  }
  interface Output extends TypedBase {
    actions: ToolsOzoneModerationDefs.ScheduledActionView[];
    /** Cursor for next page of results */
    cursor?: string;
  }
}

/** List moderation events related to a subject. */
export declare namespace ToolsOzoneModerationQueryEvents {
  interface Params extends TypedBase {
    /** If specified, only events where all of these labels were added are returned */
    addedLabels?: string[];
    /** If specified, only events where all of these tags were added are returned */
    addedTags?: string[];
    /** If specified, only events where the age assurance state matches the given value are returned */
    ageAssuranceState?:
      | "assured"
      | "blocked"
      | "pending"
      | "reset"
      | "unknown"
      | (string & {});
    /** If specified, only events where the batchId matches the given value are returned */
    batchId?: string;
    /**
     * If specified, only events where the subject belongs to the given collections will be returned. When subjectType is set to 'account', this will be ignored.
     * Maximum array length: 20
     */
    collections?: string[];
    /** If specified, only events with comments containing the keyword are returned. Apply || separator to use multiple keywords and match using OR condition. */
    comment?: string;
    /** Retrieve events created after a given timestamp */
    createdAfter?: string;
    /** Retrieve events created before a given timestamp */
    createdBefore?: string;
    createdBy?: At.DID;
    cursor?: string;
    /** If true, only events with comments are returned */
    hasComment?: boolean;
    /**
     * If true, events on all record types (posts, lists, profile etc.) or records from given 'collections' param, owned by the did are returned.
     * \@default false
     */
    includeAllUserRecords?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** If specified, only events where the modTool name matches any of the given values are returned */
    modTool?: string[];
    /** If specified, only events where the action policies match any of the given policies are returned */
    policies?: string[];
    /** If specified, only events where all of these labels were removed are returned */
    removedLabels?: string[];
    /** If specified, only events where all of these tags were removed are returned */
    removedTags?: string[];
    reportTypes?: string[];
    /**
     * Sort direction for the events. Defaults to descending order of created at timestamp.
     * \@default "desc"
     */
    sortDirection?: "asc" | "desc";
    subject?: string;
    /** If specified, only events where the subject is of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored. */
    subjectType?: "account" | "record" | (string & {});
    /** The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned. */
    types?: string[];
    /** If specified, only events where strikeCount value is set are returned. */
    withStrike?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    events: ToolsOzoneModerationDefs.ModEventView[];
    cursor?: string;
  }
}

/** View moderation statuses of subjects (record or repo). */
export declare namespace ToolsOzoneModerationQueryStatuses {
  interface Params extends TypedBase {
    /** If specified, only subjects with the given age assurance state will be returned. */
    ageAssuranceState?:
      | "assured"
      | "blocked"
      | "pending"
      | "reset"
      | "unknown"
      | (string & {});
    /** Get subjects in unresolved appealed status */
    appealed?: boolean;
    /**
     * If specified, subjects belonging to the given collections will be returned. When subjectType is set to 'account', this will be ignored.
     * Maximum array length: 20
     */
    collections?: string[];
    /** Search subjects by keyword from comments */
    comment?: string;
    cursor?: string;
    excludeTags?: string[];
    /** Search subjects where the associated record/account was deleted after a given timestamp */
    hostingDeletedAfter?: string;
    /** Search subjects where the associated record/account was deleted before a given timestamp */
    hostingDeletedBefore?: string;
    /** Search subjects by the status of the associated record/account */
    hostingStatuses?: string[];
    /** Search subjects where the associated record/account was updated after a given timestamp */
    hostingUpdatedAfter?: string;
    /** Search subjects where the associated record/account was updated before a given timestamp */
    hostingUpdatedBefore?: string;
    ignoreSubjects?: string[];
    /** All subjects, or subjects from given 'collections' param, belonging to the account specified in the 'subject' param will be returned. */
    includeAllUserRecords?: boolean;
    /** By default, we don't include muted subjects in the results. Set this to true to include them. */
    includeMuted?: boolean;
    /** Get all subject statuses that were reviewed by a specific moderator */
    lastReviewedBy?: At.DID;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** If specified, only subjects that belong to an account that has at least this many suspensions will be returned. */
    minAccountSuspendCount?: number;
    /**
     * If specified, only subjects that have priority score value above the given value will be returned.
     * Minimum: 0
     * Maximum: 100
     */
    minPriorityScore?: number;
    /** If specified, only subjects that belong to an account that has at least this many reported records will be returned. */
    minReportedRecordsCount?: number;
    /**
     * If specified, only subjects that belong to an account that has at least this many active strikes will be returned.
     * Minimum: 1
     */
    minStrikeCount?: number;
    /** If specified, only subjects that belong to an account that has at least this many taken down records will be returned. */
    minTakendownRecordsCount?: number;
    /** When set to true, only muted subjects and reporters will be returned. */
    onlyMuted?: boolean;
    /** Number of queues being used by moderators. Subjects will be split among all queues. */
    queueCount?: number;
    /** Index of the queue to fetch subjects from. Works only when queueCount value is specified. */
    queueIndex?: number;
    /** A seeder to shuffle/balance the queue items. */
    queueSeed?: string;
    /** Search subjects reported after a given timestamp */
    reportedAfter?: string;
    /** Search subjects reported before a given timestamp */
    reportedBefore?: string;
    /** Search subjects reviewed after a given timestamp */
    reviewedAfter?: string;
    /** Search subjects reviewed before a given timestamp */
    reviewedBefore?: string;
    /** Specify when fetching subjects in a certain state */
    reviewState?:
      | "tools.ozone.moderation.defs#reviewClosed"
      | "tools.ozone.moderation.defs#reviewEscalated"
      | "tools.ozone.moderation.defs#reviewNone"
      | "tools.ozone.moderation.defs#reviewOpen"
      | (string & {});
    /** \@default "desc" */
    sortDirection?: "asc" | "desc";
    /** \@default "lastReportedAt" */
    sortField?:
      | "lastReviewedAt"
      | "lastReportedAt"
      | "reportedRecordsCount"
      | "takendownRecordsCount"
      | "priorityScore";
    /** The subject to get the status for. */
    subject?: string;
    /** If specified, subjects of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored. */
    subjectType?: "account" | "record" | (string & {});
    /**
     * Maximum array length: 25
     * Items in this array are applied with OR filters. To apply AND filter, put all tags in the same string and separate using && characters
     */
    tags?: string[];
    /** Get subjects that were taken down */
    takendown?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    subjectStatuses: ToolsOzoneModerationDefs.SubjectStatusView[];
    cursor?: string;
  }
}

/** Schedule a moderation action to be executed at a future time */
export declare namespace ToolsOzoneModerationScheduleAction {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    action: TypeUnion<Takedown>;
    createdBy: At.DID;
    scheduling: SchedulingConfig;
    /**
     * Array of DID subjects to schedule the action for
     * Maximum array length: 100
     */
    subjects: At.DID[];
    /** This will be propagated to the moderation event when it is applied */
    modTool?: ToolsOzoneModerationDefs.ModTool;
  }
  type Output = ScheduledActionResults;
  interface FailedScheduling extends TypedBase {
    error: string;
    subject: At.DID;
    errorCode?: string;
  }
  interface ScheduledActionResults extends TypedBase {
    failed: FailedScheduling[];
    succeeded: At.DID[];
  }
  /** Configuration for when the action should be executed */
  interface SchedulingConfig extends TypedBase {
    /** Earliest time to execute the action (for randomized scheduling) */
    executeAfter?: string;
    /** Exact time to execute the action */
    executeAt?: string;
    /** Latest time to execute the action (for randomized scheduling) */
    executeUntil?: string;
  }
  /** Schedule a takedown action */
  interface Takedown extends TypedBase {
    /** If true, all other reports on content authored by this account will be resolved (acknowledged). */
    acknowledgeAccountSubjects?: boolean;
    comment?: string;
    /** Indicates how long the takedown should be in effect before automatically expiring. */
    durationInHours?: number;
    /** Email content to be sent to the user upon takedown. */
    emailContent?: string;
    /** Subject of the email to be sent to the user upon takedown. */
    emailSubject?: string;
    /**
     * Names/Keywords of the policies that drove the decision.
     * Maximum array length: 5
     */
    policies?: string[];
    /** Severity level of the violation (e.g., 'sev-0', 'sev-1', 'sev-2', etc.). */
    severityLevel?: string;
    /** Number of strikes to assign to the user when takedown is applied. */
    strikeCount?: number;
    /** When the strike should expire. If not provided, the strike never expires. */
    strikeExpiresAt?: string;
  }
}

/** Find repositories based on a search term. */
export declare namespace ToolsOzoneModerationSearchRepos {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    q?: string;
    /**
     * DEPRECATED: use 'q' instead
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: ToolsOzoneModerationDefs.RepoView[];
    cursor?: string;
  }
}

export declare namespace ToolsOzoneReportDefs {
  type ReasonAppeal = "tools.ozone.report.defs#reasonAppeal";
  type ReasonChildSafetyCSAM = "tools.ozone.report.defs#reasonChildSafetyCSAM";
  type ReasonChildSafetyGroom =
    "tools.ozone.report.defs#reasonChildSafetyGroom";
  type ReasonChildSafetyHarassment =
    "tools.ozone.report.defs#reasonChildSafetyHarassment";
  type ReasonChildSafetyOther =
    "tools.ozone.report.defs#reasonChildSafetyOther";
  type ReasonChildSafetyPrivacy =
    "tools.ozone.report.defs#reasonChildSafetyPrivacy";
  type ReasonHarassmentDoxxing =
    "tools.ozone.report.defs#reasonHarassmentDoxxing";
  type ReasonHarassmentHateSpeech =
    "tools.ozone.report.defs#reasonHarassmentHateSpeech";
  type ReasonHarassmentOther = "tools.ozone.report.defs#reasonHarassmentOther";
  type ReasonHarassmentTargeted =
    "tools.ozone.report.defs#reasonHarassmentTargeted";
  type ReasonHarassmentTroll = "tools.ozone.report.defs#reasonHarassmentTroll";
  type ReasonMisleadingBot = "tools.ozone.report.defs#reasonMisleadingBot";
  type ReasonMisleadingElections =
    "tools.ozone.report.defs#reasonMisleadingElections";
  type ReasonMisleadingImpersonation =
    "tools.ozone.report.defs#reasonMisleadingImpersonation";
  type ReasonMisleadingOther = "tools.ozone.report.defs#reasonMisleadingOther";
  type ReasonMisleadingScam = "tools.ozone.report.defs#reasonMisleadingScam";
  type ReasonMisleadingSpam = "tools.ozone.report.defs#reasonMisleadingSpam";
  type ReasonOther = "tools.ozone.report.defs#reasonOther";
  type ReasonRuleBanEvasion = "tools.ozone.report.defs#reasonRuleBanEvasion";
  type ReasonRuleOther = "tools.ozone.report.defs#reasonRuleOther";
  type ReasonRuleProhibitedSales =
    "tools.ozone.report.defs#reasonRuleProhibitedSales";
  type ReasonRuleSiteSecurity =
    "tools.ozone.report.defs#reasonRuleSiteSecurity";
  type ReasonSelfHarmContent = "tools.ozone.report.defs#reasonSelfHarmContent";
  type ReasonSelfHarmED = "tools.ozone.report.defs#reasonSelfHarmED";
  type ReasonSelfHarmOther = "tools.ozone.report.defs#reasonSelfHarmOther";
  type ReasonSelfHarmStunts = "tools.ozone.report.defs#reasonSelfHarmStunts";
  type ReasonSelfHarmSubstances =
    "tools.ozone.report.defs#reasonSelfHarmSubstances";
  type ReasonSexualAbuseContent =
    "tools.ozone.report.defs#reasonSexualAbuseContent";
  type ReasonSexualAnimal = "tools.ozone.report.defs#reasonSexualAnimal";
  type ReasonSexualDeepfake = "tools.ozone.report.defs#reasonSexualDeepfake";
  type ReasonSexualNCII = "tools.ozone.report.defs#reasonSexualNCII";
  type ReasonSexualOther = "tools.ozone.report.defs#reasonSexualOther";
  type ReasonSexualUnlabeled = "tools.ozone.report.defs#reasonSexualUnlabeled";
  type ReasonType =
    | "tools.ozone.report.defs#reasonAppeal"
    | "tools.ozone.report.defs#reasonChildSafetyCSAM"
    | "tools.ozone.report.defs#reasonChildSafetyGroom"
    | "tools.ozone.report.defs#reasonChildSafetyHarassment"
    | "tools.ozone.report.defs#reasonChildSafetyOther"
    | "tools.ozone.report.defs#reasonChildSafetyPrivacy"
    | "tools.ozone.report.defs#reasonHarassmentDoxxing"
    | "tools.ozone.report.defs#reasonHarassmentHateSpeech"
    | "tools.ozone.report.defs#reasonHarassmentOther"
    | "tools.ozone.report.defs#reasonHarassmentTargeted"
    | "tools.ozone.report.defs#reasonHarassmentTroll"
    | "tools.ozone.report.defs#reasonMisleadingBot"
    | "tools.ozone.report.defs#reasonMisleadingElections"
    | "tools.ozone.report.defs#reasonMisleadingImpersonation"
    | "tools.ozone.report.defs#reasonMisleadingOther"
    | "tools.ozone.report.defs#reasonMisleadingScam"
    | "tools.ozone.report.defs#reasonMisleadingSpam"
    | "tools.ozone.report.defs#reasonOther"
    | "tools.ozone.report.defs#reasonRuleBanEvasion"
    | "tools.ozone.report.defs#reasonRuleOther"
    | "tools.ozone.report.defs#reasonRuleProhibitedSales"
    | "tools.ozone.report.defs#reasonRuleSiteSecurity"
    | "tools.ozone.report.defs#reasonSelfHarmContent"
    | "tools.ozone.report.defs#reasonSelfHarmED"
    | "tools.ozone.report.defs#reasonSelfHarmOther"
    | "tools.ozone.report.defs#reasonSelfHarmStunts"
    | "tools.ozone.report.defs#reasonSelfHarmSubstances"
    | "tools.ozone.report.defs#reasonSexualAbuseContent"
    | "tools.ozone.report.defs#reasonSexualAnimal"
    | "tools.ozone.report.defs#reasonSexualDeepfake"
    | "tools.ozone.report.defs#reasonSexualNCII"
    | "tools.ozone.report.defs#reasonSexualOther"
    | "tools.ozone.report.defs#reasonSexualUnlabeled"
    | "tools.ozone.report.defs#reasonViolenceAnimal"
    | "tools.ozone.report.defs#reasonViolenceExtremistContent"
    | "tools.ozone.report.defs#reasonViolenceGlorification"
    | "tools.ozone.report.defs#reasonViolenceGraphicContent"
    | "tools.ozone.report.defs#reasonViolenceOther"
    | "tools.ozone.report.defs#reasonViolenceThreats"
    | "tools.ozone.report.defs#reasonViolenceTrafficking"
    | (string & {});
  type ReasonViolenceAnimal = "tools.ozone.report.defs#reasonViolenceAnimal";
  type ReasonViolenceExtremistContent =
    "tools.ozone.report.defs#reasonViolenceExtremistContent";
  type ReasonViolenceGlorification =
    "tools.ozone.report.defs#reasonViolenceGlorification";
  type ReasonViolenceGraphicContent =
    "tools.ozone.report.defs#reasonViolenceGraphicContent";
  type ReasonViolenceOther = "tools.ozone.report.defs#reasonViolenceOther";
  type ReasonViolenceThreats = "tools.ozone.report.defs#reasonViolenceThreats";
  type ReasonViolenceTrafficking =
    "tools.ozone.report.defs#reasonViolenceTrafficking";
}

/** Add a new URL safety rule */
export declare namespace ToolsOzoneSafelinkAddRule {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    action: ToolsOzoneSafelinkDefs.ActionType;
    pattern: ToolsOzoneSafelinkDefs.PatternType;
    reason: ToolsOzoneSafelinkDefs.ReasonType;
    /** The URL or domain to apply the rule to */
    url: string;
    /** Optional comment about the decision */
    comment?: string;
    /** Author DID. Only respected when using admin auth */
    createdBy?: At.DID;
  }
  type Output = ToolsOzoneSafelinkDefs.Event;
  interface Errors extends TypedBase {
    InvalidUrl: {};
    RuleAlreadyExists: {};
  }
}

export declare namespace ToolsOzoneSafelinkDefs {
  type ActionType = "block" | "warn" | "whitelist" | (string & {});
  /** An event for URL safety decisions */
  interface Event extends TypedBase {
    action: ActionType;
    createdAt: string;
    /** DID of the user who created this rule */
    createdBy: At.DID;
    eventType: EventType;
    /** Auto-incrementing row ID */
    id: number;
    pattern: PatternType;
    reason: ReasonType;
    /** The URL that this rule applies to */
    url: string;
    /** Optional comment about the decision */
    comment?: string;
  }
  type EventType = "addRule" | "removeRule" | "updateRule" | (string & {});
  type PatternType = "domain" | "url" | (string & {});
  type ReasonType = "csam" | "none" | "phishing" | "spam" | (string & {});
  /** Input for creating a URL safety rule */
  interface UrlRule extends TypedBase {
    action: ActionType;
    /** Timestamp when the rule was created */
    createdAt: string;
    /** DID of the user added the rule. */
    createdBy: At.DID;
    pattern: PatternType;
    reason: ReasonType;
    /** Timestamp when the rule was last updated */
    updatedAt: string;
    /** The URL or domain to apply the rule to */
    url: string;
    /** Optional comment about the decision */
    comment?: string;
  }
}

/** Query URL safety audit events */
export declare namespace ToolsOzoneSafelinkQueryEvents {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Cursor for pagination */
    cursor?: string;
    /**
     * Maximum number of results to return
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Filter by pattern type */
    patternType?: string;
    /**
     * Sort direction
     * \@default "desc"
     */
    sortDirection?: "asc" | "desc" | (string & {});
    /** Filter by specific URLs or domains */
    urls?: string[];
  }
  interface Output extends TypedBase {
    events: ToolsOzoneSafelinkDefs.Event[];
    /** Next cursor for pagination. Only present if there are more results. */
    cursor?: string;
  }
}

/** Query URL safety rules */
export declare namespace ToolsOzoneSafelinkQueryRules {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Filter by action types */
    actions?: string[];
    /** Filter by rule creator */
    createdBy?: At.DID;
    /** Cursor for pagination */
    cursor?: string;
    /**
     * Maximum number of results to return
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Filter by pattern type */
    patternType?: string;
    /** Filter by reason type */
    reason?: string;
    /**
     * Sort direction
     * \@default "desc"
     */
    sortDirection?: "asc" | "desc" | (string & {});
    /** Filter by specific URLs or domains */
    urls?: string[];
  }
  interface Output extends TypedBase {
    rules: ToolsOzoneSafelinkDefs.UrlRule[];
    /** Next cursor for pagination. Only present if there are more results. */
    cursor?: string;
  }
}

/** Remove an existing URL safety rule */
export declare namespace ToolsOzoneSafelinkRemoveRule {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    pattern: ToolsOzoneSafelinkDefs.PatternType;
    /** The URL or domain to remove the rule for */
    url: string;
    /** Optional comment about why the rule is being removed */
    comment?: string;
    /** Optional DID of the user. Only respected when using admin auth. */
    createdBy?: At.DID;
  }
  type Output = ToolsOzoneSafelinkDefs.Event;
  interface Errors extends TypedBase {
    RuleNotFound: {};
  }
}

/** Update an existing URL safety rule */
export declare namespace ToolsOzoneSafelinkUpdateRule {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    action: ToolsOzoneSafelinkDefs.ActionType;
    pattern: ToolsOzoneSafelinkDefs.PatternType;
    reason: ToolsOzoneSafelinkDefs.ReasonType;
    /** The URL or domain to update the rule for */
    url: string;
    /** Optional comment about the update */
    comment?: string;
    /** Optional DID to credit as the creator. Only respected for admin_token authentication. */
    createdBy?: At.DID;
  }
  type Output = ToolsOzoneSafelinkDefs.Event;
  interface Errors extends TypedBase {
    RuleNotFound: {};
  }
}

/** Get details about ozone's server configuration. */
export declare namespace ToolsOzoneServerGetConfig {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    appview?: ServiceConfig;
    blobDivert?: ServiceConfig;
    chat?: ServiceConfig;
    pds?: ServiceConfig;
    /** The did of the verifier used for verification. */
    verifierDid?: At.DID;
    viewer?: ViewerConfig;
  }
  interface ServiceConfig extends TypedBase {
    url?: string;
  }
  interface ViewerConfig extends TypedBase {
    role?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | "tools.ozone.team.defs#roleVerifier"
      | (string & {});
  }
}

/** Add values to a specific set. Attempting to add values to a set that does not exist will result in an error. */
export declare namespace ToolsOzoneSetAddValues {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Name of the set to add values to */
    name: string;
    /**
     * Array of string values to add to the set
     * Minimum array length: 1
     * Maximum array length: 1000
     */
    values: string[];
  }
  type Output = undefined;
}

export declare namespace ToolsOzoneSetDefs {
  interface Set extends TypedBase {
    /**
     * Minimum string length: 3
     * Maximum string length: 128
     */
    name: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
  }
  interface SetView extends TypedBase {
    createdAt: string;
    /**
     * Minimum string length: 3
     * Maximum string length: 128
     */
    name: string;
    setSize: number;
    updatedAt: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
  }
}

/** Delete an entire set. Attempting to delete a set that does not exist will result in an error. */
export declare namespace ToolsOzoneSetDeleteSet {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Name of the set to delete */
    name: string;
  }
  interface Output extends TypedBase {}
  interface Errors extends TypedBase {
    SetNotFound: {};
  }
}

/** Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error */
export declare namespace ToolsOzoneSetDeleteValues {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Name of the set to delete values from */
    name: string;
    /**
     * Array of string values to delete from the set
     * Minimum array length: 1
     */
    values: string[];
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    SetNotFound: {};
  }
}

/** Get a specific set and its values */
export declare namespace ToolsOzoneSetGetValues {
  interface Params extends TypedBase {
    name: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 100
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    set: ToolsOzoneSetDefs.SetView;
    values: string[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    SetNotFound: {};
  }
}

/** Query available sets */
export declare namespace ToolsOzoneSetQuerySets {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    namePrefix?: string;
    /** \@default "name" */
    sortBy?: "name" | "createdAt" | "updatedAt";
    /**
     * Defaults to ascending order of name field.
     * \@default "asc"
     */
    sortDirection?: "asc" | "desc";
  }
  type Input = undefined;
  interface Output extends TypedBase {
    sets: ToolsOzoneSetDefs.SetView[];
    cursor?: string;
  }
}

/** Create or update set metadata */
export declare namespace ToolsOzoneSetUpsertSet {
  interface Params extends TypedBase {}
  type Input = ToolsOzoneSetDefs.Set;
  type Output = ToolsOzoneSetDefs.SetView;
}

export declare namespace ToolsOzoneSettingDefs {
  interface Option extends TypedBase {
    createdBy: At.DID;
    did: At.DID;
    key: string;
    lastUpdatedBy: At.DID;
    scope: "instance" | "personal" | (string & {});
    value: unknown;
    createdAt?: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
    managerRole?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | "tools.ozone.team.defs#roleVerifier"
      | (string & {});
    updatedAt?: string;
  }
}

/** List settings with optional filtering */
export declare namespace ToolsOzoneSettingListOptions {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Filter for only the specified keys. Ignored if prefix is provided
     * Maximum array length: 100
     */
    keys?: string[];
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Filter keys by prefix */
    prefix?: string;
    /** \@default "instance" */
    scope?: "instance" | "personal" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    options: ToolsOzoneSettingDefs.Option[];
    cursor?: string;
  }
}

/** Delete settings by key */
export declare namespace ToolsOzoneSettingRemoveOptions {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 200
     */
    keys: string[];
    scope: "instance" | "personal" | (string & {});
  }
  interface Output extends TypedBase {}
}

/** Create or update setting option */
export declare namespace ToolsOzoneSettingUpsertOption {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    key: string;
    scope: "instance" | "personal" | (string & {});
    value: unknown;
    /** Maximum string length: 2000 */
    description?: string;
    managerRole?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | "tools.ozone.team.defs#roleVerifier"
      | (string & {});
  }
  interface Output extends TypedBase {
    option: ToolsOzoneSettingDefs.Option;
  }
}

export declare namespace ToolsOzoneSignatureDefs {
  interface SigDetail extends TypedBase {
    property: string;
    value: string;
  }
}

/** Find all correlated threat signatures between 2 or more accounts. */
export declare namespace ToolsOzoneSignatureFindCorrelation {
  interface Params extends TypedBase {
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    details: ToolsOzoneSignatureDefs.SigDetail[];
  }
}

/** Get accounts that share some matching threat signatures with the root account. */
export declare namespace ToolsOzoneSignatureFindRelatedAccounts {
  interface Params extends TypedBase {
    did: At.DID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    accounts: RelatedAccount[];
    cursor?: string;
  }
  interface RelatedAccount extends TypedBase {
    account: ComAtprotoAdminDefs.AccountView;
    similarities?: ToolsOzoneSignatureDefs.SigDetail[];
  }
}

/** Search for accounts that match one or more threat signature values. */
export declare namespace ToolsOzoneSignatureSearchAccounts {
  interface Params extends TypedBase {
    values: string[];
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    accounts: ComAtprotoAdminDefs.AccountView[];
    cursor?: string;
  }
}

/** Add a member to the ozone team. Requires admin role. */
export declare namespace ToolsOzoneTeamAddMember {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    role:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | "tools.ozone.team.defs#roleVerifier"
      | (string & {});
  }
  type Output = ToolsOzoneTeamDefs.Member;
  interface Errors extends TypedBase {
    MemberAlreadyExists: {};
  }
}

export declare namespace ToolsOzoneTeamDefs {
  interface Member extends TypedBase {
    did: At.DID;
    role:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | "tools.ozone.team.defs#roleVerifier"
      | (string & {});
    createdAt?: string;
    disabled?: boolean;
    lastUpdatedBy?: string;
    profile?: AppBskyActorDefs.ProfileViewDetailed;
    updatedAt?: string;
  }
  type RoleAdmin = "tools.ozone.team.defs#roleAdmin";
  type RoleModerator = "tools.ozone.team.defs#roleModerator";
  type RoleTriage = "tools.ozone.team.defs#roleTriage";
  type RoleVerifier = "tools.ozone.team.defs#roleVerifier";
}

/** Delete a member from ozone team. Requires admin role. */
export declare namespace ToolsOzoneTeamDeleteMember {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    MemberNotFound: {};
    CannotDeleteSelf: {};
  }
}

/** List all members with access to the ozone service. */
export declare namespace ToolsOzoneTeamListMembers {
  interface Params extends TypedBase {
    cursor?: string;
    disabled?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    q?: string;
    roles?: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    members: ToolsOzoneTeamDefs.Member[];
    cursor?: string;
  }
}

/** Update a member in the ozone service. Requires admin role. */
export declare namespace ToolsOzoneTeamUpdateMember {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    disabled?: boolean;
    role?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | "tools.ozone.team.defs#roleVerifier"
      | (string & {});
  }
  type Output = ToolsOzoneTeamDefs.Member;
  interface Errors extends TypedBase {
    MemberNotFound: {};
  }
}

export declare namespace ToolsOzoneVerificationDefs {
  /** Verification data for the associated subject. */
  interface VerificationView extends TypedBase {
    /** Timestamp when the verification was created. */
    createdAt: string;
    /** Display name of the subject the verification applies to at the moment of verifying, which might not be the same at the time of viewing. The verification is only valid if the current displayName matches the one at the time of verifying. */
    displayName: string;
    /** Handle of the subject the verification applies to at the moment of verifying, which might not be the same at the time of viewing. The verification is only valid if the current handle matches the one at the time of verifying. */
    handle: At.Handle;
    /** The user who issued this verification. */
    issuer: At.DID;
    /** The subject of the verification. */
    subject: At.DID;
    /** The AT-URI of the verification record. */
    uri: At.Uri;
    issuerProfile?: never;
    issuerRepo?: TypeUnion<
      | ToolsOzoneModerationDefs.RepoViewDetail
      | ToolsOzoneModerationDefs.RepoViewNotFound
    >;
    /** Timestamp when the verification was revoked. */
    revokedAt?: string;
    /** The user who revoked this verification. */
    revokedBy?: At.DID;
    /** Describes the reason for revocation, also indicating that the verification is no longer valid. */
    revokeReason?: string;
    subjectProfile?: never;
    subjectRepo?: TypeUnion<
      | ToolsOzoneModerationDefs.RepoViewDetail
      | ToolsOzoneModerationDefs.RepoViewNotFound
    >;
  }
}

/** Grant verifications to multiple subjects. Allows batch processing of up to 100 verifications at once. */
export declare namespace ToolsOzoneVerificationGrantVerifications {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * Array of verification requests to process
     * Maximum array length: 100
     */
    verifications: VerificationInput[];
  }
  interface Output extends TypedBase {
    failedVerifications: GrantError[];
    verifications: ToolsOzoneVerificationDefs.VerificationView[];
  }
  /** Error object for failed verifications. */
  interface GrantError extends TypedBase {
    /** Error message describing the reason for failure. */
    error: string;
    /** The did of the subject being verified */
    subject: At.DID;
  }
  interface VerificationInput extends TypedBase {
    /** Display name of the subject the verification applies to at the moment of verifying. */
    displayName: string;
    /** Handle of the subject the verification applies to at the moment of verifying. */
    handle: At.Handle;
    /** The did of the subject being verified */
    subject: At.DID;
    /** Timestamp for verification record. Defaults to current time when not specified. */
    createdAt?: string;
  }
}

/** List verifications */
export declare namespace ToolsOzoneVerificationListVerifications {
  interface Params extends TypedBase {
    /** Filter to verifications created after this timestamp */
    createdAfter?: string;
    /** Filter to verifications created before this timestamp */
    createdBefore?: string;
    /** Pagination cursor */
    cursor?: string;
    /** Filter to verifications that are revoked or not. By default, includes both. */
    isRevoked?: boolean;
    /**
     * Filter to verifications from specific issuers
     * Maximum array length: 100
     */
    issuers?: At.DID[];
    /**
     * Maximum number of results to return
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /**
     * Sort direction for creation date
     * \@default "desc"
     */
    sortDirection?: "asc" | "desc";
    /**
     * Filter to specific verified DIDs
     * Maximum array length: 100
     */
    subjects?: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    verifications: ToolsOzoneVerificationDefs.VerificationView[];
    cursor?: string;
  }
}

/** Revoke previously granted verifications in batches of up to 100. */
export declare namespace ToolsOzoneVerificationRevokeVerifications {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * Array of verification record uris to revoke
     * Maximum array length: 100
     * The AT-URI of the verification record to revoke.
     */
    uris: At.Uri[];
    /**
     * Reason for revoking the verification. This is optional and can be omitted if not needed.
     * Maximum string length: 1000
     */
    revokeReason?: string;
  }
  interface Output extends TypedBase {
    /** List of verification uris that couldn't be revoked, including failure reasons */
    failedRevocations: RevokeError[];
    /** List of verification uris successfully revoked */
    revokedVerifications: At.Uri[];
  }
  /** Error object for failed revocations */
  interface RevokeError extends TypedBase {
    /** Description of the error that occurred during revocation. */
    error: string;
    /** The AT-URI of the verification record that failed to revoke. */
    uri: At.Uri;
  }
}

export declare interface Records extends RecordBase {
  "app.bsky.actor.profile": AppBskyActorProfile.Record;
  "app.bsky.actor.status": AppBskyActorStatus.Record;
  "app.bsky.feed.generator": AppBskyFeedGenerator.Record;
  "app.bsky.feed.like": AppBskyFeedLike.Record;
  "app.bsky.feed.post": AppBskyFeedPost.Record;
  "app.bsky.feed.postgate": AppBskyFeedPostgate.Record;
  "app.bsky.feed.repost": AppBskyFeedRepost.Record;
  "app.bsky.feed.threadgate": AppBskyFeedThreadgate.Record;
  "app.bsky.graph.block": AppBskyGraphBlock.Record;
  "app.bsky.graph.follow": AppBskyGraphFollow.Record;
  "app.bsky.graph.list": AppBskyGraphList.Record;
  "app.bsky.graph.listblock": AppBskyGraphListblock.Record;
  "app.bsky.graph.listitem": AppBskyGraphListitem.Record;
  "app.bsky.graph.starterpack": AppBskyGraphStarterpack.Record;
  "app.bsky.graph.verification": AppBskyGraphVerification.Record;
  "app.bsky.labeler.service": AppBskyLabelerService.Record;
  "app.bsky.notification.declaration": AppBskyNotificationDeclaration.Record;
  "chat.bsky.actor.declaration": ChatBskyActorDeclaration.Record;
  "com.atproto.lexicon.schema": ComAtprotoLexiconSchema.Record;
}

export declare interface Queries {
  "app.bsky.actor.getPreferences": {
    output: AppBskyActorGetPreferences.Output;
  };
  "app.bsky.actor.getProfile": {
    params: AppBskyActorGetProfile.Params;
    output: AppBskyActorGetProfile.Output;
  };
  "app.bsky.actor.getProfiles": {
    params: AppBskyActorGetProfiles.Params;
    output: AppBskyActorGetProfiles.Output;
  };
  "app.bsky.actor.getSuggestions": {
    params: AppBskyActorGetSuggestions.Params;
    output: AppBskyActorGetSuggestions.Output;
  };
  "app.bsky.actor.searchActors": {
    params: AppBskyActorSearchActors.Params;
    output: AppBskyActorSearchActors.Output;
  };
  "app.bsky.actor.searchActorsTypeahead": {
    params: AppBskyActorSearchActorsTypeahead.Params;
    output: AppBskyActorSearchActorsTypeahead.Output;
  };
  "app.bsky.ageassurance.getConfig": {
    output: AppBskyAgeassuranceGetConfig.Output;
  };
  "app.bsky.ageassurance.getState": {
    params: AppBskyAgeassuranceGetState.Params;
    output: AppBskyAgeassuranceGetState.Output;
  };
  "app.bsky.bookmark.getBookmarks": {
    params: AppBskyBookmarkGetBookmarks.Params;
    output: AppBskyBookmarkGetBookmarks.Output;
  };
  "app.bsky.contact.getMatches": {
    params: AppBskyContactGetMatches.Params;
    output: AppBskyContactGetMatches.Output;
  };
  "app.bsky.contact.getSyncStatus": {
    output: AppBskyContactGetSyncStatus.Output;
  };
  "app.bsky.draft.getDrafts": {
    params: AppBskyDraftGetDrafts.Params;
    output: AppBskyDraftGetDrafts.Output;
  };
  "app.bsky.feed.describeFeedGenerator": {
    output: AppBskyFeedDescribeFeedGenerator.Output;
  };
  "app.bsky.feed.getActorFeeds": {
    params: AppBskyFeedGetActorFeeds.Params;
    output: AppBskyFeedGetActorFeeds.Output;
  };
  "app.bsky.feed.getActorLikes": {
    params: AppBskyFeedGetActorLikes.Params;
    output: AppBskyFeedGetActorLikes.Output;
  };
  "app.bsky.feed.getAuthorFeed": {
    params: AppBskyFeedGetAuthorFeed.Params;
    output: AppBskyFeedGetAuthorFeed.Output;
  };
  "app.bsky.feed.getFeed": {
    params: AppBskyFeedGetFeed.Params;
    output: AppBskyFeedGetFeed.Output;
  };
  "app.bsky.feed.getFeedGenerator": {
    params: AppBskyFeedGetFeedGenerator.Params;
    output: AppBskyFeedGetFeedGenerator.Output;
  };
  "app.bsky.feed.getFeedGenerators": {
    params: AppBskyFeedGetFeedGenerators.Params;
    output: AppBskyFeedGetFeedGenerators.Output;
  };
  "app.bsky.feed.getFeedSkeleton": {
    params: AppBskyFeedGetFeedSkeleton.Params;
    output: AppBskyFeedGetFeedSkeleton.Output;
  };
  "app.bsky.feed.getLikes": {
    params: AppBskyFeedGetLikes.Params;
    output: AppBskyFeedGetLikes.Output;
  };
  "app.bsky.feed.getListFeed": {
    params: AppBskyFeedGetListFeed.Params;
    output: AppBskyFeedGetListFeed.Output;
  };
  "app.bsky.feed.getPosts": {
    params: AppBskyFeedGetPosts.Params;
    output: AppBskyFeedGetPosts.Output;
  };
  "app.bsky.feed.getPostThread": {
    params: AppBskyFeedGetPostThread.Params;
    output: AppBskyFeedGetPostThread.Output;
  };
  "app.bsky.feed.getQuotes": {
    params: AppBskyFeedGetQuotes.Params;
    output: AppBskyFeedGetQuotes.Output;
  };
  "app.bsky.feed.getRepostedBy": {
    params: AppBskyFeedGetRepostedBy.Params;
    output: AppBskyFeedGetRepostedBy.Output;
  };
  "app.bsky.feed.getSuggestedFeeds": {
    params: AppBskyFeedGetSuggestedFeeds.Params;
    output: AppBskyFeedGetSuggestedFeeds.Output;
  };
  "app.bsky.feed.getTimeline": {
    params: AppBskyFeedGetTimeline.Params;
    output: AppBskyFeedGetTimeline.Output;
  };
  "app.bsky.feed.searchPosts": {
    params: AppBskyFeedSearchPosts.Params;
    output: AppBskyFeedSearchPosts.Output;
  };
  "app.bsky.graph.getActorStarterPacks": {
    params: AppBskyGraphGetActorStarterPacks.Params;
    output: AppBskyGraphGetActorStarterPacks.Output;
  };
  "app.bsky.graph.getBlocks": {
    params: AppBskyGraphGetBlocks.Params;
    output: AppBskyGraphGetBlocks.Output;
  };
  "app.bsky.graph.getFollowers": {
    params: AppBskyGraphGetFollowers.Params;
    output: AppBskyGraphGetFollowers.Output;
  };
  "app.bsky.graph.getFollows": {
    params: AppBskyGraphGetFollows.Params;
    output: AppBskyGraphGetFollows.Output;
  };
  "app.bsky.graph.getKnownFollowers": {
    params: AppBskyGraphGetKnownFollowers.Params;
    output: AppBskyGraphGetKnownFollowers.Output;
  };
  "app.bsky.graph.getList": {
    params: AppBskyGraphGetList.Params;
    output: AppBskyGraphGetList.Output;
  };
  "app.bsky.graph.getListBlocks": {
    params: AppBskyGraphGetListBlocks.Params;
    output: AppBskyGraphGetListBlocks.Output;
  };
  "app.bsky.graph.getListMutes": {
    params: AppBskyGraphGetListMutes.Params;
    output: AppBskyGraphGetListMutes.Output;
  };
  "app.bsky.graph.getLists": {
    params: AppBskyGraphGetLists.Params;
    output: AppBskyGraphGetLists.Output;
  };
  "app.bsky.graph.getListsWithMembership": {
    params: AppBskyGraphGetListsWithMembership.Params;
    output: AppBskyGraphGetListsWithMembership.Output;
  };
  "app.bsky.graph.getMutes": {
    params: AppBskyGraphGetMutes.Params;
    output: AppBskyGraphGetMutes.Output;
  };
  "app.bsky.graph.getRelationships": {
    params: AppBskyGraphGetRelationships.Params;
    output: AppBskyGraphGetRelationships.Output;
  };
  "app.bsky.graph.getStarterPack": {
    params: AppBskyGraphGetStarterPack.Params;
    output: AppBskyGraphGetStarterPack.Output;
  };
  "app.bsky.graph.getStarterPacks": {
    params: AppBskyGraphGetStarterPacks.Params;
    output: AppBskyGraphGetStarterPacks.Output;
  };
  "app.bsky.graph.getStarterPacksWithMembership": {
    params: AppBskyGraphGetStarterPacksWithMembership.Params;
    output: AppBskyGraphGetStarterPacksWithMembership.Output;
  };
  "app.bsky.graph.getSuggestedFollowsByActor": {
    params: AppBskyGraphGetSuggestedFollowsByActor.Params;
    output: AppBskyGraphGetSuggestedFollowsByActor.Output;
  };
  "app.bsky.graph.searchStarterPacks": {
    params: AppBskyGraphSearchStarterPacks.Params;
    output: AppBskyGraphSearchStarterPacks.Output;
  };
  "app.bsky.labeler.getServices": {
    params: AppBskyLabelerGetServices.Params;
    output: AppBskyLabelerGetServices.Output;
  };
  "app.bsky.notification.getPreferences": {
    output: AppBskyNotificationGetPreferences.Output;
  };
  "app.bsky.notification.getUnreadCount": {
    params: AppBskyNotificationGetUnreadCount.Params;
    output: AppBskyNotificationGetUnreadCount.Output;
  };
  "app.bsky.notification.listActivitySubscriptions": {
    params: AppBskyNotificationListActivitySubscriptions.Params;
    output: AppBskyNotificationListActivitySubscriptions.Output;
  };
  "app.bsky.notification.listNotifications": {
    params: AppBskyNotificationListNotifications.Params;
    output: AppBskyNotificationListNotifications.Output;
  };
  "app.bsky.unspecced.getAgeAssuranceState": {
    output: AppBskyUnspeccedGetAgeAssuranceState.Output;
  };
  "app.bsky.unspecced.getConfig": {
    output: AppBskyUnspeccedGetConfig.Output;
  };
  "app.bsky.unspecced.getOnboardingSuggestedStarterPacks": {
    params: AppBskyUnspeccedGetOnboardingSuggestedStarterPacks.Params;
    output: AppBskyUnspeccedGetOnboardingSuggestedStarterPacks.Output;
  };
  "app.bsky.unspecced.getOnboardingSuggestedStarterPacksSkeleton": {
    params: AppBskyUnspeccedGetOnboardingSuggestedStarterPacksSkeleton.Params;
    output: AppBskyUnspeccedGetOnboardingSuggestedStarterPacksSkeleton.Output;
  };
  "app.bsky.unspecced.getPopularFeedGenerators": {
    params: AppBskyUnspeccedGetPopularFeedGenerators.Params;
    output: AppBskyUnspeccedGetPopularFeedGenerators.Output;
  };
  "app.bsky.unspecced.getPostThreadOtherV2": {
    params: AppBskyUnspeccedGetPostThreadOtherV2.Params;
    output: AppBskyUnspeccedGetPostThreadOtherV2.Output;
  };
  "app.bsky.unspecced.getPostThreadV2": {
    params: AppBskyUnspeccedGetPostThreadV2.Params;
    output: AppBskyUnspeccedGetPostThreadV2.Output;
  };
  "app.bsky.unspecced.getSuggestedFeeds": {
    params: AppBskyUnspeccedGetSuggestedFeeds.Params;
    output: AppBskyUnspeccedGetSuggestedFeeds.Output;
  };
  "app.bsky.unspecced.getSuggestedFeedsSkeleton": {
    params: AppBskyUnspeccedGetSuggestedFeedsSkeleton.Params;
    output: AppBskyUnspeccedGetSuggestedFeedsSkeleton.Output;
  };
  "app.bsky.unspecced.getSuggestedStarterPacks": {
    params: AppBskyUnspeccedGetSuggestedStarterPacks.Params;
    output: AppBskyUnspeccedGetSuggestedStarterPacks.Output;
  };
  "app.bsky.unspecced.getSuggestedStarterPacksSkeleton": {
    params: AppBskyUnspeccedGetSuggestedStarterPacksSkeleton.Params;
    output: AppBskyUnspeccedGetSuggestedStarterPacksSkeleton.Output;
  };
  "app.bsky.unspecced.getSuggestedUsers": {
    params: AppBskyUnspeccedGetSuggestedUsers.Params;
    output: AppBskyUnspeccedGetSuggestedUsers.Output;
  };
  "app.bsky.unspecced.getSuggestedUsersSkeleton": {
    params: AppBskyUnspeccedGetSuggestedUsersSkeleton.Params;
    output: AppBskyUnspeccedGetSuggestedUsersSkeleton.Output;
  };
  "app.bsky.unspecced.getSuggestionsSkeleton": {
    params: AppBskyUnspeccedGetSuggestionsSkeleton.Params;
    output: AppBskyUnspeccedGetSuggestionsSkeleton.Output;
  };
  "app.bsky.unspecced.getTaggedSuggestions": {
    output: AppBskyUnspeccedGetTaggedSuggestions.Output;
  };
  "app.bsky.unspecced.getTrendingTopics": {
    params: AppBskyUnspeccedGetTrendingTopics.Params;
    output: AppBskyUnspeccedGetTrendingTopics.Output;
  };
  "app.bsky.unspecced.getTrends": {
    params: AppBskyUnspeccedGetTrends.Params;
    output: AppBskyUnspeccedGetTrends.Output;
  };
  "app.bsky.unspecced.getTrendsSkeleton": {
    params: AppBskyUnspeccedGetTrendsSkeleton.Params;
    output: AppBskyUnspeccedGetTrendsSkeleton.Output;
  };
  "app.bsky.unspecced.searchActorsSkeleton": {
    params: AppBskyUnspeccedSearchActorsSkeleton.Params;
    output: AppBskyUnspeccedSearchActorsSkeleton.Output;
  };
  "app.bsky.unspecced.searchPostsSkeleton": {
    params: AppBskyUnspeccedSearchPostsSkeleton.Params;
    output: AppBskyUnspeccedSearchPostsSkeleton.Output;
  };
  "app.bsky.unspecced.searchStarterPacksSkeleton": {
    params: AppBskyUnspeccedSearchStarterPacksSkeleton.Params;
    output: AppBskyUnspeccedSearchStarterPacksSkeleton.Output;
  };
  "app.bsky.video.getJobStatus": {
    params: AppBskyVideoGetJobStatus.Params;
    output: AppBskyVideoGetJobStatus.Output;
  };
  "app.bsky.video.getUploadLimits": {
    output: AppBskyVideoGetUploadLimits.Output;
  };
  "chat.bsky.actor.exportAccountData": {
    output: ChatBskyActorExportAccountData.Output;
  };
  "chat.bsky.convo.getConvo": {
    params: ChatBskyConvoGetConvo.Params;
    output: ChatBskyConvoGetConvo.Output;
  };
  "chat.bsky.convo.getConvoAvailability": {
    params: ChatBskyConvoGetConvoAvailability.Params;
    output: ChatBskyConvoGetConvoAvailability.Output;
  };
  "chat.bsky.convo.getConvoForMembers": {
    params: ChatBskyConvoGetConvoForMembers.Params;
    output: ChatBskyConvoGetConvoForMembers.Output;
  };
  "chat.bsky.convo.getLog": {
    params: ChatBskyConvoGetLog.Params;
    output: ChatBskyConvoGetLog.Output;
  };
  "chat.bsky.convo.getMessages": {
    params: ChatBskyConvoGetMessages.Params;
    output: ChatBskyConvoGetMessages.Output;
  };
  "chat.bsky.convo.listConvos": {
    params: ChatBskyConvoListConvos.Params;
    output: ChatBskyConvoListConvos.Output;
  };
  "chat.bsky.moderation.getActorMetadata": {
    params: ChatBskyModerationGetActorMetadata.Params;
    output: ChatBskyModerationGetActorMetadata.Output;
  };
  "chat.bsky.moderation.getMessageContext": {
    params: ChatBskyModerationGetMessageContext.Params;
    output: ChatBskyModerationGetMessageContext.Output;
  };
  "com.atproto.admin.getAccountInfo": {
    params: ComAtprotoAdminGetAccountInfo.Params;
    output: ComAtprotoAdminGetAccountInfo.Output;
  };
  "com.atproto.admin.getAccountInfos": {
    params: ComAtprotoAdminGetAccountInfos.Params;
    output: ComAtprotoAdminGetAccountInfos.Output;
  };
  "com.atproto.admin.getInviteCodes": {
    params: ComAtprotoAdminGetInviteCodes.Params;
    output: ComAtprotoAdminGetInviteCodes.Output;
  };
  "com.atproto.admin.getSubjectStatus": {
    params: ComAtprotoAdminGetSubjectStatus.Params;
    output: ComAtprotoAdminGetSubjectStatus.Output;
  };
  "com.atproto.admin.searchAccounts": {
    params: ComAtprotoAdminSearchAccounts.Params;
    output: ComAtprotoAdminSearchAccounts.Output;
  };
  "com.atproto.identity.getRecommendedDidCredentials": {
    output: ComAtprotoIdentityGetRecommendedDidCredentials.Output;
  };
  "com.atproto.identity.resolveDid": {
    params: ComAtprotoIdentityResolveDid.Params;
    output: ComAtprotoIdentityResolveDid.Output;
  };
  "com.atproto.identity.resolveHandle": {
    params: ComAtprotoIdentityResolveHandle.Params;
    output: ComAtprotoIdentityResolveHandle.Output;
  };
  "com.atproto.identity.resolveIdentity": {
    params: ComAtprotoIdentityResolveIdentity.Params;
    output: ComAtprotoIdentityResolveIdentity.Output;
  };
  "com.atproto.label.queryLabels": {
    params: ComAtprotoLabelQueryLabels.Params;
    output: ComAtprotoLabelQueryLabels.Output;
  };
  "com.atproto.lexicon.resolveLexicon": {
    params: ComAtprotoLexiconResolveLexicon.Params;
    output: ComAtprotoLexiconResolveLexicon.Output;
  };
  "com.atproto.repo.describeRepo": {
    params: ComAtprotoRepoDescribeRepo.Params;
    output: ComAtprotoRepoDescribeRepo.Output;
  };
  "com.atproto.repo.getRecord": {
    params: ComAtprotoRepoGetRecord.Params;
    output: ComAtprotoRepoGetRecord.Output;
  };
  "com.atproto.repo.listMissingBlobs": {
    params: ComAtprotoRepoListMissingBlobs.Params;
    output: ComAtprotoRepoListMissingBlobs.Output;
  };
  "com.atproto.repo.listRecords": {
    params: ComAtprotoRepoListRecords.Params;
    output: ComAtprotoRepoListRecords.Output;
  };
  "com.atproto.server.checkAccountStatus": {
    output: ComAtprotoServerCheckAccountStatus.Output;
  };
  "com.atproto.server.describeServer": {
    output: ComAtprotoServerDescribeServer.Output;
  };
  "com.atproto.server.getAccountInviteCodes": {
    params: ComAtprotoServerGetAccountInviteCodes.Params;
    output: ComAtprotoServerGetAccountInviteCodes.Output;
  };
  "com.atproto.server.getServiceAuth": {
    params: ComAtprotoServerGetServiceAuth.Params;
    output: ComAtprotoServerGetServiceAuth.Output;
  };
  "com.atproto.server.getSession": {
    output: ComAtprotoServerGetSession.Output;
  };
  "com.atproto.server.listAppPasswords": {
    output: ComAtprotoServerListAppPasswords.Output;
  };
  "com.atproto.sync.getBlob": {
    params: ComAtprotoSyncGetBlob.Params;
    output: ComAtprotoSyncGetBlob.Output;
  };
  "com.atproto.sync.getBlocks": {
    params: ComAtprotoSyncGetBlocks.Params;
    output: ComAtprotoSyncGetBlocks.Output;
  };
  "com.atproto.sync.getCheckout": {
    params: ComAtprotoSyncGetCheckout.Params;
    output: ComAtprotoSyncGetCheckout.Output;
  };
  "com.atproto.sync.getHead": {
    params: ComAtprotoSyncGetHead.Params;
    output: ComAtprotoSyncGetHead.Output;
  };
  "com.atproto.sync.getHostStatus": {
    params: ComAtprotoSyncGetHostStatus.Params;
    output: ComAtprotoSyncGetHostStatus.Output;
  };
  "com.atproto.sync.getLatestCommit": {
    params: ComAtprotoSyncGetLatestCommit.Params;
    output: ComAtprotoSyncGetLatestCommit.Output;
  };
  "com.atproto.sync.getRecord": {
    params: ComAtprotoSyncGetRecord.Params;
    output: ComAtprotoSyncGetRecord.Output;
  };
  "com.atproto.sync.getRepo": {
    params: ComAtprotoSyncGetRepo.Params;
    output: ComAtprotoSyncGetRepo.Output;
  };
  "com.atproto.sync.getRepoStatus": {
    params: ComAtprotoSyncGetRepoStatus.Params;
    output: ComAtprotoSyncGetRepoStatus.Output;
  };
  "com.atproto.sync.listBlobs": {
    params: ComAtprotoSyncListBlobs.Params;
    output: ComAtprotoSyncListBlobs.Output;
  };
  "com.atproto.sync.listHosts": {
    params: ComAtprotoSyncListHosts.Params;
    output: ComAtprotoSyncListHosts.Output;
  };
  "com.atproto.sync.listRepos": {
    params: ComAtprotoSyncListRepos.Params;
    output: ComAtprotoSyncListRepos.Output;
  };
  "com.atproto.sync.listReposByCollection": {
    params: ComAtprotoSyncListReposByCollection.Params;
    output: ComAtprotoSyncListReposByCollection.Output;
  };
  "com.atproto.temp.checkHandleAvailability": {
    params: ComAtprotoTempCheckHandleAvailability.Params;
    output: ComAtprotoTempCheckHandleAvailability.Output;
  };
  "com.atproto.temp.checkSignupQueue": {
    output: ComAtprotoTempCheckSignupQueue.Output;
  };
  "com.atproto.temp.dereferenceScope": {
    params: ComAtprotoTempDereferenceScope.Params;
    output: ComAtprotoTempDereferenceScope.Output;
  };
  "com.atproto.temp.fetchLabels": {
    params: ComAtprotoTempFetchLabels.Params;
    output: ComAtprotoTempFetchLabels.Output;
  };
  "tools.ozone.communication.listTemplates": {
    output: ToolsOzoneCommunicationListTemplates.Output;
  };
  "tools.ozone.hosting.getAccountHistory": {
    params: ToolsOzoneHostingGetAccountHistory.Params;
    output: ToolsOzoneHostingGetAccountHistory.Output;
  };
  "tools.ozone.moderation.getAccountTimeline": {
    params: ToolsOzoneModerationGetAccountTimeline.Params;
    output: ToolsOzoneModerationGetAccountTimeline.Output;
  };
  "tools.ozone.moderation.getEvent": {
    params: ToolsOzoneModerationGetEvent.Params;
    output: ToolsOzoneModerationGetEvent.Output;
  };
  "tools.ozone.moderation.getRecord": {
    params: ToolsOzoneModerationGetRecord.Params;
    output: ToolsOzoneModerationGetRecord.Output;
  };
  "tools.ozone.moderation.getRecords": {
    params: ToolsOzoneModerationGetRecords.Params;
    output: ToolsOzoneModerationGetRecords.Output;
  };
  "tools.ozone.moderation.getRepo": {
    params: ToolsOzoneModerationGetRepo.Params;
    output: ToolsOzoneModerationGetRepo.Output;
  };
  "tools.ozone.moderation.getReporterStats": {
    params: ToolsOzoneModerationGetReporterStats.Params;
    output: ToolsOzoneModerationGetReporterStats.Output;
  };
  "tools.ozone.moderation.getRepos": {
    params: ToolsOzoneModerationGetRepos.Params;
    output: ToolsOzoneModerationGetRepos.Output;
  };
  "tools.ozone.moderation.getSubjects": {
    params: ToolsOzoneModerationGetSubjects.Params;
    output: ToolsOzoneModerationGetSubjects.Output;
  };
  "tools.ozone.moderation.queryEvents": {
    params: ToolsOzoneModerationQueryEvents.Params;
    output: ToolsOzoneModerationQueryEvents.Output;
  };
  "tools.ozone.moderation.queryStatuses": {
    params: ToolsOzoneModerationQueryStatuses.Params;
    output: ToolsOzoneModerationQueryStatuses.Output;
  };
  "tools.ozone.moderation.searchRepos": {
    params: ToolsOzoneModerationSearchRepos.Params;
    output: ToolsOzoneModerationSearchRepos.Output;
  };
  "tools.ozone.server.getConfig": {
    output: ToolsOzoneServerGetConfig.Output;
  };
  "tools.ozone.set.getValues": {
    params: ToolsOzoneSetGetValues.Params;
    output: ToolsOzoneSetGetValues.Output;
  };
  "tools.ozone.set.querySets": {
    params: ToolsOzoneSetQuerySets.Params;
    output: ToolsOzoneSetQuerySets.Output;
  };
  "tools.ozone.setting.listOptions": {
    params: ToolsOzoneSettingListOptions.Params;
    output: ToolsOzoneSettingListOptions.Output;
  };
  "tools.ozone.signature.findCorrelation": {
    params: ToolsOzoneSignatureFindCorrelation.Params;
    output: ToolsOzoneSignatureFindCorrelation.Output;
  };
  "tools.ozone.signature.findRelatedAccounts": {
    params: ToolsOzoneSignatureFindRelatedAccounts.Params;
    output: ToolsOzoneSignatureFindRelatedAccounts.Output;
  };
  "tools.ozone.signature.searchAccounts": {
    params: ToolsOzoneSignatureSearchAccounts.Params;
    output: ToolsOzoneSignatureSearchAccounts.Output;
  };
  "tools.ozone.team.listMembers": {
    params: ToolsOzoneTeamListMembers.Params;
    output: ToolsOzoneTeamListMembers.Output;
  };
  "tools.ozone.verification.listVerifications": {
    params: ToolsOzoneVerificationListVerifications.Params;
    output: ToolsOzoneVerificationListVerifications.Output;
  };
}

export declare interface Procedures {
  "app.bsky.actor.putPreferences": {
    input: AppBskyActorPutPreferences.Input;
  };
  "app.bsky.ageassurance.begin": {
    input: AppBskyAgeassuranceBegin.Input;
    output: AppBskyAgeassuranceBegin.Output;
  };
  "app.bsky.bookmark.createBookmark": {
    input: AppBskyBookmarkCreateBookmark.Input;
  };
  "app.bsky.bookmark.deleteBookmark": {
    input: AppBskyBookmarkDeleteBookmark.Input;
  };
  "app.bsky.contact.dismissMatch": {
    input: AppBskyContactDismissMatch.Input;
    output: AppBskyContactDismissMatch.Output;
  };
  "app.bsky.contact.importContacts": {
    input: AppBskyContactImportContacts.Input;
    output: AppBskyContactImportContacts.Output;
  };
  "app.bsky.contact.removeData": {
    input: AppBskyContactRemoveData.Input;
    output: AppBskyContactRemoveData.Output;
  };
  "app.bsky.contact.sendNotification": {
    input: AppBskyContactSendNotification.Input;
    output: AppBskyContactSendNotification.Output;
  };
  "app.bsky.contact.startPhoneVerification": {
    input: AppBskyContactStartPhoneVerification.Input;
    output: AppBskyContactStartPhoneVerification.Output;
  };
  "app.bsky.contact.verifyPhone": {
    input: AppBskyContactVerifyPhone.Input;
    output: AppBskyContactVerifyPhone.Output;
  };
  "app.bsky.draft.createDraft": {
    input: AppBskyDraftCreateDraft.Input;
    output: AppBskyDraftCreateDraft.Output;
  };
  "app.bsky.draft.deleteDraft": {
    input: AppBskyDraftDeleteDraft.Input;
  };
  "app.bsky.draft.updateDraft": {
    input: AppBskyDraftUpdateDraft.Input;
  };
  "app.bsky.feed.sendInteractions": {
    input: AppBskyFeedSendInteractions.Input;
    output: AppBskyFeedSendInteractions.Output;
  };
  "app.bsky.graph.muteActor": {
    input: AppBskyGraphMuteActor.Input;
  };
  "app.bsky.graph.muteActorList": {
    input: AppBskyGraphMuteActorList.Input;
  };
  "app.bsky.graph.muteThread": {
    input: AppBskyGraphMuteThread.Input;
  };
  "app.bsky.graph.unmuteActor": {
    input: AppBskyGraphUnmuteActor.Input;
  };
  "app.bsky.graph.unmuteActorList": {
    input: AppBskyGraphUnmuteActorList.Input;
  };
  "app.bsky.graph.unmuteThread": {
    input: AppBskyGraphUnmuteThread.Input;
  };
  "app.bsky.notification.putActivitySubscription": {
    input: AppBskyNotificationPutActivitySubscription.Input;
    output: AppBskyNotificationPutActivitySubscription.Output;
  };
  "app.bsky.notification.putPreferences": {
    input: AppBskyNotificationPutPreferences.Input;
  };
  "app.bsky.notification.putPreferencesV2": {
    input: AppBskyNotificationPutPreferencesV2.Input;
    output: AppBskyNotificationPutPreferencesV2.Output;
  };
  "app.bsky.notification.registerPush": {
    input: AppBskyNotificationRegisterPush.Input;
  };
  "app.bsky.notification.unregisterPush": {
    input: AppBskyNotificationUnregisterPush.Input;
  };
  "app.bsky.notification.updateSeen": {
    input: AppBskyNotificationUpdateSeen.Input;
  };
  "app.bsky.unspecced.initAgeAssurance": {
    input: AppBskyUnspeccedInitAgeAssurance.Input;
    output: AppBskyUnspeccedInitAgeAssurance.Output;
  };
  "app.bsky.video.uploadVideo": {
    input: AppBskyVideoUploadVideo.Input;
    output: AppBskyVideoUploadVideo.Output;
  };
  "chat.bsky.actor.deleteAccount": {
    output: ChatBskyActorDeleteAccount.Output;
  };
  "chat.bsky.convo.acceptConvo": {
    input: ChatBskyConvoAcceptConvo.Input;
    output: ChatBskyConvoAcceptConvo.Output;
  };
  "chat.bsky.convo.addReaction": {
    input: ChatBskyConvoAddReaction.Input;
    output: ChatBskyConvoAddReaction.Output;
  };
  "chat.bsky.convo.deleteMessageForSelf": {
    input: ChatBskyConvoDeleteMessageForSelf.Input;
    output: ChatBskyConvoDeleteMessageForSelf.Output;
  };
  "chat.bsky.convo.leaveConvo": {
    input: ChatBskyConvoLeaveConvo.Input;
    output: ChatBskyConvoLeaveConvo.Output;
  };
  "chat.bsky.convo.muteConvo": {
    input: ChatBskyConvoMuteConvo.Input;
    output: ChatBskyConvoMuteConvo.Output;
  };
  "chat.bsky.convo.removeReaction": {
    input: ChatBskyConvoRemoveReaction.Input;
    output: ChatBskyConvoRemoveReaction.Output;
  };
  "chat.bsky.convo.sendMessage": {
    input: ChatBskyConvoSendMessage.Input;
    output: ChatBskyConvoSendMessage.Output;
  };
  "chat.bsky.convo.sendMessageBatch": {
    input: ChatBskyConvoSendMessageBatch.Input;
    output: ChatBskyConvoSendMessageBatch.Output;
  };
  "chat.bsky.convo.unmuteConvo": {
    input: ChatBskyConvoUnmuteConvo.Input;
    output: ChatBskyConvoUnmuteConvo.Output;
  };
  "chat.bsky.convo.updateAllRead": {
    input: ChatBskyConvoUpdateAllRead.Input;
    output: ChatBskyConvoUpdateAllRead.Output;
  };
  "chat.bsky.convo.updateRead": {
    input: ChatBskyConvoUpdateRead.Input;
    output: ChatBskyConvoUpdateRead.Output;
  };
  "chat.bsky.moderation.updateActorAccess": {
    input: ChatBskyModerationUpdateActorAccess.Input;
  };
  "com.atproto.admin.deleteAccount": {
    input: ComAtprotoAdminDeleteAccount.Input;
  };
  "com.atproto.admin.disableAccountInvites": {
    input: ComAtprotoAdminDisableAccountInvites.Input;
  };
  "com.atproto.admin.disableInviteCodes": {
    input: ComAtprotoAdminDisableInviteCodes.Input;
  };
  "com.atproto.admin.enableAccountInvites": {
    input: ComAtprotoAdminEnableAccountInvites.Input;
  };
  "com.atproto.admin.sendEmail": {
    input: ComAtprotoAdminSendEmail.Input;
    output: ComAtprotoAdminSendEmail.Output;
  };
  "com.atproto.admin.updateAccountEmail": {
    input: ComAtprotoAdminUpdateAccountEmail.Input;
  };
  "com.atproto.admin.updateAccountHandle": {
    input: ComAtprotoAdminUpdateAccountHandle.Input;
  };
  "com.atproto.admin.updateAccountPassword": {
    input: ComAtprotoAdminUpdateAccountPassword.Input;
  };
  "com.atproto.admin.updateAccountSigningKey": {
    input: ComAtprotoAdminUpdateAccountSigningKey.Input;
  };
  "com.atproto.admin.updateSubjectStatus": {
    input: ComAtprotoAdminUpdateSubjectStatus.Input;
    output: ComAtprotoAdminUpdateSubjectStatus.Output;
  };
  "com.atproto.identity.refreshIdentity": {
    input: ComAtprotoIdentityRefreshIdentity.Input;
    output: ComAtprotoIdentityRefreshIdentity.Output;
  };
  "com.atproto.identity.requestPlcOperationSignature": {};
  "com.atproto.identity.signPlcOperation": {
    input: ComAtprotoIdentitySignPlcOperation.Input;
    output: ComAtprotoIdentitySignPlcOperation.Output;
  };
  "com.atproto.identity.submitPlcOperation": {
    input: ComAtprotoIdentitySubmitPlcOperation.Input;
  };
  "com.atproto.identity.updateHandle": {
    input: ComAtprotoIdentityUpdateHandle.Input;
  };
  "com.atproto.moderation.createReport": {
    input: ComAtprotoModerationCreateReport.Input;
    output: ComAtprotoModerationCreateReport.Output;
  };
  "com.atproto.repo.applyWrites": {
    input: ComAtprotoRepoApplyWrites.Input;
    output: ComAtprotoRepoApplyWrites.Output;
  };
  "com.atproto.repo.createRecord": {
    input: ComAtprotoRepoCreateRecord.Input;
    output: ComAtprotoRepoCreateRecord.Output;
  };
  "com.atproto.repo.deleteRecord": {
    input: ComAtprotoRepoDeleteRecord.Input;
    output: ComAtprotoRepoDeleteRecord.Output;
  };
  "com.atproto.repo.importRepo": {
    input: ComAtprotoRepoImportRepo.Input;
  };
  "com.atproto.repo.putRecord": {
    input: ComAtprotoRepoPutRecord.Input;
    output: ComAtprotoRepoPutRecord.Output;
  };
  "com.atproto.repo.uploadBlob": {
    input: ComAtprotoRepoUploadBlob.Input;
    output: ComAtprotoRepoUploadBlob.Output;
  };
  "com.atproto.server.activateAccount": {};
  "com.atproto.server.confirmEmail": {
    input: ComAtprotoServerConfirmEmail.Input;
  };
  "com.atproto.server.createAccount": {
    input: ComAtprotoServerCreateAccount.Input;
    output: ComAtprotoServerCreateAccount.Output;
  };
  "com.atproto.server.createAppPassword": {
    input: ComAtprotoServerCreateAppPassword.Input;
    output: ComAtprotoServerCreateAppPassword.Output;
  };
  "com.atproto.server.createInviteCode": {
    input: ComAtprotoServerCreateInviteCode.Input;
    output: ComAtprotoServerCreateInviteCode.Output;
  };
  "com.atproto.server.createInviteCodes": {
    input: ComAtprotoServerCreateInviteCodes.Input;
    output: ComAtprotoServerCreateInviteCodes.Output;
  };
  "com.atproto.server.createSession": {
    input: ComAtprotoServerCreateSession.Input;
    output: ComAtprotoServerCreateSession.Output;
  };
  "com.atproto.server.deactivateAccount": {
    input: ComAtprotoServerDeactivateAccount.Input;
  };
  "com.atproto.server.deleteAccount": {
    input: ComAtprotoServerDeleteAccount.Input;
  };
  "com.atproto.server.deleteSession": {};
  "com.atproto.server.refreshSession": {
    output: ComAtprotoServerRefreshSession.Output;
  };
  "com.atproto.server.requestAccountDelete": {};
  "com.atproto.server.requestEmailConfirmation": {};
  "com.atproto.server.requestEmailUpdate": {
    output: ComAtprotoServerRequestEmailUpdate.Output;
  };
  "com.atproto.server.requestPasswordReset": {
    input: ComAtprotoServerRequestPasswordReset.Input;
  };
  "com.atproto.server.reserveSigningKey": {
    input: ComAtprotoServerReserveSigningKey.Input;
    output: ComAtprotoServerReserveSigningKey.Output;
  };
  "com.atproto.server.resetPassword": {
    input: ComAtprotoServerResetPassword.Input;
  };
  "com.atproto.server.revokeAppPassword": {
    input: ComAtprotoServerRevokeAppPassword.Input;
  };
  "com.atproto.server.updateEmail": {
    input: ComAtprotoServerUpdateEmail.Input;
  };
  "com.atproto.sync.notifyOfUpdate": {
    input: ComAtprotoSyncNotifyOfUpdate.Input;
  };
  "com.atproto.sync.requestCrawl": {
    input: ComAtprotoSyncRequestCrawl.Input;
  };
  "com.atproto.temp.addReservedHandle": {
    input: ComAtprotoTempAddReservedHandle.Input;
    output: ComAtprotoTempAddReservedHandle.Output;
  };
  "com.atproto.temp.requestPhoneVerification": {
    input: ComAtprotoTempRequestPhoneVerification.Input;
  };
  "com.atproto.temp.revokeAccountCredentials": {
    input: ComAtprotoTempRevokeAccountCredentials.Input;
  };
  "tools.ozone.communication.createTemplate": {
    input: ToolsOzoneCommunicationCreateTemplate.Input;
    output: ToolsOzoneCommunicationCreateTemplate.Output;
  };
  "tools.ozone.communication.deleteTemplate": {
    input: ToolsOzoneCommunicationDeleteTemplate.Input;
  };
  "tools.ozone.communication.updateTemplate": {
    input: ToolsOzoneCommunicationUpdateTemplate.Input;
    output: ToolsOzoneCommunicationUpdateTemplate.Output;
  };
  "tools.ozone.moderation.cancelScheduledActions": {
    input: ToolsOzoneModerationCancelScheduledActions.Input;
    output: ToolsOzoneModerationCancelScheduledActions.Output;
  };
  "tools.ozone.moderation.emitEvent": {
    input: ToolsOzoneModerationEmitEvent.Input;
    output: ToolsOzoneModerationEmitEvent.Output;
  };
  "tools.ozone.moderation.listScheduledActions": {
    input: ToolsOzoneModerationListScheduledActions.Input;
    output: ToolsOzoneModerationListScheduledActions.Output;
  };
  "tools.ozone.moderation.scheduleAction": {
    input: ToolsOzoneModerationScheduleAction.Input;
    output: ToolsOzoneModerationScheduleAction.Output;
  };
  "tools.ozone.safelink.addRule": {
    input: ToolsOzoneSafelinkAddRule.Input;
    output: ToolsOzoneSafelinkAddRule.Output;
  };
  "tools.ozone.safelink.queryEvents": {
    input: ToolsOzoneSafelinkQueryEvents.Input;
    output: ToolsOzoneSafelinkQueryEvents.Output;
  };
  "tools.ozone.safelink.queryRules": {
    input: ToolsOzoneSafelinkQueryRules.Input;
    output: ToolsOzoneSafelinkQueryRules.Output;
  };
  "tools.ozone.safelink.removeRule": {
    input: ToolsOzoneSafelinkRemoveRule.Input;
    output: ToolsOzoneSafelinkRemoveRule.Output;
  };
  "tools.ozone.safelink.updateRule": {
    input: ToolsOzoneSafelinkUpdateRule.Input;
    output: ToolsOzoneSafelinkUpdateRule.Output;
  };
  "tools.ozone.set.addValues": {
    input: ToolsOzoneSetAddValues.Input;
  };
  "tools.ozone.set.deleteSet": {
    input: ToolsOzoneSetDeleteSet.Input;
    output: ToolsOzoneSetDeleteSet.Output;
  };
  "tools.ozone.set.deleteValues": {
    input: ToolsOzoneSetDeleteValues.Input;
  };
  "tools.ozone.set.upsertSet": {
    input: ToolsOzoneSetUpsertSet.Input;
    output: ToolsOzoneSetUpsertSet.Output;
  };
  "tools.ozone.setting.removeOptions": {
    input: ToolsOzoneSettingRemoveOptions.Input;
    output: ToolsOzoneSettingRemoveOptions.Output;
  };
  "tools.ozone.setting.upsertOption": {
    input: ToolsOzoneSettingUpsertOption.Input;
    output: ToolsOzoneSettingUpsertOption.Output;
  };
  "tools.ozone.team.addMember": {
    input: ToolsOzoneTeamAddMember.Input;
    output: ToolsOzoneTeamAddMember.Output;
  };
  "tools.ozone.team.deleteMember": {
    input: ToolsOzoneTeamDeleteMember.Input;
  };
  "tools.ozone.team.updateMember": {
    input: ToolsOzoneTeamUpdateMember.Input;
    output: ToolsOzoneTeamUpdateMember.Output;
  };
  "tools.ozone.verification.grantVerifications": {
    input: ToolsOzoneVerificationGrantVerifications.Input;
    output: ToolsOzoneVerificationGrantVerifications.Output;
  };
  "tools.ozone.verification.revokeVerifications": {
    input: ToolsOzoneVerificationRevokeVerifications.Input;
    output: ToolsOzoneVerificationRevokeVerifications.Output;
  };
}

export declare interface Subscriptions {
  "com.atproto.label.subscribeLabels": {
    params: ComAtprotoLabelSubscribeLabels.Params;
    message: ComAtprotoLabelSubscribeLabels.Message;
    errors: ComAtprotoLabelSubscribeLabels.Errors;
  };
  "com.atproto.sync.subscribeRepos": {
    params: ComAtprotoSyncSubscribeRepos.Params;
    message: ComAtprotoSyncSubscribeRepos.Message;
    errors: ComAtprotoSyncSubscribeRepos.Errors;
  };
}
