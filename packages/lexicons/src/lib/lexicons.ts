/* eslint-disable */
// This file is automatically generated by @tsky/lex-cli, do not edit!

/**
 * @module
 * Contains type declarations for Bluesky lexicons
 * @generated
 * Generated on: 2025-03-08T03:21:38.181Z
 * Version: main
 * Source: https://github.com/bluesky-social/atproto/tree/18fbfa00057dda9ef4eba77d8b4e87994893c952/lexicons
 */

/** Base type with optional type field */
export interface TypedBase {
  $type?: string;
}

/** Base type for all record types */
export interface RecordBase {
  $type: string;
}

/** Makes $type required and specific */
export type Typed<T extends TypedBase, Type extends string> = Omit<
  T,
  "$type"
> & {
  $type: Type;
};

/** Creates a union of objects discriminated by $type */
export type TypeUnion<T extends TypedBase> = T extends any
  ? Typed<T, string>
  : never;

/** Type guard for records */
export function isRecord(value: unknown): value is RecordBase {
  return (
    typeof value === "object" &&
    value !== null &&
    "$type" in value &&
    typeof value.$type === "string"
  );
}

/** Base AT Protocol schema types */
export declare namespace At {
  /** CID string */
  type CID = string;

  /** DID of a user */
  type DID = `did:${string}`;

  /** User handle */
  type Handle = string;

  /** URI string */
  type Uri = string;

  /** TID string */
  type TID = string;

  /** RKEY string */
  type RKEY = string;

  /** Object containing a CID string */
  interface CIDLink {
    $link: CID;
  }

  /** Object containing a base64-encoded bytes */
  interface Bytes {
    $bytes: string;
  }

  /** Blob interface */
  interface Blob<T extends string = string> extends RecordBase {
    $type: "blob";
    mimeType: T;
    ref: {
      $link: string;
    };
    size: number;
  }
}
export declare namespace AppBskyActorDefs {
  interface AdultContentPref extends TypedBase {
    /** \@default false */
    enabled: boolean;
  }
  /** If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress. */
  interface BskyAppProgressGuide extends TypedBase {
    /** Maximum string length: 100 */
    guide: string;
  }
  /** A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this. */
  interface BskyAppStatePref extends TypedBase {
    activeProgressGuide?: BskyAppProgressGuide;
    /**
     * Storage for NUXs the user has encountered.
     * Maximum array length: 100
     */
    nuxs?: AppBskyActorDefs.Nux[];
    /**
     * An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.
     * Maximum array length: 1000
     * Maximum string length: 100
     */
    queuedNudges?: string[];
  }
  interface ContentLabelPref extends TypedBase {
    label: string;
    visibility: "hide" | "ignore" | "show" | "warn" | (string & {});
    /** Which labeler does this preference apply to? If undefined, applies globally. */
    labelerDid?: At.DID;
  }
  interface FeedViewPref extends TypedBase {
    /** The URI of the feed, or an identifier which describes the feed. */
    feed: string;
    /** Hide quote posts in the feed. */
    hideQuotePosts?: boolean;
    /** Hide replies in the feed. */
    hideReplies?: boolean;
    /** Hide replies in the feed if they do not have this number of likes. */
    hideRepliesByLikeCount?: number;
    /**
     * Hide replies in the feed if they are not by followed users.
     * \@default true
     */
    hideRepliesByUnfollowed?: boolean;
    /** Hide reposts in the feed. */
    hideReposts?: boolean;
  }
  interface HiddenPostsPref extends TypedBase {
    /** A list of URIs of posts the account owner has hidden. */
    items: At.Uri[];
  }
  interface InterestsPref extends TypedBase {
    /**
     * A list of tags which describe the account owner's interests gathered during onboarding.
     * Maximum array length: 100
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tags: string[];
  }
  /** The subject's followers whom you also follow */
  interface KnownFollowers extends TypedBase {
    count: number;
    /**
     * Minimum array length: 0
     * Maximum array length: 5
     */
    followers: ProfileViewBasic[];
  }
  interface LabelerPrefItem extends TypedBase {
    did: At.DID;
  }
  interface LabelersPref extends TypedBase {
    labelers: LabelerPrefItem[];
  }
  /** A word that the account owner has muted. */
  interface MutedWord extends TypedBase {
    /** The intended targets of the muted word. */
    targets: AppBskyActorDefs.MutedWordTarget[];
    /**
     * The muted word itself.
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    value: string;
    /**
     * Groups of users to apply the muted word to. If undefined, applies to all users.
     * \@default "all"
     */
    actorTarget?: "all" | "exclude-following" | (string & {});
    /** The date and time at which the muted word will expire and no longer be applied. */
    expiresAt?: string;
    id?: string;
  }
  interface MutedWordsPref extends TypedBase {
    /** A list of words the account owner has muted. */
    items: AppBskyActorDefs.MutedWord[];
  }
  /**
   * Maximum string length: 640
   * Maximum grapheme length: 64
   */
  type MutedWordTarget = "content" | "tag" | (string & {});
  /** A new user experiences (NUX) storage object */
  interface Nux extends TypedBase {
    /** \@default false */
    completed: boolean;
    /** Maximum string length: 100 */
    id: string;
    /**
     * Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    data?: string;
    /** The date and time at which the NUX will expire and should be considered completed. */
    expiresAt?: string;
  }
  interface PersonalDetailsPref extends TypedBase {
    /** The birth date of account owner. */
    birthDate?: string;
  }
  /** Default post interaction settings for the account. These values should be applied as default values when creating new posts. These refs should mirror the threadgate and postgate records exactly. */
  interface PostInteractionSettingsPref extends TypedBase {
    /**
     * Matches postgate record. List of rules defining who can embed this users posts. If value is an empty array or is undefined, no particular rules apply and anyone can embed.
     * Maximum array length: 5
     */
    postgateEmbeddingRules?: TypeUnion<AppBskyFeedPostgate.DisableRule>[];
    /**
     * Matches threadgate record. List of rules defining who can reply to this users posts. If value is an empty array, no one can reply. If value is undefined, anyone can reply.
     * Maximum array length: 5
     */
    threadgateAllowRules?: TypeUnion<
      | AppBskyFeedThreadgate.FollowerRule
      | AppBskyFeedThreadgate.FollowingRule
      | AppBskyFeedThreadgate.ListRule
      | AppBskyFeedThreadgate.MentionRule
    >[];
  }
  type Preferences = TypeUnion<
    | AdultContentPref
    | BskyAppStatePref
    | ContentLabelPref
    | FeedViewPref
    | HiddenPostsPref
    | InterestsPref
    | LabelersPref
    | MutedWordsPref
    | PersonalDetailsPref
    | PostInteractionSettingsPref
    | SavedFeedsPref
    | SavedFeedsPrefV2
    | ThreadViewPref
  >[];
  interface ProfileAssociated extends TypedBase {
    chat?: ProfileAssociatedChat;
    feedgens?: number;
    labeler?: boolean;
    lists?: number;
    starterPacks?: number;
  }
  interface ProfileAssociatedChat extends TypedBase {
    allowIncoming: "all" | "following" | "none" | (string & {});
  }
  interface ProfileView extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    createdAt?: string;
    /**
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    indexedAt?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    viewer?: ViewerState;
  }
  interface ProfileViewBasic extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    createdAt?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    viewer?: ViewerState;
  }
  interface ProfileViewDetailed extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: ProfileAssociated;
    avatar?: string;
    banner?: string;
    createdAt?: string;
    /**
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    followersCount?: number;
    followsCount?: number;
    indexedAt?: string;
    joinedViaStarterPack?: AppBskyGraphDefs.StarterPackViewBasic;
    labels?: ComAtprotoLabelDefs.Label[];
    pinnedPost?: ComAtprotoRepoStrongRef.Main;
    postsCount?: number;
    viewer?: ViewerState;
  }
  interface SavedFeed extends TypedBase {
    id: string;
    pinned: boolean;
    type: "feed" | "list" | "timeline" | (string & {});
    value: string;
  }
  interface SavedFeedsPref extends TypedBase {
    pinned: At.Uri[];
    saved: At.Uri[];
    timelineIndex?: number;
  }
  interface SavedFeedsPrefV2 extends TypedBase {
    items: AppBskyActorDefs.SavedFeed[];
  }
  interface ThreadViewPref extends TypedBase {
    /** Show followed users at the top of all replies. */
    prioritizeFollowedUsers?: boolean;
    /** Sorting mode for threads. */
    sort?:
      | "hotness"
      | "most-likes"
      | "newest"
      | "oldest"
      | "random"
      | (string & {});
  }
  /** Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests. */
  interface ViewerState extends TypedBase {
    blockedBy?: boolean;
    blocking?: At.Uri;
    blockingByList?: AppBskyGraphDefs.ListViewBasic;
    followedBy?: At.Uri;
    following?: At.Uri;
    knownFollowers?: KnownFollowers;
    muted?: boolean;
    mutedByList?: AppBskyGraphDefs.ListViewBasic;
  }
}

/** Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth. */
export declare namespace AppBskyActorGetPreferences {
  type Input = undefined;
  interface Output extends TypedBase {
    preferences: AppBskyActorDefs.Preferences;
  }
}

/** Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth. */
export declare namespace AppBskyActorGetProfile {
  interface Params extends TypedBase {
    /** Handle or DID of account to fetch profile of. */
    actor: string;
  }
  type Input = undefined;
  type Output = AppBskyActorDefs.ProfileViewDetailed;
}

/** Get detailed profile views of multiple actors. */
export declare namespace AppBskyActorGetProfiles {
  interface Params extends TypedBase {
    /** Maximum array length: 25 */
    actors: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    profiles: AppBskyActorDefs.ProfileViewDetailed[];
  }
}

/** Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding. */
export declare namespace AppBskyActorGetSuggestions {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileView[];
    cursor?: string;
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: number;
  }
}

export declare namespace AppBskyActorProfile {
  /** A declaration of a Bluesky account profile. */
  interface Record extends RecordBase {
    $type: "app.bsky.actor.profile";
    /** Small image to be displayed next to posts from account. AKA, 'profile picture' */
    avatar?: At.Blob;
    /** Larger horizontal image to display behind profile view. */
    banner?: At.Blob;
    createdAt?: string;
    /**
     * Free-form profile description text.
     * Maximum string length: 2560
     * Maximum grapheme length: 256
     */
    description?: string;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    joinedViaStarterPack?: ComAtprotoRepoStrongRef.Main;
    /** Self-label values, specific to the Bluesky application, on the overall account. */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
    pinnedPost?: ComAtprotoRepoStrongRef.Main;
  }
}

/** Set the private preferences attached to the account. */
export declare namespace AppBskyActorPutPreferences {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    preferences: AppBskyActorDefs.Preferences;
  }
  type Output = undefined;
}

/** Find actors (profiles) matching search criteria. Does not require auth. */
export declare namespace AppBskyActorSearchActors {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q?: string;
    /**
     * DEPRECATED: use 'q' instead.
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth. */
export declare namespace AppBskyActorSearchActorsTypeahead {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 10
     */
    limit?: number;
    /** Search query prefix; not a full query string. */
    q?: string;
    /**
     * DEPRECATED: use 'q' instead.
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyActorDefs.ProfileViewBasic[];
  }
}

export declare namespace AppBskyEmbedDefs {
  /** width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit. */
  interface AspectRatio extends TypedBase {
    /** Minimum: 1 */
    height: number;
    /** Minimum: 1 */
    width: number;
  }
}

export declare namespace AppBskyEmbedExternal {
  /** A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post). */
  interface Main extends TypedBase {
    external: External;
  }
  interface External extends TypedBase {
    description: string;
    title: string;
    uri: string;
    thumb?: At.Blob;
  }
  interface View extends TypedBase {
    external: ViewExternal;
  }
  interface ViewExternal extends TypedBase {
    description: string;
    title: string;
    uri: string;
    thumb?: string;
  }
}

export declare namespace AppBskyEmbedImages {
  interface Main extends TypedBase {
    /** Maximum array length: 4 */
    images: Image[];
  }
  interface Image extends TypedBase {
    /** Alt text description of the image, for accessibility. */
    alt: string;
    image: At.Blob;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
  }
  interface View extends TypedBase {
    /** Maximum array length: 4 */
    images: ViewImage[];
  }
  interface ViewImage extends TypedBase {
    /** Alt text description of the image, for accessibility. */
    alt: string;
    /** Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View. */
    fullsize: string;
    /** Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View. */
    thumb: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
  }
}

export declare namespace AppBskyEmbedRecord {
  interface Main extends TypedBase {
    record: ComAtprotoRepoStrongRef.Main;
  }
  interface View extends TypedBase {
    record: TypeUnion<
      | ViewBlocked
      | ViewDetached
      | ViewNotFound
      | ViewRecord
      | AppBskyFeedDefs.GeneratorView
      | AppBskyGraphDefs.ListView
      | AppBskyGraphDefs.StarterPackViewBasic
      | AppBskyLabelerDefs.LabelerView
    >;
  }
  interface ViewBlocked extends TypedBase {
    author: AppBskyFeedDefs.BlockedAuthor;
    blocked: boolean;
    uri: At.Uri;
  }
  interface ViewDetached extends TypedBase {
    detached: boolean;
    uri: At.Uri;
  }
  interface ViewNotFound extends TypedBase {
    notFound: boolean;
    uri: At.Uri;
  }
  interface ViewRecord extends TypedBase {
    author: AppBskyActorDefs.ProfileViewBasic;
    cid: At.CID;
    indexedAt: string;
    uri: At.Uri;
    /** The record data itself. */
    value: unknown;
    embeds?: TypeUnion<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedRecord.View
      | AppBskyEmbedRecordWithMedia.View
      | AppBskyEmbedVideo.View
    >[];
    labels?: ComAtprotoLabelDefs.Label[];
    likeCount?: number;
    quoteCount?: number;
    replyCount?: number;
    repostCount?: number;
  }
}

export declare namespace AppBskyEmbedRecordWithMedia {
  interface Main extends TypedBase {
    media: TypeUnion<
      | AppBskyEmbedExternal.Main
      | AppBskyEmbedImages.Main
      | AppBskyEmbedVideo.Main
    >;
    record: AppBskyEmbedRecord.Main;
  }
  interface View extends TypedBase {
    media: TypeUnion<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedVideo.View
    >;
    record: AppBskyEmbedRecord.View;
  }
}

export declare namespace AppBskyEmbedVideo {
  interface Main extends TypedBase {
    /** The mp4 video file. May be up to 100mb, formerly limited to 50mb. */
    video: At.Blob;
    /**
     * Alt text description of the video, for accessibility.
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    alt?: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
    /** Maximum array length: 20 */
    captions?: Caption[];
  }
  interface Caption extends TypedBase {
    file: At.Blob;
    lang: string;
  }
  interface View extends TypedBase {
    cid: At.CID;
    playlist: string;
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    alt?: string;
    aspectRatio?: AppBskyEmbedDefs.AspectRatio;
    thumbnail?: string;
  }
}

export declare namespace AppBskyFeedDefs {
  interface BlockedAuthor extends TypedBase {
    did: At.DID;
    viewer?: AppBskyActorDefs.ViewerState;
  }
  interface BlockedPost extends TypedBase {
    author: BlockedAuthor;
    blocked: boolean;
    uri: At.Uri;
  }
  type ClickthroughAuthor = "app.bsky.feed.defs#clickthroughAuthor";
  type ClickthroughEmbed = "app.bsky.feed.defs#clickthroughEmbed";
  type ClickthroughItem = "app.bsky.feed.defs#clickthroughItem";
  type ClickthroughReposter = "app.bsky.feed.defs#clickthroughReposter";
  type ContentModeUnspecified = "app.bsky.feed.defs#contentModeUnspecified";
  type ContentModeVideo = "app.bsky.feed.defs#contentModeVideo";
  interface FeedViewPost extends TypedBase {
    post: PostView;
    /**
     * Context provided by feed generator that may be passed back alongside interactions.
     * Maximum string length: 2000
     */
    feedContext?: string;
    reason?: TypeUnion<ReasonPin | ReasonRepost>;
    reply?: ReplyRef;
  }
  interface GeneratorView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    did: At.DID;
    displayName: string;
    indexedAt: string;
    uri: At.Uri;
    acceptsInteractions?: boolean;
    avatar?: string;
    contentMode?:
      | "app.bsky.feed.defs#contentModeUnspecified"
      | "app.bsky.feed.defs#contentModeVideo"
      | (string & {});
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: GeneratorViewerState;
  }
  interface GeneratorViewerState extends TypedBase {
    like?: At.Uri;
  }
  interface Interaction extends TypedBase {
    event?:
      | "app.bsky.feed.defs#clickthroughAuthor"
      | "app.bsky.feed.defs#clickthroughEmbed"
      | "app.bsky.feed.defs#clickthroughItem"
      | "app.bsky.feed.defs#clickthroughReposter"
      | "app.bsky.feed.defs#interactionLike"
      | "app.bsky.feed.defs#interactionQuote"
      | "app.bsky.feed.defs#interactionReply"
      | "app.bsky.feed.defs#interactionRepost"
      | "app.bsky.feed.defs#interactionSeen"
      | "app.bsky.feed.defs#interactionShare"
      | "app.bsky.feed.defs#requestLess"
      | "app.bsky.feed.defs#requestMore"
      | (string & {});
    /**
     * Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.
     * Maximum string length: 2000
     */
    feedContext?: string;
    item?: At.Uri;
  }
  type InteractionLike = "app.bsky.feed.defs#interactionLike";
  type InteractionQuote = "app.bsky.feed.defs#interactionQuote";
  type InteractionReply = "app.bsky.feed.defs#interactionReply";
  type InteractionRepost = "app.bsky.feed.defs#interactionRepost";
  type InteractionSeen = "app.bsky.feed.defs#interactionSeen";
  type InteractionShare = "app.bsky.feed.defs#interactionShare";
  interface NotFoundPost extends TypedBase {
    notFound: boolean;
    uri: At.Uri;
  }
  interface PostView extends TypedBase {
    author: AppBskyActorDefs.ProfileViewBasic;
    cid: At.CID;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    embed?: TypeUnion<
      | AppBskyEmbedExternal.View
      | AppBskyEmbedImages.View
      | AppBskyEmbedRecord.View
      | AppBskyEmbedRecordWithMedia.View
      | AppBskyEmbedVideo.View
    >;
    labels?: ComAtprotoLabelDefs.Label[];
    likeCount?: number;
    quoteCount?: number;
    replyCount?: number;
    repostCount?: number;
    threadgate?: ThreadgateView;
    viewer?: ViewerState;
  }
  interface ReasonPin extends TypedBase {}
  interface ReasonRepost extends TypedBase {
    by: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
  }
  interface ReplyRef extends TypedBase {
    parent: TypeUnion<BlockedPost | NotFoundPost | PostView>;
    root: TypeUnion<BlockedPost | NotFoundPost | PostView>;
    /** When parent is a reply to another post, this is the author of that post. */
    grandparentAuthor?: AppBskyActorDefs.ProfileViewBasic;
  }
  type RequestLess = "app.bsky.feed.defs#requestLess";
  type RequestMore = "app.bsky.feed.defs#requestMore";
  interface SkeletonFeedPost extends TypedBase {
    post: At.Uri;
    /**
     * Context that will be passed through to client and may be passed to feed generator back alongside interactions.
     * Maximum string length: 2000
     */
    feedContext?: string;
    reason?: TypeUnion<SkeletonReasonPin | SkeletonReasonRepost>;
  }
  interface SkeletonReasonPin extends TypedBase {}
  interface SkeletonReasonRepost extends TypedBase {
    repost: At.Uri;
  }
  /** Metadata about this post within the context of the thread it is in. */
  interface ThreadContext extends TypedBase {
    rootAuthorLike?: At.Uri;
  }
  interface ThreadgateView extends TypedBase {
    cid?: At.CID;
    lists?: AppBskyGraphDefs.ListViewBasic[];
    record?: unknown;
    uri?: At.Uri;
  }
  interface ThreadViewPost extends TypedBase {
    post: PostView;
    parent?: TypeUnion<BlockedPost | NotFoundPost | ThreadViewPost>;
    replies?: TypeUnion<BlockedPost | NotFoundPost | ThreadViewPost>[];
    threadContext?: ThreadContext;
  }
  /** Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests. */
  interface ViewerState extends TypedBase {
    embeddingDisabled?: boolean;
    like?: At.Uri;
    pinned?: boolean;
    replyDisabled?: boolean;
    repost?: At.Uri;
    threadMuted?: boolean;
  }
}

/** Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View). */
export declare namespace AppBskyFeedDescribeFeedGenerator {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    did: At.DID;
    feeds: Feed[];
    links?: Links;
  }
  interface Feed extends TypedBase {
    uri: At.Uri;
  }
  interface Links extends TypedBase {
    privacyPolicy?: string;
    termsOfService?: string;
  }
}

export declare namespace AppBskyFeedGenerator {
  /** Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.generator";
    createdAt: string;
    did: At.DID;
    /**
     * Maximum string length: 240
     * Maximum grapheme length: 24
     */
    displayName: string;
    /** Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions */
    acceptsInteractions?: boolean;
    avatar?: At.Blob;
    contentMode?:
      | "app.bsky.feed.defs#contentModeUnspecified"
      | "app.bsky.feed.defs#contentModeVideo"
      | (string & {});
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    /** Self-label values */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
  }
}

/** Get a list of feeds (feed generator records) created by the actor (in the actor's repo). */
export declare namespace AppBskyFeedGetActorFeeds {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a list of posts liked by an actor. Requires auth, actor must be the requesting account. */
export declare namespace AppBskyFeedGetActorLikes {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    BlockedActor: {};
    BlockedByActor: {};
  }
}

/** Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth. */
export declare namespace AppBskyFeedGetAuthorFeed {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Combinations of post/repost types to include in response.
     * \@default "posts_with_replies"
     */
    filter?:
      | "posts_and_author_threads"
      | "posts_no_replies"
      | "posts_with_media"
      | "posts_with_replies"
      | "posts_with_video"
      | (string & {});
    /** \@default false */
    includePins?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    BlockedActor: {};
    BlockedByActor: {};
  }
}

/** Get a hydrated feed from an actor's selected feed generator. Implemented by App View. */
export declare namespace AppBskyFeedGetFeed {
  interface Params extends TypedBase {
    feed: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    UnknownFeed: {};
  }
}

/** Get information about a feed generator. Implemented by AppView. */
export declare namespace AppBskyFeedGetFeedGenerator {
  interface Params extends TypedBase {
    /** AT-URI of the feed generator record. */
    feed: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** Indicates whether the feed generator service has been online recently, or else seems to be inactive. */
    isOnline: boolean;
    /** Indicates whether the feed generator service is compatible with the record declaration. */
    isValid: boolean;
    view: AppBskyFeedDefs.GeneratorView;
  }
}

/** Get information about a list of feed generators. */
export declare namespace AppBskyFeedGetFeedGenerators {
  interface Params extends TypedBase {
    feeds: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
  }
}

/** Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service. */
export declare namespace AppBskyFeedGetFeedSkeleton {
  interface Params extends TypedBase {
    /** Reference to feed generator record describing the specific feed being requested. */
    feed: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.SkeletonFeedPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    UnknownFeed: {};
  }
}

/** Get like records which reference a subject (by AT-URI and CID). */
export declare namespace AppBskyFeedGetLikes {
  interface Params extends TypedBase {
    /** AT-URI of the subject (eg, a post record). */
    uri: At.Uri;
    /** CID of the subject record (aka, specific version of record), to filter likes. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    likes: Like[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
  interface Like extends TypedBase {
    actor: AppBskyActorDefs.ProfileView;
    createdAt: string;
    indexedAt: string;
  }
}

/** Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth. */
export declare namespace AppBskyFeedGetListFeed {
  interface Params extends TypedBase {
    /** Reference (AT-URI) to the list record. */
    list: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    UnknownList: {};
  }
}

/** Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'. */
export declare namespace AppBskyFeedGetPosts {
  interface Params extends TypedBase {
    /**
     * List of post AT-URIs to return hydrated views for.
     * Maximum array length: 25
     */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyFeedDefs.PostView[];
  }
}

/** Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests. */
export declare namespace AppBskyFeedGetPostThread {
  interface Params extends TypedBase {
    /** Reference (AT-URI) to post record. */
    uri: At.Uri;
    /**
     * How many levels of reply depth should be included in response.
     * Minimum: 0
     * Maximum: 1000
     * \@default 6
     */
    depth?: number;
    /**
     * How many levels of parent (and grandparent, etc) post to include.
     * Minimum: 0
     * Maximum: 1000
     * \@default 80
     */
    parentHeight?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    thread: TypeUnion<
      | AppBskyFeedDefs.BlockedPost
      | AppBskyFeedDefs.NotFoundPost
      | AppBskyFeedDefs.ThreadViewPost
    >;
    threadgate?: AppBskyFeedDefs.ThreadgateView;
  }
  interface Errors extends TypedBase {
    NotFound: {};
  }
}

/** Get a list of quotes for a given post. */
export declare namespace AppBskyFeedGetQuotes {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of post record */
    uri: At.Uri;
    /** If supplied, filters to quotes of specific version (by CID) of the post record. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyFeedDefs.PostView[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
}

/** Get a list of reposts for a given post. */
export declare namespace AppBskyFeedGetRepostedBy {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of post record */
    uri: At.Uri;
    /** If supplied, filters to reposts of specific version (by CID) of the post record. */
    cid?: At.CID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repostedBy: AppBskyActorDefs.ProfileView[];
    uri: At.Uri;
    cid?: At.CID;
    cursor?: string;
  }
}

/** Get a list of suggested feeds (feed generators) for the requesting account. */
export declare namespace AppBskyFeedGetSuggestedFeeds {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed. */
export declare namespace AppBskyFeedGetTimeline {
  interface Params extends TypedBase {
    /** Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism. */
    algorithm?: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feed: AppBskyFeedDefs.FeedViewPost[];
    cursor?: string;
  }
}

export declare namespace AppBskyFeedLike {
  /** Record declaring a 'like' of a piece of subject content. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.like";
    createdAt: string;
    subject: ComAtprotoRepoStrongRef.Main;
  }
}

export declare namespace AppBskyFeedPost {
  /** Record containing a Bluesky post. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.post";
    /** Client-declared timestamp when this post was originally created. */
    createdAt: string;
    /**
     * The primary post content. May be an empty string, if there are embeds.
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    text: string;
    embed?: TypeUnion<
      | AppBskyEmbedExternal.Main
      | AppBskyEmbedImages.Main
      | AppBskyEmbedRecord.Main
      | AppBskyEmbedRecordWithMedia.Main
      | AppBskyEmbedVideo.Main
    >;
    /**
     * DEPRECATED: replaced by app.bsky.richtext.facet.
     * \@deprecated
     */
    entities?: Entity[];
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
    /** Self-label values for this post. Effectively content warnings. */
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
    /**
     * Indicates human language of post primary text content.
     * Maximum array length: 3
     */
    langs?: string[];
    reply?: ReplyRef;
    /**
     * Additional hashtags, in addition to any included in post text and facets.
     * Maximum array length: 8
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tags?: string[];
  }
  /**
   * Deprecated: use facets instead.
   * \@deprecated
   */
  interface Entity extends TypedBase {
    index: TextSlice;
    /** Expected values are 'mention' and 'link'. */
    type: string;
    value: string;
  }
  interface ReplyRef extends TypedBase {
    parent: ComAtprotoRepoStrongRef.Main;
    root: ComAtprotoRepoStrongRef.Main;
  }
  /**
   * Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.
   * \@deprecated
   */
  interface TextSlice extends TypedBase {
    /** Minimum: 0 */
    end: number;
    /** Minimum: 0 */
    start: number;
  }
}

export declare namespace AppBskyFeedPostgate {
  /** Record defining interaction rules for a post. The record key (rkey) of the postgate record must match the record key of the post, and that record must be in the same repository. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.postgate";
    createdAt: string;
    /** Reference (AT-URI) to the post record. */
    post: At.Uri;
    /**
     * List of AT-URIs embedding this post that the author has detached from.
     * Maximum array length: 50
     */
    detachedEmbeddingUris?: At.Uri[];
    /**
     * List of rules defining who can embed this post. If value is an empty array or is undefined, no particular rules apply and anyone can embed.
     * Maximum array length: 5
     */
    embeddingRules?: TypeUnion<DisableRule>[];
  }
  /** Disables embedding of this post. */
  interface DisableRule extends TypedBase {}
}

export declare namespace AppBskyFeedRepost {
  /** Record representing a 'repost' of an existing Bluesky post. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.repost";
    createdAt: string;
    subject: ComAtprotoRepoStrongRef.Main;
  }
}

/** Find posts matching search criteria, returning views of those posts. */
export declare namespace AppBskyFeedSearchPosts {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Filter to posts by the given account. Handles are resolved to DID before query-time. */
    author?: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /** Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization. */
    domain?: string;
    /** Filter to posts in the given language. Expected to be based on post language field, though server may override language detection. */
    lang?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions. */
    mentions?: string;
    /** Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD). */
    since?: string;
    /**
     * Specifies the ranking order of results.
     * \@default "latest"
     */
    sort?: "latest" | "top" | (string & {});
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag?: string[];
    /** Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD). */
    until?: string;
    /** Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching. */
    url?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyFeedDefs.PostView[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

/** Send information about interactions with feed items back to the feed generator that served them. */
export declare namespace AppBskyFeedSendInteractions {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    interactions: AppBskyFeedDefs.Interaction[];
  }
  interface Output extends TypedBase {}
}

export declare namespace AppBskyFeedThreadgate {
  /** Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository. */
  interface Record extends RecordBase {
    $type: "app.bsky.feed.threadgate";
    createdAt: string;
    /** Reference (AT-URI) to the post record. */
    post: At.Uri;
    /**
     * List of rules defining who can reply to this post. If value is an empty array, no one can reply. If value is undefined, anyone can reply.
     * Maximum array length: 5
     */
    allow?: TypeUnion<FollowerRule | FollowingRule | ListRule | MentionRule>[];
    /**
     * List of hidden reply URIs.
     * Maximum array length: 50
     */
    hiddenReplies?: At.Uri[];
  }
  /** Allow replies from actors who follow you. */
  interface FollowerRule extends TypedBase {}
  /** Allow replies from actors you follow. */
  interface FollowingRule extends TypedBase {}
  /** Allow replies from actors on a list. */
  interface ListRule extends TypedBase {
    list: At.Uri;
  }
  /** Allow replies from actors mentioned in your post. */
  interface MentionRule extends TypedBase {}
}

export declare namespace AppBskyGraphBlock {
  /** Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.block";
    createdAt: string;
    /** DID of the account to be blocked. */
    subject: At.DID;
  }
}

export declare namespace AppBskyGraphDefs {
  type Curatelist = "app.bsky.graph.defs#curatelist";
  interface ListItemView extends TypedBase {
    subject: AppBskyActorDefs.ProfileView;
    uri: At.Uri;
  }
  type ListPurpose =
    | "app.bsky.graph.defs#curatelist"
    | "app.bsky.graph.defs#modlist"
    | "app.bsky.graph.defs#referencelist"
    | (string & {});
  interface ListView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    purpose: ListPurpose;
    uri: At.Uri;
    avatar?: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
    viewer?: ListViewerState;
  }
  interface ListViewBasic extends TypedBase {
    cid: At.CID;
    /**
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    purpose: ListPurpose;
    uri: At.Uri;
    avatar?: string;
    indexedAt?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
    viewer?: ListViewerState;
  }
  interface ListViewerState extends TypedBase {
    blocked?: At.Uri;
    muted?: boolean;
  }
  type Modlist = "app.bsky.graph.defs#modlist";
  /** indicates that a handle or DID could not be resolved */
  interface NotFoundActor extends TypedBase {
    actor: string;
    notFound: boolean;
  }
  type Referencelist = "app.bsky.graph.defs#referencelist";
  /** lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object) */
  interface Relationship extends TypedBase {
    did: At.DID;
    /** if the actor is followed by this DID, contains the AT-URI of the follow record */
    followedBy?: At.Uri;
    /** if the actor follows this DID, this is the AT-URI of the follow record */
    following?: At.Uri;
  }
  interface StarterPackView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    /** Maximum array length: 3 */
    feeds?: AppBskyFeedDefs.GeneratorView[];
    /** Minimum: 0 */
    joinedAllTimeCount?: number;
    /** Minimum: 0 */
    joinedWeekCount?: number;
    labels?: ComAtprotoLabelDefs.Label[];
    list?: ListViewBasic;
    /** Maximum array length: 12 */
    listItemsSample?: ListItemView[];
  }
  interface StarterPackViewBasic extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileViewBasic;
    indexedAt: string;
    record: unknown;
    uri: At.Uri;
    /** Minimum: 0 */
    joinedAllTimeCount?: number;
    /** Minimum: 0 */
    joinedWeekCount?: number;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    listItemCount?: number;
  }
}

export declare namespace AppBskyGraphFollow {
  /** Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.follow";
    createdAt: string;
    subject: At.DID;
  }
}

/** Get a list of starter packs created by the actor. */
export declare namespace AppBskyGraphGetActorStarterPacks {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
    cursor?: string;
  }
}

/** Enumerates which accounts the requesting account is currently blocking. Requires auth. */
export declare namespace AppBskyGraphGetBlocks {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    blocks: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerates accounts which follow a specified account (actor). */
export declare namespace AppBskyGraphGetFollowers {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    followers: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Enumerates accounts which a specified account (actor) follows. */
export declare namespace AppBskyGraphGetFollows {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    follows: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Enumerates accounts which follow a specified account (actor) and are followed by the viewer. */
export declare namespace AppBskyGraphGetKnownFollowers {
  interface Params extends TypedBase {
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    followers: AppBskyActorDefs.ProfileView[];
    subject: AppBskyActorDefs.ProfileView;
    cursor?: string;
  }
}

/** Gets a 'view' (with additional context) of a specified list. */
export declare namespace AppBskyGraphGetList {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of the list record to hydrate. */
    list: At.Uri;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    items: AppBskyGraphDefs.ListItemView[];
    list: AppBskyGraphDefs.ListView;
    cursor?: string;
  }
}

/** Get mod lists that the requesting account (actor) is blocking. Requires auth. */
export declare namespace AppBskyGraphGetListBlocks {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetListMutes {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates the lists created by a specified account (actor). */
export declare namespace AppBskyGraphGetLists {
  interface Params extends TypedBase {
    /** The account (actor) to enumerate lists from. */
    actor: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    lists: AppBskyGraphDefs.ListView[];
    cursor?: string;
  }
}

/** Enumerates accounts that the requesting account (actor) currently has muted. Requires auth. */
export declare namespace AppBskyGraphGetMutes {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    mutes: AppBskyActorDefs.ProfileView[];
    cursor?: string;
  }
}

/** Enumerates public relationships between one account, and a list of other accounts. Does not require auth. */
export declare namespace AppBskyGraphGetRelationships {
  interface Params extends TypedBase {
    /** Primary account requesting relationships for. */
    actor: string;
    /**
     * List of 'other' accounts to be related back to the primary.
     * Maximum array length: 30
     */
    others?: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    relationships: TypeUnion<
      AppBskyGraphDefs.NotFoundActor | AppBskyGraphDefs.Relationship
    >[];
    actor?: At.DID;
  }
  interface Errors extends TypedBase {
    ActorNotFound: {};
  }
}

/** Gets a view of a starter pack. */
export declare namespace AppBskyGraphGetStarterPack {
  interface Params extends TypedBase {
    /** Reference (AT-URI) of the starter pack record. */
    starterPack: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPack: AppBskyGraphDefs.StarterPackView;
  }
}

/** Get views for a list of starter packs. */
export declare namespace AppBskyGraphGetStarterPacks {
  interface Params extends TypedBase {
    /** Maximum array length: 25 */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
  }
}

/** Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account. */
export declare namespace AppBskyGraphGetSuggestedFollowsByActor {
  interface Params extends TypedBase {
    actor: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    suggestions: AppBskyActorDefs.ProfileView[];
    /**
     * If true, response has fallen-back to generic results, and is not scoped using relativeToDid
     * \@default false
     */
    isFallback?: boolean;
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: number;
  }
}

export declare namespace AppBskyGraphList {
  /** Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.list";
    createdAt: string;
    /**
     * Display name for list; can not be empty.
     * Minimum string length: 1
     * Maximum string length: 64
     */
    name: string;
    /** Defines the purpose of the list (aka, moderation-oriented or curration-oriented) */
    purpose: AppBskyGraphDefs.ListPurpose;
    avatar?: At.Blob;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
  }
}

export declare namespace AppBskyGraphListblock {
  /** Record representing a block relationship against an entire an entire list of accounts (actors). */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.listblock";
    createdAt: string;
    /** Reference (AT-URI) to the mod list record. */
    subject: At.Uri;
  }
}

export declare namespace AppBskyGraphListitem {
  /** Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.listitem";
    createdAt: string;
    /** Reference (AT-URI) to the list record (app.bsky.graph.list). */
    list: At.Uri;
    /** The account which is included on the list. */
    subject: At.DID;
  }
}

/** Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActor {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    actor: string;
  }
  type Output = undefined;
}

/** Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteActorList {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    list: At.Uri;
  }
  type Output = undefined;
}

/** Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth. */
export declare namespace AppBskyGraphMuteThread {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    root: At.Uri;
  }
  type Output = undefined;
}

/** Find starter packs matching search criteria. Does not require auth. */
export declare namespace AppBskyGraphSearchStarterPacks {
  interface Params extends TypedBase {
    /** Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyGraphDefs.StarterPackViewBasic[];
    cursor?: string;
  }
}

export declare namespace AppBskyGraphStarterpack {
  /** Record defining a starter pack of actors and feeds for new users. */
  interface Record extends RecordBase {
    $type: "app.bsky.graph.starterpack";
    createdAt: string;
    /** Reference (AT-URI) to the list record. */
    list: At.Uri;
    /**
     * Display name for starter pack; can not be empty.
     * Minimum string length: 1
     * Maximum string length: 500
     * Maximum grapheme length: 50
     */
    name: string;
    /**
     * Maximum string length: 3000
     * Maximum grapheme length: 300
     */
    description?: string;
    descriptionFacets?: AppBskyRichtextFacet.Main[];
    /** Maximum array length: 3 */
    feeds?: FeedItem[];
  }
  interface FeedItem extends TypedBase {
    uri: At.Uri;
  }
}

/** Unmutes the specified account. Requires auth. */
export declare namespace AppBskyGraphUnmuteActor {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    actor: string;
  }
  type Output = undefined;
}

/** Unmutes the specified list of accounts. Requires auth. */
export declare namespace AppBskyGraphUnmuteActorList {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    list: At.Uri;
  }
  type Output = undefined;
}

/** Unmutes the specified thread. Requires auth. */
export declare namespace AppBskyGraphUnmuteThread {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    root: At.Uri;
  }
  type Output = undefined;
}

export declare namespace AppBskyLabelerDefs {
  interface LabelerPolicies extends TypedBase {
    /** The label values which this labeler publishes. May include global or custom labels. */
    labelValues: ComAtprotoLabelDefs.LabelValue[];
    /** Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler. */
    labelValueDefinitions?: ComAtprotoLabelDefs.LabelValueDefinition[];
  }
  interface LabelerView extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    viewer?: LabelerViewerState;
  }
  interface LabelerViewDetailed extends TypedBase {
    cid: At.CID;
    creator: AppBskyActorDefs.ProfileView;
    indexedAt: string;
    policies: AppBskyLabelerDefs.LabelerPolicies;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    /** Minimum: 0 */
    likeCount?: number;
    /** The set of report reason 'codes' which are in-scope for this service to review and action. These usually align to policy categories. If not defined (distinct from empty array), all reason types are allowed. */
    reasonTypes?: ComAtprotoModerationDefs.ReasonType[];
    /** Set of record types (collection NSIDs) which can be reported to this service. If not defined (distinct from empty array), default is any record type. */
    subjectCollections?: string[];
    /** The set of subject types (account, record, etc) this service accepts reports on. */
    subjectTypes?: ComAtprotoModerationDefs.SubjectType[];
    viewer?: LabelerViewerState;
  }
  interface LabelerViewerState extends TypedBase {
    like?: At.Uri;
  }
}

/** Get information about a list of labeler services. */
export declare namespace AppBskyLabelerGetServices {
  interface Params extends TypedBase {
    dids: At.DID[];
    /** \@default false */
    detailed?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    views: TypeUnion<
      AppBskyLabelerDefs.LabelerView | AppBskyLabelerDefs.LabelerViewDetailed
    >[];
  }
}

export declare namespace AppBskyLabelerService {
  /** A declaration of the existence of labeler service. */
  interface Record extends RecordBase {
    $type: "app.bsky.labeler.service";
    createdAt: string;
    policies: AppBskyLabelerDefs.LabelerPolicies;
    labels?: TypeUnion<ComAtprotoLabelDefs.SelfLabels>;
    /** The set of report reason 'codes' which are in-scope for this service to review and action. These usually align to policy categories. If not defined (distinct from empty array), all reason types are allowed. */
    reasonTypes?: ComAtprotoModerationDefs.ReasonType[];
    /** Set of record types (collection NSIDs) which can be reported to this service. If not defined (distinct from empty array), default is any record type. */
    subjectCollections?: string[];
    /** The set of subject types (account, record, etc) this service accepts reports on. */
    subjectTypes?: ComAtprotoModerationDefs.SubjectType[];
  }
}

/** Count the number of unread notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationGetUnreadCount {
  interface Params extends TypedBase {
    priority?: boolean;
    seenAt?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    count: number;
  }
}

/** Enumerate notifications for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationListNotifications {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    priority?: boolean;
    /**
     * Notification reasons to include in response.
     * A reason that matches the reason property of #notification.
     */
    reasons?: string[];
    seenAt?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    notifications: Notification[];
    cursor?: string;
    priority?: boolean;
    seenAt?: string;
  }
  interface Notification extends TypedBase {
    author: AppBskyActorDefs.ProfileView;
    cid: At.CID;
    indexedAt: string;
    isRead: boolean;
    /** Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'. */
    reason:
      | "follow"
      | "like"
      | "mention"
      | "quote"
      | "reply"
      | "repost"
      | "starterpack-joined"
      | (string & {});
    record: unknown;
    uri: At.Uri;
    labels?: ComAtprotoLabelDefs.Label[];
    reasonSubject?: At.Uri;
  }
}

/** Set notification-related preferences for an account. Requires auth. */
export declare namespace AppBskyNotificationPutPreferences {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    priority: boolean;
  }
  type Output = undefined;
}

/** Register to receive push notifications, via a specified service, for the requesting account. Requires auth. */
export declare namespace AppBskyNotificationRegisterPush {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    appId: string;
    platform: "android" | "ios" | "web" | (string & {});
    serviceDid: At.DID;
    token: string;
  }
  type Output = undefined;
}

/** Notify server that the requesting account has seen notifications. Requires auth. */
export declare namespace AppBskyNotificationUpdateSeen {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    seenAt: string;
  }
  type Output = undefined;
}

export declare namespace AppBskyRichtextFacet {
  /** Annotation of a sub-string within rich text. */
  interface Main extends TypedBase {
    features: TypeUnion<Link | Mention | Tag>[];
    index: ByteSlice;
  }
  /** Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets. */
  interface ByteSlice extends TypedBase {
    /** Minimum: 0 */
    byteEnd: number;
    /** Minimum: 0 */
    byteStart: number;
  }
  /** Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL. */
  interface Link extends TypedBase {
    uri: string;
  }
  /** Facet feature for mention of another account. The text is usually a handle, including a '\@' prefix, but the facet reference is a DID. */
  interface Mention extends TypedBase {
    did: At.DID;
  }
  /** Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags'). */
  interface Tag extends TypedBase {
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag: string;
  }
}

export declare namespace AppBskyUnspeccedDefs {
  interface SkeletonSearchActor extends TypedBase {
    did: At.DID;
  }
  interface SkeletonSearchPost extends TypedBase {
    uri: At.Uri;
  }
  interface SkeletonSearchStarterPack extends TypedBase {
    uri: At.Uri;
  }
  interface TrendingTopic extends TypedBase {
    link: string;
    topic: string;
    description?: string;
    displayName?: string;
  }
}

/** Get miscellaneous runtime configuration. */
export declare namespace AppBskyUnspeccedGetConfig {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    checkEmailConfirmed?: boolean;
  }
}

/** An unspecced view of globally popular feed generators. */
export declare namespace AppBskyUnspeccedGetPopularFeedGenerators {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    query?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    feeds: AppBskyFeedDefs.GeneratorView[];
    cursor?: string;
  }
}

/** Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions */
export declare namespace AppBskyUnspeccedGetSuggestionsSkeleton {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer. */
    relativeToDid?: At.DID;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
    cursor?: string;
    /** Snowflake for this recommendation, use when submitting recommendation events. */
    recId?: number;
    /** DID of the account these suggestions are relative to. If this is returned undefined, suggestions are based on the viewer. */
    relativeToDid?: At.DID;
  }
}

/** Get a list of suggestions (feeds and users) tagged with categories */
export declare namespace AppBskyUnspeccedGetTaggedSuggestions {
  type Input = undefined;
  interface Output extends TypedBase {
    suggestions: Suggestion[];
  }
  interface Suggestion extends TypedBase {
    subject: string;
    subjectType: "actor" | "feed" | (string & {});
    tag: string;
  }
}

/** Get a list of trending topics */
export declare namespace AppBskyUnspeccedGetTrendingTopics {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 25
     * \@default 10
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    suggested: AppBskyUnspeccedDefs.TrendingTopic[];
    topics: AppBskyUnspeccedDefs.TrendingTopic[];
  }
}

/** Backend Actors (profile) search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchActorsSkeleton {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax. */
    q: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** If true, acts as fast/simple 'typeahead' query. */
    typeahead?: boolean;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    actors: AppBskyUnspeccedDefs.SkeletonSearchActor[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

/** Backend Posts search, returns only skeleton */
export declare namespace AppBskyUnspeccedSearchPostsSkeleton {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Filter to posts by the given account. Handles are resolved to DID before query-time. */
    author?: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /** Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization. */
    domain?: string;
    /** Filter to posts in the given language. Expected to be based on post language field, though server may override language detection. */
    lang?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions. */
    mentions?: string;
    /** Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD). */
    since?: string;
    /**
     * Specifies the ranking order of results.
     * \@default "latest"
     */
    sort?: "latest" | "top" | (string & {});
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    tag?: string[];
    /** Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD). */
    until?: string;
    /** Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching. */
    url?: string;
    /** DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries. */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    posts: AppBskyUnspeccedDefs.SkeletonSearchPost[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

/** Backend Starter Pack search, returns only skeleton. */
export declare namespace AppBskyUnspeccedSearchStarterPacksSkeleton {
  interface Params extends TypedBase {
    /** Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. */
    q: string;
    /** Optional pagination mechanism; may not necessarily allow scrolling through entire result set. */
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 25
     */
    limit?: number;
    /** DID of the account making the request (not included for public/unauthenticated queries). */
    viewer?: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    starterPacks: AppBskyUnspeccedDefs.SkeletonSearchStarterPack[];
    cursor?: string;
    /** Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits. */
    hitsTotal?: number;
  }
  interface Errors extends TypedBase {
    BadQueryString: {};
  }
}

export declare namespace AppBskyVideoDefs {
  interface JobStatus extends TypedBase {
    did: At.DID;
    jobId: string;
    /** The state of the video processing job. All values not listed as a known value indicate that the job is in process. */
    state: "JOB_STATE_COMPLETED" | "JOB_STATE_FAILED" | (string & {});
    blob?: At.Blob;
    error?: string;
    message?: string;
    /**
     * Progress within the current processing state.
     * Minimum: 0
     * Maximum: 100
     */
    progress?: number;
  }
}

/** Get status details for a video processing job. */
export declare namespace AppBskyVideoGetJobStatus {
  interface Params extends TypedBase {
    jobId: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    jobStatus: AppBskyVideoDefs.JobStatus;
  }
}

/** Get video upload limits for the authenticated user. */
export declare namespace AppBskyVideoGetUploadLimits {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    canUpload: boolean;
    error?: string;
    message?: string;
    remainingDailyBytes?: number;
    remainingDailyVideos?: number;
  }
}

/** Upload a video to be processed then stored on the PDS. */
export declare namespace AppBskyVideoUploadVideo {
  interface Params extends TypedBase {}
  type Input = Blob | ArrayBufferView;
  interface Output extends TypedBase {
    jobStatus: AppBskyVideoDefs.JobStatus;
  }
}

export declare namespace ChatBskyActorDeclaration {
  /** A declaration of a Bluesky chat account. */
  interface Record extends RecordBase {
    $type: "chat.bsky.actor.declaration";
    allowIncoming: "all" | "following" | "none" | (string & {});
  }
}

export declare namespace ChatBskyActorDefs {
  interface ProfileViewBasic extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    associated?: AppBskyActorDefs.ProfileAssociated;
    avatar?: string;
    /** Set to true when the actor cannot actively participate in converations */
    chatDisabled?: boolean;
    /**
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    displayName?: string;
    labels?: ComAtprotoLabelDefs.Label[];
    viewer?: AppBskyActorDefs.ViewerState;
  }
}

export declare namespace ChatBskyActorDeleteAccount {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {}
}

export declare namespace ChatBskyActorExportAccountData {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = Uint8Array;
}

export declare namespace ChatBskyConvoAcceptConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    /** Rev when the convo was accepted. If not present, the convo was already accepted. */
    rev?: string;
  }
}

export declare namespace ChatBskyConvoDefs {
  interface ConvoView extends TypedBase {
    id: string;
    members: ChatBskyActorDefs.ProfileViewBasic[];
    muted: boolean;
    rev: string;
    unreadCount: number;
    lastMessage?: TypeUnion<DeletedMessageView | MessageView>;
    status?: "accepted" | "request" | (string & {});
  }
  interface DeletedMessageView extends TypedBase {
    id: string;
    rev: string;
    sender: MessageViewSender;
    sentAt: string;
  }
  interface LogAcceptConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogBeginConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogCreateMessage extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogDeleteMessage extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogLeaveConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogMuteConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface LogReadMessage extends TypedBase {
    convoId: string;
    message: TypeUnion<DeletedMessageView | MessageView>;
    rev: string;
  }
  interface LogUnmuteConvo extends TypedBase {
    convoId: string;
    rev: string;
  }
  interface MessageInput extends TypedBase {
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    text: string;
    embed?: TypeUnion<AppBskyEmbedRecord.Main>;
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
  }
  interface MessageRef extends TypedBase {
    convoId: string;
    did: At.DID;
    messageId: string;
  }
  interface MessageView extends TypedBase {
    id: string;
    rev: string;
    sender: MessageViewSender;
    sentAt: string;
    /**
     * Maximum string length: 10000
     * Maximum grapheme length: 1000
     */
    text: string;
    embed?: TypeUnion<AppBskyEmbedRecord.View>;
    /** Annotations of text (mentions, URLs, hashtags, etc) */
    facets?: AppBskyRichtextFacet.Main[];
  }
  interface MessageViewSender extends TypedBase {
    did: At.DID;
  }
}

export declare namespace ChatBskyConvoDeleteMessageForSelf {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    messageId: string;
  }
  type Output = ChatBskyConvoDefs.DeletedMessageView;
}

export declare namespace ChatBskyConvoGetConvo {
  interface Params extends TypedBase {
    convoId: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

/** Get whether the requester and the other members can chat. If an existing convo is found for these members, it is returned. */
export declare namespace ChatBskyConvoGetConvoAvailability {
  interface Params extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 10
     */
    members: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    canChat: boolean;
    convo?: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoGetConvoForMembers {
  interface Params extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 10
     */
    members: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoGetLog {
  interface Params extends TypedBase {
    cursor?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    logs: TypeUnion<
      | ChatBskyConvoDefs.LogAcceptConvo
      | ChatBskyConvoDefs.LogBeginConvo
      | ChatBskyConvoDefs.LogCreateMessage
      | ChatBskyConvoDefs.LogDeleteMessage
      | ChatBskyConvoDefs.LogLeaveConvo
    >[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoGetMessages {
  interface Params extends TypedBase {
    convoId: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    messages: TypeUnion<
      ChatBskyConvoDefs.DeletedMessageView | ChatBskyConvoDefs.MessageView
    >[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoLeaveConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    convoId: string;
    rev: string;
  }
}

export declare namespace ChatBskyConvoListConvos {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    readState?: "unread" | (string & {});
    status?: "accepted" | "request" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    convos: ChatBskyConvoDefs.ConvoView[];
    cursor?: string;
  }
}

export declare namespace ChatBskyConvoMuteConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoSendMessage {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    message: ChatBskyConvoDefs.MessageInput;
  }
  type Output = ChatBskyConvoDefs.MessageView;
}

export declare namespace ChatBskyConvoSendMessageBatch {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Maximum array length: 100 */
    items: BatchItem[];
  }
  interface Output extends TypedBase {
    items: ChatBskyConvoDefs.MessageView[];
  }
  interface BatchItem extends TypedBase {
    convoId: string;
    message: ChatBskyConvoDefs.MessageInput;
  }
}

export declare namespace ChatBskyConvoUnmuteConvo {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
  }
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyConvoUpdateAllRead {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    status?: "accepted" | "request" | (string & {});
  }
  interface Output extends TypedBase {
    /** The count of updated convos. */
    updatedCount: number;
  }
}

export declare namespace ChatBskyConvoUpdateRead {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    convoId: string;
    messageId?: string;
  }
  interface Output extends TypedBase {
    convo: ChatBskyConvoDefs.ConvoView;
  }
}

export declare namespace ChatBskyModerationGetActorMetadata {
  interface Params extends TypedBase {
    actor: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    all: Metadata;
    day: Metadata;
    month: Metadata;
  }
  interface Metadata extends TypedBase {
    convos: number;
    convosStarted: number;
    messagesReceived: number;
    messagesSent: number;
  }
}

export declare namespace ChatBskyModerationGetMessageContext {
  interface Params extends TypedBase {
    messageId: string;
    /** \@default 5 */
    after?: number;
    /** \@default 5 */
    before?: number;
    /** Conversation that the message is from. NOTE: this field will eventually be required. */
    convoId?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    messages: TypeUnion<
      ChatBskyConvoDefs.DeletedMessageView | ChatBskyConvoDefs.MessageView
    >[];
  }
}

export declare namespace ChatBskyModerationUpdateActorAccess {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    actor: At.DID;
    allowAccess: boolean;
    ref?: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoAdminDefs {
  interface AccountView extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    deactivatedAt?: string;
    email?: string;
    emailConfirmedAt?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invites?: ComAtprotoServerDefs.InviteCode[];
    invitesDisabled?: boolean;
    relatedRecords?: unknown[];
    threatSignatures?: ThreatSignature[];
  }
  interface RepoBlobRef extends TypedBase {
    cid: At.CID;
    did: At.DID;
    recordUri?: At.Uri;
  }
  interface RepoRef extends TypedBase {
    did: At.DID;
  }
  interface StatusAttr extends TypedBase {
    applied: boolean;
    ref?: string;
  }
  interface ThreatSignature extends TypedBase {
    property: string;
    value: string;
  }
}

/** Delete a user account as an administrator. */
export declare namespace ComAtprotoAdminDeleteAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
  }
  type Output = undefined;
}

/** Disable an account from receiving new invite codes, but does not invalidate existing codes. */
export declare namespace ComAtprotoAdminDisableAccountInvites {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    account: At.DID;
    /** Optional reason for disabled invites. */
    note?: string;
  }
  type Output = undefined;
}

/** Disable some set of codes and/or all codes associated with a set of users. */
export declare namespace ComAtprotoAdminDisableInviteCodes {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    accounts?: string[];
    codes?: string[];
  }
  type Output = undefined;
}

/** Re-enable an account's ability to receive invite codes. */
export declare namespace ComAtprotoAdminEnableAccountInvites {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    account: At.DID;
    /** Optional reason for enabled invites. */
    note?: string;
  }
  type Output = undefined;
}

/** Get details about an account. */
export declare namespace ComAtprotoAdminGetAccountInfo {
  interface Params extends TypedBase {
    did: At.DID;
  }
  type Input = undefined;
  type Output = ComAtprotoAdminDefs.AccountView;
}

/** Get details about some accounts. */
export declare namespace ComAtprotoAdminGetAccountInfos {
  interface Params extends TypedBase {
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    infos: ComAtprotoAdminDefs.AccountView[];
  }
}

/** Get an admin view of invite codes. */
export declare namespace ComAtprotoAdminGetInviteCodes {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 500
     * \@default 100
     */
    limit?: number;
    /** \@default "recent" */
    sort?: "recent" | "usage" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    codes: ComAtprotoServerDefs.InviteCode[];
    cursor?: string;
  }
}

/** Get the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminGetSubjectStatus {
  interface Params extends TypedBase {
    blob?: At.CID;
    did?: At.DID;
    uri?: At.Uri;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    subject: TypeUnion<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    deactivated?: ComAtprotoAdminDefs.StatusAttr;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
}

/** Get list of accounts that matches your search query. */
export declare namespace ComAtprotoAdminSearchAccounts {
  interface Params extends TypedBase {
    cursor?: string;
    email?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    accounts: ComAtprotoAdminDefs.AccountView[];
    cursor?: string;
  }
}

/** Send email to a user's account email address. */
export declare namespace ComAtprotoAdminSendEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    content: string;
    recipientDid: At.DID;
    senderDid: At.DID;
    /** Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers */
    comment?: string;
    subject?: string;
  }
  interface Output extends TypedBase {
    sent: boolean;
  }
}

/** Administrative action to update an account's email. */
export declare namespace ComAtprotoAdminUpdateAccountEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The handle or DID of the repo. */
    account: string;
    email: string;
  }
  type Output = undefined;
}

/** Administrative action to update an account's handle. */
export declare namespace ComAtprotoAdminUpdateAccountHandle {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    handle: At.Handle;
  }
  type Output = undefined;
}

/** Update the password for a user account as an administrator. */
export declare namespace ComAtprotoAdminUpdateAccountPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    password: string;
  }
  type Output = undefined;
}

/** Update the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminUpdateSubjectStatus {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    subject: TypeUnion<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    deactivated?: ComAtprotoAdminDefs.StatusAttr;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
  interface Output extends TypedBase {
    subject: TypeUnion<
      | ComAtprotoAdminDefs.RepoBlobRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    takedown?: ComAtprotoAdminDefs.StatusAttr;
  }
}

export declare namespace ComAtprotoIdentityDefs {
  interface IdentityInfo extends TypedBase {
    did: At.DID;
    /** The complete DID document for the identity. */
    didDoc: unknown;
    /** The validated handle of the account; or 'handle.invalid' if the handle did not bi-directionally match the DID document. */
    handle: At.Handle;
  }
}

/** Describe the credentials that should be included in the DID doc of an account that is migrating to this service. */
export declare namespace ComAtprotoIdentityGetRecommendedDidCredentials {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    alsoKnownAs?: string[];
    /** Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs. */
    rotationKeys?: string[];
    services?: unknown;
    verificationMethods?: unknown;
  }
}

/** Request that the server re-resolve an identity (DID and handle). The server may ignore this request, or require authentication, depending on the role, implementation, and policy of the server. */
export declare namespace ComAtprotoIdentityRefreshIdentity {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    identifier: string;
  }
  type Output = ComAtprotoIdentityDefs.IdentityInfo;
  interface Errors extends TypedBase {
    HandleNotFound: {};
    DidNotFound: {};
    DidDeactivated: {};
  }
}

/** Request an email with a code to in order to request a signed PLC operation. Requires Auth. */
export declare namespace ComAtprotoIdentityRequestPlcOperationSignature {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Resolves DID to DID document. Does not bi-directionally verify handle. */
export declare namespace ComAtprotoIdentityResolveDid {
  interface Params extends TypedBase {
    /** DID to resolve. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** The complete DID document for the identity. */
    didDoc: unknown;
  }
  interface Errors extends TypedBase {
    DidNotFound: {};
    DidDeactivated: {};
  }
}

/** Resolves an atproto handle (hostname) to a DID. Does not necessarily bi-directionally verify against the the DID document. */
export declare namespace ComAtprotoIdentityResolveHandle {
  interface Params extends TypedBase {
    /** The handle to resolve. */
    handle: At.Handle;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    did: At.DID;
  }
  interface Errors extends TypedBase {
    HandleNotFound: {};
  }
}

/** Resolves an identity (DID or Handle) to a full identity (DID document and verified handle). */
export declare namespace ComAtprotoIdentityResolveIdentity {
  interface Params extends TypedBase {
    /** Handle or DID to resolve. */
    identifier: string;
  }
  type Input = undefined;
  type Output = ComAtprotoIdentityDefs.IdentityInfo;
  interface Errors extends TypedBase {
    HandleNotFound: {};
    DidNotFound: {};
    DidDeactivated: {};
  }
}

/** Signs a PLC operation to update some value(s) in the requesting DID's document. */
export declare namespace ComAtprotoIdentitySignPlcOperation {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    alsoKnownAs?: string[];
    rotationKeys?: string[];
    services?: unknown;
    /** A token received through com.atproto.identity.requestPlcOperationSignature */
    token?: string;
    verificationMethods?: unknown;
  }
  interface Output extends TypedBase {
    /** A signed DID PLC operation. */
    operation: unknown;
  }
}

/** Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry */
export declare namespace ComAtprotoIdentitySubmitPlcOperation {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    operation: unknown;
  }
  type Output = undefined;
}

/** Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth. */
export declare namespace ComAtprotoIdentityUpdateHandle {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The new handle. */
    handle: At.Handle;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoLabelDefs {
  /** Metadata tag on an atproto resource (eg, repo or record). */
  interface Label extends TypedBase {
    /** Timestamp when this label was created. */
    cts: string;
    /** DID of the actor who created this label. */
    src: At.DID;
    /** AT URI of the record, repository (account), or other resource that this label applies to. */
    uri: string;
    /**
     * The short string name of the value or type of this label.
     * Maximum string length: 128
     */
    val: string;
    /** Optionally, CID specifying the specific version of 'uri' resource this label applies to. */
    cid?: At.CID;
    /** Timestamp at which this label expires (no longer applies). */
    exp?: string;
    /** If true, this is a negation label, overwriting a previous label. */
    neg?: boolean;
    /** Signature of dag-cbor encoded label. */
    sig?: At.Bytes;
    /** The AT Protocol version of the label object. */
    ver?: number;
  }
  type LabelValue =
    | "!hide"
    | "!no-promote"
    | "!no-unauthenticated"
    | "!warn"
    | "dmca-violation"
    | "doxxing"
    | "gore"
    | "nsfl"
    | "nudity"
    | "porn"
    | "sexual"
    | (string & {});
  /** Declares a label value and its expected interpretations and behaviors. */
  interface LabelValueDefinition extends TypedBase {
    /** What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing. */
    blurs: "content" | "media" | "none" | (string & {});
    /**
     * The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).
     * Maximum string length: 100
     * Maximum grapheme length: 100
     */
    identifier: string;
    locales: LabelValueDefinitionStrings[];
    /** How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing. */
    severity: "alert" | "inform" | "none" | (string & {});
    /** Does the user need to have adult content enabled in order to configure this label? */
    adultOnly?: boolean;
    /**
     * The default setting for this label.
     * \@default "warn"
     */
    defaultSetting?: "hide" | "ignore" | "warn" | (string & {});
  }
  /** Strings which describe the label in the UI, localized into a specific language. */
  interface LabelValueDefinitionStrings extends TypedBase {
    /**
     * A longer description of what the label means and why it might be applied.
     * Maximum string length: 100000
     * Maximum grapheme length: 10000
     */
    description: string;
    /** The code of the language these strings are written in. */
    lang: string;
    /**
     * A short human-readable name for the label.
     * Maximum string length: 640
     * Maximum grapheme length: 64
     */
    name: string;
  }
  /** Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel. */
  interface SelfLabel extends TypedBase {
    /**
     * The short string name of the value or type of this label.
     * Maximum string length: 128
     */
    val: string;
  }
  /** Metadata tags on an atproto record, published by the author within the record. */
  interface SelfLabels extends TypedBase {
    /** Maximum array length: 10 */
    values: SelfLabel[];
  }
}

/** Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth. */
export declare namespace ComAtprotoLabelQueryLabels {
  interface Params extends TypedBase {
    /** List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI. */
    uriPatterns: string[];
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 250
     * \@default 50
     */
    limit?: number;
    /** Optional list of label sources (DIDs) to filter on. */
    sources?: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    labels: ComAtprotoLabelDefs.Label[];
    cursor?: string;
  }
}

export declare namespace ComAtprotoLabelSubscribeLabels {
  interface Params extends TypedBase {
    /** The last known event seq number to backfill from. */
    cursor?: number;
  }
  type Message = TypeUnion<Info | Labels>;
  interface Errors extends TypedBase {
    FutureCursor: {};
  }
  interface Info extends TypedBase {
    name: "OutdatedCursor" | (string & {});
    message?: string;
  }
  interface Labels extends TypedBase {
    labels: ComAtprotoLabelDefs.Label[];
    seq: number;
  }
}

export declare namespace ComAtprotoLexiconSchema {
  /** Representation of Lexicon schemas themselves, when published as atproto records. Note that the schema language is not defined in Lexicon; this meta schema currently only includes a single version field ('lexicon'). See the atproto specifications for description of the other expected top-level fields ('id', 'defs', etc). */
  interface Record extends RecordBase {
    $type: "com.atproto.lexicon.schema";
    /** Indicates the 'version' of the Lexicon language. Must be '1' for the current atproto/Lexicon schema system. */
    lexicon: number;
  }
}

/** Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth. */
export declare namespace ComAtprotoModerationCreateReport {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Indicates the broad category of violation the report is for. */
    reasonType: ComAtprotoModerationDefs.ReasonType;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /**
     * Additional context about the content and violation.
     * Maximum string length: 20000
     * Maximum grapheme length: 2000
     */
    reason?: string;
  }
  interface Output extends TypedBase {
    createdAt: string;
    id: number;
    reasonType: ComAtprotoModerationDefs.ReasonType;
    reportedBy: At.DID;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /**
     * Maximum string length: 20000
     * Maximum grapheme length: 2000
     */
    reason?: string;
  }
}

export declare namespace ComAtprotoModerationDefs {
  type ReasonAppeal = "com.atproto.moderation.defs#reasonAppeal";
  type ReasonMisleading = "com.atproto.moderation.defs#reasonMisleading";
  type ReasonOther = "com.atproto.moderation.defs#reasonOther";
  type ReasonRude = "com.atproto.moderation.defs#reasonRude";
  type ReasonSexual = "com.atproto.moderation.defs#reasonSexual";
  type ReasonSpam = "com.atproto.moderation.defs#reasonSpam";
  type ReasonType =
    | "com.atproto.moderation.defs#reasonAppeal"
    | "com.atproto.moderation.defs#reasonMisleading"
    | "com.atproto.moderation.defs#reasonOther"
    | "com.atproto.moderation.defs#reasonRude"
    | "com.atproto.moderation.defs#reasonSexual"
    | "com.atproto.moderation.defs#reasonSpam"
    | "com.atproto.moderation.defs#reasonViolation"
    | (string & {});
  type ReasonViolation = "com.atproto.moderation.defs#reasonViolation";
  /** Tag describing a type of subject that might be reported. */
  type SubjectType = "account" | "chat" | "record" | (string & {});
}

/** Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoApplyWrites {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    writes: TypeUnion<Create | Delete | Update>[];
    /** If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations. */
    swapCommit?: At.CID;
    /** Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output extends TypedBase {
    commit?: ComAtprotoRepoDefs.CommitMeta;
    results?: TypeUnion<CreateResult | DeleteResult | UpdateResult>[];
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
  /** Operation which creates a new record. */
  interface Create extends TypedBase {
    collection: string;
    value: unknown;
    /** NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility. */
    rkey?: At.RKEY;
  }
  interface CreateResult extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  /** Operation which deletes an existing record. */
  interface Delete extends TypedBase {
    collection: string;
    rkey: At.RKEY;
  }
  interface DeleteResult extends TypedBase {}
  /** Operation which updates an existing record. */
  interface Update extends TypedBase {
    collection: string;
    rkey: At.RKEY;
    value: unknown;
  }
  interface UpdateResult extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
}

/** Create a single new repository record. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoCreateRecord {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The record itself. Must contain a $type field. */
    record: unknown;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey?: At.RKEY;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    commit?: ComAtprotoRepoDefs.CommitMeta;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
}

export declare namespace ComAtprotoRepoDefs {
  interface CommitMeta extends TypedBase {
    cid: At.CID;
    rev: At.TID;
  }
}

/** Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoDeleteRecord {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey: At.RKEY;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Compare and swap with the previous record by CID. */
    swapRecord?: At.CID;
  }
  interface Output extends TypedBase {
    commit?: ComAtprotoRepoDefs.CommitMeta;
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
}

/** Get information about an account and repository, including the list of collections. Does not require auth. */
export declare namespace ComAtprotoRepoDescribeRepo {
  interface Params extends TypedBase {
    /** The handle or DID of the repo. */
    repo: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    /** List of all the collections (NSIDs) for which this repo contains at least one record. */
    collections: string[];
    did: At.DID;
    /** The complete DID document for this account. */
    didDoc: unknown;
    handle: At.Handle;
    /** Indicates if handle is currently valid (resolves bi-directionally) */
    handleIsCorrect: boolean;
  }
}

/** Get a single record from a repository. Does not require auth. */
export declare namespace ComAtprotoRepoGetRecord {
  interface Params extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The handle or DID of the repo. */
    repo: string;
    /** The Record Key. */
    rkey: At.RKEY;
    /** The CID of the version of the record. If not specified, then return the most recent version. */
    cid?: At.CID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    uri: At.Uri;
    value: unknown;
    cid?: At.CID;
  }
  interface Errors extends TypedBase {
    RecordNotFound: {};
  }
}

/** Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set. */
export declare namespace ComAtprotoRepoImportRepo {
  interface Params extends TypedBase {}
  type Input = Blob | ArrayBufferView;
  type Output = undefined;
}

/** Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow. */
export declare namespace ComAtprotoRepoListMissingBlobs {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    blobs: RecordBlob[];
    cursor?: string;
  }
  interface RecordBlob extends TypedBase {
    cid: At.CID;
    recordUri: At.Uri;
  }
}

/** List a range of records in a repository, matching a specific collection. Does not require auth. */
export declare namespace ComAtprotoRepoListRecords {
  interface Params extends TypedBase {
    /** The NSID of the record type. */
    collection: string;
    /** The handle or DID of the repo. */
    repo: string;
    cursor?: string;
    /**
     * The number of records to return.
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Flag to reverse the order of the returned records. */
    reverse?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    records: Record[];
    cursor?: string;
  }
  interface Record extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    value: unknown;
  }
}

/** Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoPutRecord {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The NSID of the record collection. */
    collection: string;
    /** The record to write. */
    record: unknown;
    /** The handle or DID of the repo (aka, current account). */
    repo: string;
    /** The Record Key. */
    rkey: At.RKEY;
    /** Compare and swap with the previous commit by CID. */
    swapCommit?: At.CID;
    /** Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation */
    swapRecord?: At.CID | null;
    /** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
    validate?: boolean;
  }
  interface Output extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
    commit?: ComAtprotoRepoDefs.CommitMeta;
    validationStatus?: "unknown" | "valid" | (string & {});
  }
  interface Errors extends TypedBase {
    InvalidSwap: {};
  }
}

export declare namespace ComAtprotoRepoStrongRef {
  interface Main extends TypedBase {
    cid: At.CID;
    uri: At.Uri;
  }
}

/** Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoUploadBlob {
  interface Params extends TypedBase {}
  type Input = Blob | ArrayBufferView;
  interface Output extends TypedBase {
    blob: At.Blob;
  }
}

/** Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup. */
export declare namespace ComAtprotoServerActivateAccount {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself. */
export declare namespace ComAtprotoServerCheckAccountStatus {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    activated: boolean;
    expectedBlobs: number;
    importedBlobs: number;
    indexedRecords: number;
    privateStateValues: number;
    repoBlocks: number;
    repoCommit: At.CID;
    repoRev: string;
    validDid: boolean;
  }
}

/** Confirm an email using a token from com.atproto.server.requestEmailConfirmation. */
export declare namespace ComAtprotoServerConfirmEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    email: string;
    token: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    AccountNotFound: {};
    ExpiredToken: {};
    InvalidToken: {};
    InvalidEmail: {};
  }
}

/** Create an account. Implemented by PDS. */
export declare namespace ComAtprotoServerCreateAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Requested handle for the account. */
    handle: At.Handle;
    /** Pre-existing atproto DID, being imported to a new account. */
    did?: At.DID;
    email?: string;
    inviteCode?: string;
    /** Initial account password. May need to meet instance-specific password strength requirements. */
    password?: string;
    /** A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented. */
    plcOp?: unknown;
    /** DID PLC rotation key (aka, recovery key) to be included in PLC creation operation. */
    recoveryKey?: string;
    verificationCode?: string;
    verificationPhone?: string;
  }
  /** Account login session returned on successful account creation. */
  interface Output extends TypedBase {
    accessJwt: string;
    /** The DID of the new account. */
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    /** Complete DID document. */
    didDoc?: unknown;
  }
  interface Errors extends TypedBase {
    InvalidHandle: {};
    InvalidPassword: {};
    InvalidInviteCode: {};
    HandleNotAvailable: {};
    UnsupportedDomain: {};
    UnresolvableDid: {};
    IncompatibleDidDoc: {};
  }
}

/** Create an App Password. */
export declare namespace ComAtprotoServerCreateAppPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** A short name for the App Password, to help distinguish them. */
    name: string;
    /** If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients. */
    privileged?: boolean;
  }
  type Output = AppPassword;
  interface Errors extends TypedBase {
    AccountTakedown: {};
  }
  interface AppPassword extends TypedBase {
    createdAt: string;
    name: string;
    password: string;
    privileged?: boolean;
  }
}

/** Create an invite code. */
export declare namespace ComAtprotoServerCreateInviteCode {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    useCount: number;
    forAccount?: At.DID;
  }
  interface Output extends TypedBase {
    code: string;
  }
}

/** Create invite codes. */
export declare namespace ComAtprotoServerCreateInviteCodes {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** \@default 1 */
    codeCount: number;
    useCount: number;
    forAccounts?: At.DID[];
  }
  interface Output extends TypedBase {
    codes: AccountCodes[];
  }
  interface AccountCodes extends TypedBase {
    account: string;
    codes: string[];
  }
}

/** Create an authentication session. */
export declare namespace ComAtprotoServerCreateSession {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Handle or other identifier supported by the server for the authenticating user. */
    identifier: string;
    password: string;
    /** When true, instead of throwing error for takendown accounts, a valid response with a narrow scoped token will be returned */
    allowTakendown?: boolean;
    authFactorToken?: string;
  }
  interface Output extends TypedBase {
    accessJwt: string;
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors extends TypedBase {
    AccountTakedown: {};
    AuthFactorTokenRequired: {};
  }
}

/** Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host. */
export declare namespace ComAtprotoServerDeactivateAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** A recommendation to server as to how long they should hold onto the deactivated account before deleting. */
    deleteAfter?: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoServerDefs {
  interface InviteCode extends TypedBase {
    available: number;
    code: string;
    createdAt: string;
    createdBy: string;
    disabled: boolean;
    forAccount: string;
    uses: InviteCodeUse[];
  }
  interface InviteCodeUse extends TypedBase {
    usedAt: string;
    usedBy: At.DID;
  }
}

/** Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth. */
export declare namespace ComAtprotoServerDeleteAccount {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    password: string;
    token: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    ExpiredToken: {};
    InvalidToken: {};
  }
}

/** Delete the current session. Requires auth. */
export declare namespace ComAtprotoServerDeleteSession {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Describes the server's account creation requirements and capabilities. Implemented by PDS. */
export declare namespace ComAtprotoServerDescribeServer {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    /** List of domain suffixes that can be used in account handles. */
    availableUserDomains: string[];
    did: At.DID;
    /** Contact information */
    contact?: Contact;
    /** If true, an invite code must be supplied to create an account on this instance. */
    inviteCodeRequired?: boolean;
    /** URLs of service policy documents. */
    links?: Links;
    /** If true, a phone verification token must be supplied to create an account on this instance. */
    phoneVerificationRequired?: boolean;
  }
  interface Contact extends TypedBase {
    email?: string;
  }
  interface Links extends TypedBase {
    privacyPolicy?: string;
    termsOfService?: string;
  }
}

/** Get all invite codes for the current account. Requires auth. */
export declare namespace ComAtprotoServerGetAccountInviteCodes {
  interface Params extends TypedBase {
    /**
     * Controls whether any new 'earned' but not 'created' invites should be created.
     * \@default true
     */
    createAvailable?: boolean;
    /** \@default true */
    includeUsed?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    codes: ComAtprotoServerDefs.InviteCode[];
  }
  interface Errors extends TypedBase {
    DuplicateCreate: {};
  }
}

/** Get a signed token on behalf of the requesting DID for the requested service. */
export declare namespace ComAtprotoServerGetServiceAuth {
  interface Params extends TypedBase {
    /** The DID of the service that the token will be used to authenticate with */
    aud: At.DID;
    /** The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope. */
    exp?: number;
    /** Lexicon (XRPC) method to bind the requested token to */
    lxm?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    token: string;
  }
  interface Errors extends TypedBase {
    BadExpiration: {};
  }
}

/** Get information about the current auth session. Requires auth. */
export declare namespace ComAtprotoServerGetSession {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    active?: boolean;
    didDoc?: unknown;
    email?: string;
    emailAuthFactor?: boolean;
    emailConfirmed?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
}

/** List all App Passwords. */
export declare namespace ComAtprotoServerListAppPasswords {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    passwords: AppPassword[];
  }
  interface Errors extends TypedBase {
    AccountTakedown: {};
  }
  interface AppPassword extends TypedBase {
    createdAt: string;
    name: string;
    privileged?: boolean;
  }
}

/** Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt'). */
export declare namespace ComAtprotoServerRefreshSession {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    accessJwt: string;
    did: At.DID;
    handle: At.Handle;
    refreshJwt: string;
    active?: boolean;
    didDoc?: unknown;
    /** Hosting status of the account. If not specified, then assume 'active'. */
    status?: "deactivated" | "suspended" | "takendown" | (string & {});
  }
  interface Errors extends TypedBase {
    AccountTakedown: {};
  }
}

/** Initiate a user account deletion via email. */
export declare namespace ComAtprotoServerRequestAccountDelete {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Request an email with a code to confirm ownership of email. */
export declare namespace ComAtprotoServerRequestEmailConfirmation {
  interface Params extends TypedBase {}
  type Input = undefined;
  type Output = undefined;
}

/** Request a token in order to update email. */
export declare namespace ComAtprotoServerRequestEmailUpdate {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    tokenRequired: boolean;
  }
}

/** Initiate a user account password reset via email. */
export declare namespace ComAtprotoServerRequestPasswordReset {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    email: string;
  }
  type Output = undefined;
}

/** Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented. */
export declare namespace ComAtprotoServerReserveSigningKey {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** The DID to reserve a key for. */
    did?: At.DID;
  }
  interface Output extends TypedBase {
    /** The public key for the reserved signing key, in did:key serialization. */
    signingKey: string;
  }
}

/** Reset a user account password using a token. */
export declare namespace ComAtprotoServerResetPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    password: string;
    token: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    ExpiredToken: {};
    InvalidToken: {};
  }
}

/** Revoke an App Password by name. */
export declare namespace ComAtprotoServerRevokeAppPassword {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    name: string;
  }
  type Output = undefined;
}

/** Update an account's email. */
export declare namespace ComAtprotoServerUpdateEmail {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    email: string;
    emailAuthFactor?: boolean;
    /** Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed. */
    token?: string;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    ExpiredToken: {};
    InvalidToken: {};
    TokenRequired: {};
  }
}

/** Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlob {
  interface Params extends TypedBase {
    /** The CID of the blob to fetch */
    cid: At.CID;
    /** The DID of the account. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    BlobNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlocks {
  interface Params extends TypedBase {
    cids: At.CID[];
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    BlockNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/**
 * DEPRECATED - please use com.atproto.sync.getRepo instead
 * \@deprecated
 */
export declare namespace ComAtprotoSyncGetCheckout {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  type Output = Uint8Array;
}

/**
 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
 * \@deprecated
 */
export declare namespace ComAtprotoSyncGetHead {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    root: At.CID;
  }
  interface Errors extends TypedBase {
    HeadNotFound: {};
  }
}

/** Get the current commit CID & revision of the specified repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetLatestCommit {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    cid: At.CID;
    rev: At.TID;
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetRecord {
  interface Params extends TypedBase {
    collection: string;
    /** The DID of the repo. */
    did: At.DID;
    /** Record Key */
    rkey: At.RKEY;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    RecordNotFound: {};
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetRepo {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
    /** The revision ('rev') of the repo to create a diff from. */
    since?: At.TID;
  }
  type Input = undefined;
  type Output = Uint8Array;
  interface Errors extends TypedBase {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncGetRepoStatus {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    active: boolean;
    did: At.DID;
    /** Optional field, the current rev of the repo, if active=true */
    rev?: At.TID;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?:
      | "deactivated"
      | "deleted"
      | "desynchronized"
      | "suspended"
      | "takendown"
      | "throttled"
      | (string & {});
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
  }
}

/** List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncListBlobs {
  interface Params extends TypedBase {
    /** The DID of the repo. */
    did: At.DID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
    /** Optional revision of the repo to list blobs since. */
    since?: At.TID;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    cids: At.CID[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    RepoNotFound: {};
    RepoTakendown: {};
    RepoSuspended: {};
    RepoDeactivated: {};
  }
}

/** Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncListRepos {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: Repo[];
    cursor?: string;
  }
  interface Repo extends TypedBase {
    did: At.DID;
    /** Current repo commit CID */
    head: At.CID;
    rev: At.TID;
    active?: boolean;
    /** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
    status?:
      | "deactivated"
      | "deleted"
      | "desynchronized"
      | "suspended"
      | "takendown"
      | "throttled"
      | (string & {});
  }
}

/** Enumerates all the DIDs which have records with the given collection NSID. */
export declare namespace ComAtprotoSyncListReposByCollection {
  interface Params extends TypedBase {
    collection: string;
    cursor?: string;
    /**
     * Maximum size of response set. Recommend setting a large maximum (1000+) when enumerating large DID lists.
     * Minimum: 1
     * Maximum: 2000
     * \@default 500
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: Repo[];
    cursor?: string;
  }
  interface Repo extends TypedBase {
    did: At.DID;
  }
}

/** Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay. DEPRECATED: just use com.atproto.sync.requestCrawl */
export declare namespace ComAtprotoSyncNotifyOfUpdate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Hostname of the current service (usually a PDS) that is notifying of update. */
    hostname: string;
  }
  type Output = undefined;
}

/** Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth. */
export declare namespace ComAtprotoSyncRequestCrawl {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Hostname of the current service (eg, PDS) that is requesting to be crawled. */
    hostname: string;
  }
  type Output = undefined;
}

export declare namespace ComAtprotoSyncSubscribeRepos {
  interface Params extends TypedBase {
    /** The last known event seq number to backfill from. */
    cursor?: number;
  }
  type Message = TypeUnion<Account | Commit | Identity | Info | Sync>;
  interface Errors extends TypedBase {
    FutureCursor: {};
    ConsumerTooSlow: {};
  }
  /** Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active. */
  interface Account extends TypedBase {
    /** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
    active: boolean;
    did: At.DID;
    seq: number;
    time: string;
    /** If active=false, this optional field indicates a reason for why the account is not active. */
    status?:
      | "deactivated"
      | "deleted"
      | "desynchronized"
      | "suspended"
      | "takendown"
      | "throttled"
      | (string & {});
  }
  /** Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature. */
  interface Commit extends TypedBase {
    /**
     * DEPRECATED -- will soon always be empty. List of new blobs (by CID) referenced by records in this commit.
     * \@deprecated
     */
    blobs: At.CIDLink[];
    /** CAR file containing relevant blocks, as a diff since the previous repo state. The commit must be included as a block, and the commit block CID must be the first entry in the CAR header 'roots' list. */
    blocks: At.Bytes;
    /** Repo commit object CID. */
    commit: At.CIDLink;
    /**
     * Maximum array length: 200
     * List of repo mutation operations in this commit (eg, records created, updated, or deleted).
     */
    ops: RepoOp[];
    /**
     * DEPRECATED -- unused
     * \@deprecated
     */
    rebase: boolean;
    /** The repo this event comes from. Note that all other message types name this field 'did'. */
    repo: At.DID;
    /** The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event. */
    rev: At.TID;
    /** The stream sequence number of this message. */
    seq: number;
    /** The rev of the last emitted commit from this repo (if any). */
    since: At.TID | null;
    /** Timestamp of when this message was originally broadcast. */
    time: string;
    /**
     * DEPRECATED -- replaced by #sync event and data limits. Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data.
     * \@deprecated
     */
    tooBig: boolean;
    /** The root CID of the MST tree for the previous commit from this repo (indicated by the 'since' revision field in this message). Corresponds to the 'data' field in the repo commit object. NOTE: this field is effectively required for the 'inductive' version of firehose. */
    prevData?: At.CIDLink;
  }
  /** Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache. */
  interface Identity extends TypedBase {
    did: At.DID;
    seq: number;
    time: string;
    /** The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details. */
    handle?: At.Handle;
  }
  interface Info extends TypedBase {
    name: "OutdatedCursor" | (string & {});
    message?: string;
  }
  /** A repo operation, ie a mutation of a single record. */
  interface RepoOp extends TypedBase {
    action: "create" | "delete" | "update" | (string & {});
    /** For creates and updates, the new record CID. For deletions, null. */
    cid: At.CIDLink | null;
    path: string;
    /** For updates and deletes, the previous record CID (required for inductive firehose). For creations, field should not be defined. */
    prev?: At.CIDLink;
  }
  /** Updates the repo to a new state, without necessarily including that state on the firehose. Used to recover from broken commit streams, data loss incidents, or in situations where upstream host does not know recent state of the repository. */
  interface Sync extends TypedBase {
    /** CAR file containing the commit, as a block. The CAR header must include the commit block CID as the first 'root'. */
    blocks: At.Bytes;
    /** The account this repo event corresponds to. Must match that in the commit object. */
    did: At.DID;
    /** The rev of the commit. This value must match that in the commit object. */
    rev: string;
    /** The stream sequence number of this message. */
    seq: number;
    /** Timestamp of when this message was originally broadcast. */
    time: string;
  }
}

/** Add a handle to the set of reserved handles. */
export declare namespace ComAtprotoTempAddReservedHandle {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    handle: string;
  }
  interface Output extends TypedBase {}
}

/** Check accounts location in signup queue. */
export declare namespace ComAtprotoTempCheckSignupQueue {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    activated: boolean;
    estimatedTimeMs?: number;
    placeInQueue?: number;
  }
}

/**
 * DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.
 * \@deprecated
 */
export declare namespace ComAtprotoTempFetchLabels {
  interface Params extends TypedBase {
    /**
     * Minimum: 1
     * Maximum: 250
     * \@default 50
     */
    limit?: number;
    since?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    labels: ComAtprotoLabelDefs.Label[];
  }
}

/** Request a verification code to be sent to the supplied phone number */
export declare namespace ComAtprotoTempRequestPhoneVerification {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    phoneNumber: string;
  }
  type Output = undefined;
}

/** Administrative action to create a new, re-usable communication (email for now) template. */
export declare namespace ToolsOzoneCommunicationCreateTemplate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Content of the template, markdown supported, can contain variable placeholders. */
    contentMarkdown: string;
    /** Name of the template. */
    name: string;
    /** Subject of the message, used in emails. */
    subject: string;
    /** DID of the user who is creating the template. */
    createdBy?: At.DID;
    /** Message language. */
    lang?: string;
  }
  type Output = ToolsOzoneCommunicationDefs.TemplateView;
  interface Errors extends TypedBase {
    DuplicateTemplateName: {};
  }
}

export declare namespace ToolsOzoneCommunicationDefs {
  interface TemplateView extends TypedBase {
    /** Subject of the message, used in emails. */
    contentMarkdown: string;
    createdAt: string;
    disabled: boolean;
    id: string;
    /** DID of the user who last updated the template. */
    lastUpdatedBy: At.DID;
    /** Name of the template. */
    name: string;
    updatedAt: string;
    /** Message language. */
    lang?: string;
    /** Content of the template, can contain markdown and variable placeholders. */
    subject?: string;
  }
}

/** Delete a communication template. */
export declare namespace ToolsOzoneCommunicationDeleteTemplate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    id: string;
  }
  type Output = undefined;
}

/** Get list of all communication templates. */
export declare namespace ToolsOzoneCommunicationListTemplates {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    communicationTemplates: ToolsOzoneCommunicationDefs.TemplateView[];
  }
}

/** Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only. */
export declare namespace ToolsOzoneCommunicationUpdateTemplate {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** ID of the template to be updated. */
    id: string;
    /** Content of the template, markdown supported, can contain variable placeholders. */
    contentMarkdown?: string;
    disabled?: boolean;
    /** Message language. */
    lang?: string;
    /** Name of the template. */
    name?: string;
    /** Subject of the message, used in emails. */
    subject?: string;
    /** DID of the user who is updating the template. */
    updatedBy?: At.DID;
  }
  type Output = ToolsOzoneCommunicationDefs.TemplateView;
  interface Errors extends TypedBase {
    DuplicateTemplateName: {};
  }
}

export declare namespace ToolsOzoneModerationDefs {
  /** Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface AccountEvent extends TypedBase {
    /** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
    active: boolean;
    timestamp: string;
    comment?: string;
    status?:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | "tombstoned"
      | "unknown"
      | (string & {});
  }
  interface AccountHosting extends TypedBase {
    status:
      | "deactivated"
      | "deleted"
      | "suspended"
      | "takendown"
      | "unknown"
      | (string & {});
    createdAt?: string;
    deactivatedAt?: string;
    deletedAt?: string;
    reactivatedAt?: string;
    updatedAt?: string;
  }
  /** Statistics about a particular account subject */
  interface AccountStats extends TypedBase {
    /** Total number of appeals against a moderation action on the account */
    appealCount?: number;
    /** Number of times the account was escalated */
    escalateCount?: number;
    /** Total number of reports on the account */
    reportCount?: number;
    /** Number of times the account was suspended */
    suspendCount?: number;
    /** Number of times the account was taken down */
    takedownCount?: number;
  }
  interface BlobView extends TypedBase {
    cid: At.CID;
    createdAt: string;
    mimeType: string;
    size: number;
    details?: TypeUnion<ImageDetails | VideoDetails>;
    moderation?: Moderation;
  }
  /** Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface IdentityEvent extends TypedBase {
    timestamp: string;
    comment?: string;
    handle?: At.Handle;
    pdsHost?: string;
    tombstone?: boolean;
  }
  interface ImageDetails extends TypedBase {
    height: number;
    width: number;
  }
  interface Moderation extends TypedBase {
    subjectStatus?: SubjectStatusView;
  }
  interface ModerationDetail extends TypedBase {
    subjectStatus?: SubjectStatusView;
  }
  interface ModEventAcknowledge extends TypedBase {
    /** If true, all other reports on content authored by this account will be resolved (acknowledged). */
    acknowledgeAccountSubjects?: boolean;
    comment?: string;
  }
  /** Add a comment to a subject. An empty comment will clear any previously set sticky comment. */
  interface ModEventComment extends TypedBase {
    comment?: string;
    /** Make the comment persistent on the subject */
    sticky?: boolean;
  }
  /** Divert a record's blobs to a 3rd party service for further scanning/tagging */
  interface ModEventDivert extends TypedBase {
    comment?: string;
  }
  /** Keep a log of outgoing email to a user */
  interface ModEventEmail extends TypedBase {
    /** The subject line of the email sent to the user. */
    subjectLine: string;
    /** Additional comment about the outgoing comm. */
    comment?: string;
    /** The content of the email sent to the user. */
    content?: string;
  }
  interface ModEventEscalate extends TypedBase {
    comment?: string;
  }
  /** Apply/Negate labels on a subject */
  interface ModEventLabel extends TypedBase {
    createLabelVals: string[];
    negateLabelVals: string[];
    comment?: string;
    /** Indicates how long the label will remain on the subject. Only applies on labels that are being added. */
    durationInHours?: number;
  }
  /** Mute incoming reports on a subject */
  interface ModEventMute extends TypedBase {
    /** Indicates how long the subject should remain muted. */
    durationInHours: number;
    comment?: string;
  }
  /** Mute incoming reports from an account */
  interface ModEventMuteReporter extends TypedBase {
    comment?: string;
    /** Indicates how long the account should remain muted. Falsy value here means a permanent mute. */
    durationInHours?: number;
  }
  /** Set priority score of the subject. Higher score means higher priority. */
  interface ModEventPriorityScore extends TypedBase {
    /**
     * Minimum: 0
     * Maximum: 100
     */
    score: number;
    comment?: string;
  }
  /** Report a subject */
  interface ModEventReport extends TypedBase {
    reportType: ComAtprotoModerationDefs.ReasonType;
    comment?: string;
    /** Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject. */
    isReporterMuted?: boolean;
  }
  /** Resolve appeal on a subject */
  interface ModEventResolveAppeal extends TypedBase {
    /** Describe resolution. */
    comment?: string;
  }
  /** Revert take down action on a subject */
  interface ModEventReverseTakedown extends TypedBase {
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  /** Add/Remove a tag on a subject */
  interface ModEventTag extends TypedBase {
    /** Tags to be added to the subject. If already exists, won't be duplicated. */
    add: string[];
    /** Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated. */
    remove: string[];
    /** Additional comment about added/removed tags. */
    comment?: string;
  }
  /** Take down a subject permanently or temporarily */
  interface ModEventTakedown extends TypedBase {
    /** If true, all other reports on content authored by this account will be resolved (acknowledged). */
    acknowledgeAccountSubjects?: boolean;
    comment?: string;
    /** Indicates how long the takedown should be in effect before automatically expiring. */
    durationInHours?: number;
    /**
     * Names/Keywords of the policies that drove the decision.
     * Maximum array length: 5
     */
    policies?: string[];
  }
  /** Unmute action on a subject */
  interface ModEventUnmute extends TypedBase {
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  /** Unmute incoming reports from an account */
  interface ModEventUnmuteReporter extends TypedBase {
    /** Describe reasoning behind the reversal. */
    comment?: string;
  }
  interface ModEventView extends TypedBase {
    createdAt: string;
    createdBy: At.DID;
    event: TypeUnion<
      | AccountEvent
      | IdentityEvent
      | ModEventAcknowledge
      | ModEventComment
      | ModEventDivert
      | ModEventEmail
      | ModEventEscalate
      | ModEventLabel
      | ModEventMute
      | ModEventMuteReporter
      | ModEventPriorityScore
      | ModEventReport
      | ModEventResolveAppeal
      | ModEventReverseTakedown
      | ModEventTag
      | ModEventTakedown
      | ModEventUnmute
      | ModEventUnmuteReporter
      | RecordEvent
    >;
    id: number;
    subject: TypeUnion<
      | ChatBskyConvoDefs.MessageRef
      | ComAtprotoAdminDefs.RepoRef
      | ComAtprotoRepoStrongRef.Main
    >;
    subjectBlobCids: string[];
    creatorHandle?: string;
    subjectHandle?: string;
  }
  interface ModEventViewDetail extends TypedBase {
    createdAt: string;
    createdBy: At.DID;
    event: TypeUnion<
      | AccountEvent
      | IdentityEvent
      | ModEventAcknowledge
      | ModEventComment
      | ModEventDivert
      | ModEventEmail
      | ModEventEscalate
      | ModEventLabel
      | ModEventMute
      | ModEventMuteReporter
      | ModEventPriorityScore
      | ModEventReport
      | ModEventResolveAppeal
      | ModEventReverseTakedown
      | ModEventTag
      | ModEventTakedown
      | ModEventUnmute
      | ModEventUnmuteReporter
      | RecordEvent
    >;
    id: number;
    subject: TypeUnion<
      RecordView | RecordViewNotFound | RepoView | RepoViewNotFound
    >;
    subjectBlobs: BlobView[];
  }
  /** Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking. */
  interface RecordEvent extends TypedBase {
    op: "create" | "delete" | "update" | (string & {});
    timestamp: string;
    cid?: At.CID;
    comment?: string;
  }
  interface RecordHosting extends TypedBase {
    status: "deleted" | "unknown" | (string & {});
    createdAt?: string;
    deletedAt?: string;
    updatedAt?: string;
  }
  /** Statistics about a set of record subject items */
  interface RecordsStats extends TypedBase {
    /** Number of items that were appealed at least once */
    appealedCount?: number;
    /** Number of items that were escalated at least once */
    escalatedCount?: number;
    /** Number of item currently in "reviewOpen" or "reviewEscalated" state */
    pendingCount?: number;
    /** Number of item currently in "reviewNone" or "reviewClosed" state */
    processedCount?: number;
    /** Number of items that were reported at least once */
    reportedCount?: number;
    /** Total number of item in the set */
    subjectCount?: number;
    /** Number of item currently taken down */
    takendownCount?: number;
    /** Cumulative sum of the number of reports on the items in the set */
    totalReports?: number;
  }
  interface RecordView extends TypedBase {
    blobCids: At.CID[];
    cid: At.CID;
    indexedAt: string;
    moderation: Moderation;
    repo: RepoView;
    uri: At.Uri;
    value: unknown;
  }
  interface RecordViewDetail extends TypedBase {
    blobs: BlobView[];
    cid: At.CID;
    indexedAt: string;
    moderation: ModerationDetail;
    repo: RepoView;
    uri: At.Uri;
    value: unknown;
    labels?: ComAtprotoLabelDefs.Label[];
  }
  interface RecordViewNotFound extends TypedBase {
    uri: At.Uri;
  }
  interface ReporterStats extends TypedBase {
    /** The total number of reports made by the user on accounts. */
    accountReportCount: number;
    did: At.DID;
    /** The total number of accounts labeled as a result of the user's reports. */
    labeledAccountCount: number;
    /** The total number of records labeled as a result of the user's reports. */
    labeledRecordCount: number;
    /** The total number of reports made by the user on records. */
    recordReportCount: number;
    /** The total number of accounts reported by the user. */
    reportedAccountCount: number;
    /** The total number of records reported by the user. */
    reportedRecordCount: number;
    /** The total number of accounts taken down as a result of the user's reports. */
    takendownAccountCount: number;
    /** The total number of records taken down as a result of the user's reports. */
    takendownRecordCount: number;
  }
  interface RepoView extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    moderation: Moderation;
    relatedRecords: unknown[];
    deactivatedAt?: string;
    email?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invitesDisabled?: boolean;
    threatSignatures?: ComAtprotoAdminDefs.ThreatSignature[];
  }
  interface RepoViewDetail extends TypedBase {
    did: At.DID;
    handle: At.Handle;
    indexedAt: string;
    moderation: ModerationDetail;
    relatedRecords: unknown[];
    deactivatedAt?: string;
    email?: string;
    emailConfirmedAt?: string;
    invitedBy?: ComAtprotoServerDefs.InviteCode;
    inviteNote?: string;
    invites?: ComAtprotoServerDefs.InviteCode[];
    invitesDisabled?: boolean;
    labels?: ComAtprotoLabelDefs.Label[];
    threatSignatures?: ComAtprotoAdminDefs.ThreatSignature[];
  }
  interface RepoViewNotFound extends TypedBase {
    did: At.DID;
  }
  type ReviewClosed = "tools.ozone.moderation.defs#reviewClosed";
  type ReviewEscalated = "tools.ozone.moderation.defs#reviewEscalated";
  type ReviewNone = "tools.ozone.moderation.defs#reviewNone";
  type ReviewOpen = "tools.ozone.moderation.defs#reviewOpen";
  type SubjectReviewState =
    | "#reviewClosed"
    | "#reviewEscalated"
    | "#reviewNone"
    | "#reviewOpen"
    | (string & {});
  interface SubjectStatusView extends TypedBase {
    /** Timestamp referencing the first moderation status impacting event was emitted on the subject */
    createdAt: string;
    id: number;
    reviewState: SubjectReviewState;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    /** Timestamp referencing when the last update was made to the moderation status of the subject */
    updatedAt: string;
    /** Statistics related to the account subject */
    accountStats?: AccountStats;
    /** True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators. */
    appealed?: boolean;
    /** Sticky comment on the subject. */
    comment?: string;
    hosting?: TypeUnion<AccountHosting | RecordHosting>;
    /** Timestamp referencing when the author of the subject appealed a moderation action */
    lastAppealedAt?: string;
    lastReportedAt?: string;
    lastReviewedAt?: string;
    lastReviewedBy?: At.DID;
    muteReportingUntil?: string;
    muteUntil?: string;
    /**
     * Numeric value representing the level of priority. Higher score means higher priority.
     * Minimum: 0
     * Maximum: 100
     */
    priorityScore?: number;
    /** Statistics related to the record subjects authored by the subject's account */
    recordsStats?: RecordsStats;
    subjectBlobCids?: At.CID[];
    subjectRepoHandle?: string;
    suspendUntil?: string;
    tags?: string[];
    takendown?: boolean;
  }
  interface VideoDetails extends TypedBase {
    height: number;
    length: number;
    width: number;
  }
}

/** Take a moderation action on an actor. */
export declare namespace ToolsOzoneModerationEmitEvent {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    createdBy: At.DID;
    event: TypeUnion<
      | ToolsOzoneModerationDefs.AccountEvent
      | ToolsOzoneModerationDefs.IdentityEvent
      | ToolsOzoneModerationDefs.ModEventAcknowledge
      | ToolsOzoneModerationDefs.ModEventComment
      | ToolsOzoneModerationDefs.ModEventDivert
      | ToolsOzoneModerationDefs.ModEventEmail
      | ToolsOzoneModerationDefs.ModEventEscalate
      | ToolsOzoneModerationDefs.ModEventLabel
      | ToolsOzoneModerationDefs.ModEventMute
      | ToolsOzoneModerationDefs.ModEventMuteReporter
      | ToolsOzoneModerationDefs.ModEventPriorityScore
      | ToolsOzoneModerationDefs.ModEventReport
      | ToolsOzoneModerationDefs.ModEventResolveAppeal
      | ToolsOzoneModerationDefs.ModEventReverseTakedown
      | ToolsOzoneModerationDefs.ModEventTag
      | ToolsOzoneModerationDefs.ModEventTakedown
      | ToolsOzoneModerationDefs.ModEventUnmute
      | ToolsOzoneModerationDefs.ModEventUnmuteReporter
      | ToolsOzoneModerationDefs.RecordEvent
    >;
    subject: TypeUnion<
      ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
    >;
    subjectBlobCids?: At.CID[];
  }
  type Output = ToolsOzoneModerationDefs.ModEventView;
  interface Errors extends TypedBase {
    SubjectHasAction: {};
  }
}

/** Get details about a moderation event. */
export declare namespace ToolsOzoneModerationGetEvent {
  interface Params extends TypedBase {
    id: number;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.ModEventViewDetail;
}

/** Get details about a record. */
export declare namespace ToolsOzoneModerationGetRecord {
  interface Params extends TypedBase {
    uri: At.Uri;
    cid?: At.CID;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.RecordViewDetail;
  interface Errors extends TypedBase {
    RecordNotFound: {};
  }
}

/** Get details about some records. */
export declare namespace ToolsOzoneModerationGetRecords {
  interface Params extends TypedBase {
    /** Maximum array length: 100 */
    uris: At.Uri[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    records: TypeUnion<
      | ToolsOzoneModerationDefs.RecordViewDetail
      | ToolsOzoneModerationDefs.RecordViewNotFound
    >[];
  }
}

/** Get details about a repository. */
export declare namespace ToolsOzoneModerationGetRepo {
  interface Params extends TypedBase {
    did: At.DID;
  }
  type Input = undefined;
  type Output = ToolsOzoneModerationDefs.RepoViewDetail;
  interface Errors extends TypedBase {
    RepoNotFound: {};
  }
}

/** Get reporter stats for a list of users. */
export declare namespace ToolsOzoneModerationGetReporterStats {
  interface Params extends TypedBase {
    /** Maximum array length: 100 */
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    stats: ToolsOzoneModerationDefs.ReporterStats[];
  }
}

/** Get details about some repositories. */
export declare namespace ToolsOzoneModerationGetRepos {
  interface Params extends TypedBase {
    /** Maximum array length: 100 */
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: TypeUnion<
      | ToolsOzoneModerationDefs.RepoViewDetail
      | ToolsOzoneModerationDefs.RepoViewNotFound
    >[];
  }
}

/** List moderation events related to a subject. */
export declare namespace ToolsOzoneModerationQueryEvents {
  interface Params extends TypedBase {
    /** If specified, only events where all of these labels were added are returned */
    addedLabels?: string[];
    /** If specified, only events where all of these tags were added are returned */
    addedTags?: string[];
    /**
     * If specified, only events where the subject belongs to the given collections will be returned. When subjectType is set to 'account', this will be ignored.
     * Maximum array length: 20
     */
    collections?: string[];
    /** If specified, only events with comments containing the keyword are returned. Apply || separator to use multiple keywords and match using OR condition. */
    comment?: string;
    /** Retrieve events created after a given timestamp */
    createdAfter?: string;
    /** Retrieve events created before a given timestamp */
    createdBefore?: string;
    createdBy?: At.DID;
    cursor?: string;
    /** If true, only events with comments are returned */
    hasComment?: boolean;
    /**
     * If true, events on all record types (posts, lists, profile etc.) or records from given 'collections' param, owned by the did are returned.
     * \@default false
     */
    includeAllUserRecords?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** If specified, only events where the action policies match any of the given policies are returned */
    policies?: string[];
    /** If specified, only events where all of these labels were removed are returned */
    removedLabels?: string[];
    /** If specified, only events where all of these tags were removed are returned */
    removedTags?: string[];
    reportTypes?: string[];
    /**
     * Sort direction for the events. Defaults to descending order of created at timestamp.
     * \@default "desc"
     */
    sortDirection?: "asc" | "desc";
    subject?: string;
    /** If specified, only events where the subject is of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored. */
    subjectType?: "account" | "record" | (string & {});
    /** The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned. */
    types?: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    events: ToolsOzoneModerationDefs.ModEventView[];
    cursor?: string;
  }
}

/** View moderation statuses of subjects (record or repo). */
export declare namespace ToolsOzoneModerationQueryStatuses {
  interface Params extends TypedBase {
    /** Get subjects in unresolved appealed status */
    appealed?: boolean;
    /**
     * If specified, subjects belonging to the given collections will be returned. When subjectType is set to 'account', this will be ignored.
     * Maximum array length: 20
     */
    collections?: string[];
    /** Search subjects by keyword from comments */
    comment?: string;
    cursor?: string;
    excludeTags?: string[];
    /** Search subjects where the associated record/account was deleted after a given timestamp */
    hostingDeletedAfter?: string;
    /** Search subjects where the associated record/account was deleted before a given timestamp */
    hostingDeletedBefore?: string;
    /** Search subjects by the status of the associated record/account */
    hostingStatuses?: string[];
    /** Search subjects where the associated record/account was updated after a given timestamp */
    hostingUpdatedAfter?: string;
    /** Search subjects where the associated record/account was updated before a given timestamp */
    hostingUpdatedBefore?: string;
    ignoreSubjects?: string[];
    /** All subjects, or subjects from given 'collections' param, belonging to the account specified in the 'subject' param will be returned. */
    includeAllUserRecords?: boolean;
    /** By default, we don't include muted subjects in the results. Set this to true to include them. */
    includeMuted?: boolean;
    /** Get all subject statuses that were reviewed by a specific moderator */
    lastReviewedBy?: At.DID;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** If specified, only subjects that belong to an account that has at least this many suspensions will be returned. */
    minAccountSuspendCount?: number;
    /**
     * If specified, only subjects that have priority score value above the given value will be returned.
     * Minimum: 0
     * Maximum: 100
     */
    minPriorityScore?: number;
    /** If specified, only subjects that belong to an account that has at least this many reported records will be returned. */
    minReportedRecordsCount?: number;
    /** If specified, only subjects that belong to an account that has at least this many taken down records will be returned. */
    minTakendownRecordsCount?: number;
    /** When set to true, only muted subjects and reporters will be returned. */
    onlyMuted?: boolean;
    /** Number of queues being used by moderators. Subjects will be split among all queues. */
    queueCount?: number;
    /** Index of the queue to fetch subjects from. Works only when queueCount value is specified. */
    queueIndex?: number;
    /** A seeder to shuffle/balance the queue items. */
    queueSeed?: string;
    /** Search subjects reported after a given timestamp */
    reportedAfter?: string;
    /** Search subjects reported before a given timestamp */
    reportedBefore?: string;
    /** Search subjects reviewed after a given timestamp */
    reviewedAfter?: string;
    /** Search subjects reviewed before a given timestamp */
    reviewedBefore?: string;
    /** Specify when fetching subjects in a certain state */
    reviewState?: string;
    /** \@default "desc" */
    sortDirection?: "asc" | "desc";
    /** \@default "lastReportedAt" */
    sortField?:
      | "lastReviewedAt"
      | "lastReportedAt"
      | "reportedRecordsCount"
      | "takendownRecordsCount"
      | "priorityScore";
    /** The subject to get the status for. */
    subject?: string;
    /** If specified, subjects of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored. */
    subjectType?: "account" | "record" | (string & {});
    /**
     * Maximum array length: 25
     * Items in this array are applied with OR filters. To apply AND filter, put all tags in the same string and separate using && characters
     */
    tags?: string[];
    /** Get subjects that were taken down */
    takendown?: boolean;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    subjectStatuses: ToolsOzoneModerationDefs.SubjectStatusView[];
    cursor?: string;
  }
}

/** Find repositories based on a search term. */
export declare namespace ToolsOzoneModerationSearchRepos {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    q?: string;
    /**
     * DEPRECATED: use 'q' instead
     * \@deprecated
     */
    term?: string;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    repos: ToolsOzoneModerationDefs.RepoView[];
    cursor?: string;
  }
}

/** Get details about ozone's server configuration. */
export declare namespace ToolsOzoneServerGetConfig {
  interface Params extends TypedBase {}
  type Input = undefined;
  interface Output extends TypedBase {
    appview?: ServiceConfig;
    blobDivert?: ServiceConfig;
    chat?: ServiceConfig;
    pds?: ServiceConfig;
    viewer?: ViewerConfig;
  }
  interface ServiceConfig extends TypedBase {
    url?: string;
  }
  interface ViewerConfig extends TypedBase {
    role?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
}

/** Add values to a specific set. Attempting to add values to a set that does not exist will result in an error. */
export declare namespace ToolsOzoneSetAddValues {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Name of the set to add values to */
    name: string;
    /**
     * Array of string values to add to the set
     * Minimum array length: 1
     * Maximum array length: 1000
     */
    values: string[];
  }
  type Output = undefined;
}

export declare namespace ToolsOzoneSetDefs {
  interface Set extends TypedBase {
    /**
     * Minimum string length: 3
     * Maximum string length: 128
     */
    name: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
  }
  interface SetView extends TypedBase {
    createdAt: string;
    /**
     * Minimum string length: 3
     * Maximum string length: 128
     */
    name: string;
    setSize: number;
    updatedAt: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
  }
}

/** Delete an entire set. Attempting to delete a set that does not exist will result in an error. */
export declare namespace ToolsOzoneSetDeleteSet {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Name of the set to delete */
    name: string;
  }
  interface Output extends TypedBase {}
  interface Errors extends TypedBase {
    SetNotFound: {};
  }
}

/** Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error */
export declare namespace ToolsOzoneSetDeleteValues {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /** Name of the set to delete values from */
    name: string;
    /**
     * Array of string values to delete from the set
     * Minimum array length: 1
     */
    values: string[];
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    SetNotFound: {};
  }
}

/** Get a specific set and its values */
export declare namespace ToolsOzoneSetGetValues {
  interface Params extends TypedBase {
    name: string;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 1000
     * \@default 100
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    set: ToolsOzoneSetDefs.SetView;
    values: string[];
    cursor?: string;
  }
  interface Errors extends TypedBase {
    SetNotFound: {};
  }
}

/** Query available sets */
export declare namespace ToolsOzoneSetQuerySets {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    namePrefix?: string;
    /** \@default "name" */
    sortBy?: "name" | "createdAt" | "updatedAt";
    /**
     * Defaults to ascending order of name field.
     * \@default "asc"
     */
    sortDirection?: "asc" | "desc";
  }
  type Input = undefined;
  interface Output extends TypedBase {
    sets: ToolsOzoneSetDefs.SetView[];
    cursor?: string;
  }
}

/** Create or update set metadata */
export declare namespace ToolsOzoneSetUpsertSet {
  interface Params extends TypedBase {}
  type Input = ToolsOzoneSetDefs.Set;
  type Output = ToolsOzoneSetDefs.SetView;
}

export declare namespace ToolsOzoneSettingDefs {
  interface Option extends TypedBase {
    createdBy: At.DID;
    did: At.DID;
    key: string;
    lastUpdatedBy: At.DID;
    scope: "instance" | "personal" | (string & {});
    value: unknown;
    createdAt?: string;
    /**
     * Maximum string length: 10240
     * Maximum grapheme length: 1024
     */
    description?: string;
    managerRole?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
    updatedAt?: string;
  }
}

/** List settings with optional filtering */
export declare namespace ToolsOzoneSettingListOptions {
  interface Params extends TypedBase {
    cursor?: string;
    /**
     * Filter for only the specified keys. Ignored if prefix is provided
     * Maximum array length: 100
     */
    keys?: string[];
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    /** Filter keys by prefix */
    prefix?: string;
    /** \@default "instance" */
    scope?: "instance" | "personal" | (string & {});
  }
  type Input = undefined;
  interface Output extends TypedBase {
    options: ToolsOzoneSettingDefs.Option[];
    cursor?: string;
  }
}

/** Delete settings by key */
export declare namespace ToolsOzoneSettingRemoveOptions {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    /**
     * Minimum array length: 1
     * Maximum array length: 200
     */
    keys: string[];
    scope: "instance" | "personal" | (string & {});
  }
  interface Output extends TypedBase {}
}

/** Create or update setting option */
export declare namespace ToolsOzoneSettingUpsertOption {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    key: string;
    scope: "instance" | "personal" | (string & {});
    value: unknown;
    /** Maximum string length: 2000 */
    description?: string;
    managerRole?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
  interface Output extends TypedBase {
    option: ToolsOzoneSettingDefs.Option;
  }
}

export declare namespace ToolsOzoneSignatureDefs {
  interface SigDetail extends TypedBase {
    property: string;
    value: string;
  }
}

/** Find all correlated threat signatures between 2 or more accounts. */
export declare namespace ToolsOzoneSignatureFindCorrelation {
  interface Params extends TypedBase {
    dids: At.DID[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    details: ToolsOzoneSignatureDefs.SigDetail[];
  }
}

/** Get accounts that share some matching threat signatures with the root account. */
export declare namespace ToolsOzoneSignatureFindRelatedAccounts {
  interface Params extends TypedBase {
    did: At.DID;
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    accounts: RelatedAccount[];
    cursor?: string;
  }
  interface RelatedAccount extends TypedBase {
    account: ComAtprotoAdminDefs.AccountView;
    similarities?: ToolsOzoneSignatureDefs.SigDetail[];
  }
}

/** Search for accounts that match one or more threat signature values. */
export declare namespace ToolsOzoneSignatureSearchAccounts {
  interface Params extends TypedBase {
    values: string[];
    cursor?: string;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
  }
  type Input = undefined;
  interface Output extends TypedBase {
    accounts: ComAtprotoAdminDefs.AccountView[];
    cursor?: string;
  }
}

/** Add a member to the ozone team. Requires admin role. */
export declare namespace ToolsOzoneTeamAddMember {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    role:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
  type Output = ToolsOzoneTeamDefs.Member;
  interface Errors extends TypedBase {
    MemberAlreadyExists: {};
  }
}

export declare namespace ToolsOzoneTeamDefs {
  interface Member extends TypedBase {
    did: At.DID;
    role: "#roleAdmin" | "#roleModerator" | "#roleTriage" | (string & {});
    createdAt?: string;
    disabled?: boolean;
    lastUpdatedBy?: string;
    profile?: AppBskyActorDefs.ProfileViewDetailed;
    updatedAt?: string;
  }
  type RoleAdmin = "tools.ozone.team.defs#roleAdmin";
  type RoleModerator = "tools.ozone.team.defs#roleModerator";
  type RoleTriage = "tools.ozone.team.defs#roleTriage";
}

/** Delete a member from ozone team. Requires admin role. */
export declare namespace ToolsOzoneTeamDeleteMember {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
  }
  type Output = undefined;
  interface Errors extends TypedBase {
    MemberNotFound: {};
    CannotDeleteSelf: {};
  }
}

/** List all members with access to the ozone service. */
export declare namespace ToolsOzoneTeamListMembers {
  interface Params extends TypedBase {
    cursor?: string;
    disabled?: boolean;
    /**
     * Minimum: 1
     * Maximum: 100
     * \@default 50
     */
    limit?: number;
    q?: string;
    roles?: string[];
  }
  type Input = undefined;
  interface Output extends TypedBase {
    members: ToolsOzoneTeamDefs.Member[];
    cursor?: string;
  }
}

/** Update a member in the ozone service. Requires admin role. */
export declare namespace ToolsOzoneTeamUpdateMember {
  interface Params extends TypedBase {}
  interface Input extends TypedBase {
    did: At.DID;
    disabled?: boolean;
    role?:
      | "tools.ozone.team.defs#roleAdmin"
      | "tools.ozone.team.defs#roleModerator"
      | "tools.ozone.team.defs#roleTriage"
      | (string & {});
  }
  type Output = ToolsOzoneTeamDefs.Member;
  interface Errors extends TypedBase {
    MemberNotFound: {};
  }
}

export declare interface Records extends RecordBase {
  "app.bsky.actor.profile": AppBskyActorProfile.Record;
  "app.bsky.feed.generator": AppBskyFeedGenerator.Record;
  "app.bsky.feed.like": AppBskyFeedLike.Record;
  "app.bsky.feed.post": AppBskyFeedPost.Record;
  "app.bsky.feed.postgate": AppBskyFeedPostgate.Record;
  "app.bsky.feed.repost": AppBskyFeedRepost.Record;
  "app.bsky.feed.threadgate": AppBskyFeedThreadgate.Record;
  "app.bsky.graph.block": AppBskyGraphBlock.Record;
  "app.bsky.graph.follow": AppBskyGraphFollow.Record;
  "app.bsky.graph.list": AppBskyGraphList.Record;
  "app.bsky.graph.listblock": AppBskyGraphListblock.Record;
  "app.bsky.graph.listitem": AppBskyGraphListitem.Record;
  "app.bsky.graph.starterpack": AppBskyGraphStarterpack.Record;
  "app.bsky.labeler.service": AppBskyLabelerService.Record;
  "chat.bsky.actor.declaration": ChatBskyActorDeclaration.Record;
  "com.atproto.lexicon.schema": ComAtprotoLexiconSchema.Record;
}

export declare interface Queries {
  "app.bsky.actor.getPreferences": {
    output: AppBskyActorGetPreferences.Output;
  };
  "app.bsky.actor.getProfile": {
    params: AppBskyActorGetProfile.Params;
    output: AppBskyActorGetProfile.Output;
  };
  "app.bsky.actor.getProfiles": {
    params: AppBskyActorGetProfiles.Params;
    output: AppBskyActorGetProfiles.Output;
  };
  "app.bsky.actor.getSuggestions": {
    params: AppBskyActorGetSuggestions.Params;
    output: AppBskyActorGetSuggestions.Output;
  };
  "app.bsky.actor.searchActors": {
    params: AppBskyActorSearchActors.Params;
    output: AppBskyActorSearchActors.Output;
  };
  "app.bsky.actor.searchActorsTypeahead": {
    params: AppBskyActorSearchActorsTypeahead.Params;
    output: AppBskyActorSearchActorsTypeahead.Output;
  };
  "app.bsky.feed.describeFeedGenerator": {
    output: AppBskyFeedDescribeFeedGenerator.Output;
  };
  "app.bsky.feed.getActorFeeds": {
    params: AppBskyFeedGetActorFeeds.Params;
    output: AppBskyFeedGetActorFeeds.Output;
  };
  "app.bsky.feed.getActorLikes": {
    params: AppBskyFeedGetActorLikes.Params;
    output: AppBskyFeedGetActorLikes.Output;
  };
  "app.bsky.feed.getAuthorFeed": {
    params: AppBskyFeedGetAuthorFeed.Params;
    output: AppBskyFeedGetAuthorFeed.Output;
  };
  "app.bsky.feed.getFeed": {
    params: AppBskyFeedGetFeed.Params;
    output: AppBskyFeedGetFeed.Output;
  };
  "app.bsky.feed.getFeedGenerator": {
    params: AppBskyFeedGetFeedGenerator.Params;
    output: AppBskyFeedGetFeedGenerator.Output;
  };
  "app.bsky.feed.getFeedGenerators": {
    params: AppBskyFeedGetFeedGenerators.Params;
    output: AppBskyFeedGetFeedGenerators.Output;
  };
  "app.bsky.feed.getFeedSkeleton": {
    params: AppBskyFeedGetFeedSkeleton.Params;
    output: AppBskyFeedGetFeedSkeleton.Output;
  };
  "app.bsky.feed.getLikes": {
    params: AppBskyFeedGetLikes.Params;
    output: AppBskyFeedGetLikes.Output;
  };
  "app.bsky.feed.getListFeed": {
    params: AppBskyFeedGetListFeed.Params;
    output: AppBskyFeedGetListFeed.Output;
  };
  "app.bsky.feed.getPosts": {
    params: AppBskyFeedGetPosts.Params;
    output: AppBskyFeedGetPosts.Output;
  };
  "app.bsky.feed.getPostThread": {
    params: AppBskyFeedGetPostThread.Params;
    output: AppBskyFeedGetPostThread.Output;
  };
  "app.bsky.feed.getQuotes": {
    params: AppBskyFeedGetQuotes.Params;
    output: AppBskyFeedGetQuotes.Output;
  };
  "app.bsky.feed.getRepostedBy": {
    params: AppBskyFeedGetRepostedBy.Params;
    output: AppBskyFeedGetRepostedBy.Output;
  };
  "app.bsky.feed.getSuggestedFeeds": {
    params: AppBskyFeedGetSuggestedFeeds.Params;
    output: AppBskyFeedGetSuggestedFeeds.Output;
  };
  "app.bsky.feed.getTimeline": {
    params: AppBskyFeedGetTimeline.Params;
    output: AppBskyFeedGetTimeline.Output;
  };
  "app.bsky.feed.searchPosts": {
    params: AppBskyFeedSearchPosts.Params;
    output: AppBskyFeedSearchPosts.Output;
  };
  "app.bsky.graph.getActorStarterPacks": {
    params: AppBskyGraphGetActorStarterPacks.Params;
    output: AppBskyGraphGetActorStarterPacks.Output;
  };
  "app.bsky.graph.getBlocks": {
    params: AppBskyGraphGetBlocks.Params;
    output: AppBskyGraphGetBlocks.Output;
  };
  "app.bsky.graph.getFollowers": {
    params: AppBskyGraphGetFollowers.Params;
    output: AppBskyGraphGetFollowers.Output;
  };
  "app.bsky.graph.getFollows": {
    params: AppBskyGraphGetFollows.Params;
    output: AppBskyGraphGetFollows.Output;
  };
  "app.bsky.graph.getKnownFollowers": {
    params: AppBskyGraphGetKnownFollowers.Params;
    output: AppBskyGraphGetKnownFollowers.Output;
  };
  "app.bsky.graph.getList": {
    params: AppBskyGraphGetList.Params;
    output: AppBskyGraphGetList.Output;
  };
  "app.bsky.graph.getListBlocks": {
    params: AppBskyGraphGetListBlocks.Params;
    output: AppBskyGraphGetListBlocks.Output;
  };
  "app.bsky.graph.getListMutes": {
    params: AppBskyGraphGetListMutes.Params;
    output: AppBskyGraphGetListMutes.Output;
  };
  "app.bsky.graph.getLists": {
    params: AppBskyGraphGetLists.Params;
    output: AppBskyGraphGetLists.Output;
  };
  "app.bsky.graph.getMutes": {
    params: AppBskyGraphGetMutes.Params;
    output: AppBskyGraphGetMutes.Output;
  };
  "app.bsky.graph.getRelationships": {
    params: AppBskyGraphGetRelationships.Params;
    output: AppBskyGraphGetRelationships.Output;
  };
  "app.bsky.graph.getStarterPack": {
    params: AppBskyGraphGetStarterPack.Params;
    output: AppBskyGraphGetStarterPack.Output;
  };
  "app.bsky.graph.getStarterPacks": {
    params: AppBskyGraphGetStarterPacks.Params;
    output: AppBskyGraphGetStarterPacks.Output;
  };
  "app.bsky.graph.getSuggestedFollowsByActor": {
    params: AppBskyGraphGetSuggestedFollowsByActor.Params;
    output: AppBskyGraphGetSuggestedFollowsByActor.Output;
  };
  "app.bsky.graph.searchStarterPacks": {
    params: AppBskyGraphSearchStarterPacks.Params;
    output: AppBskyGraphSearchStarterPacks.Output;
  };
  "app.bsky.labeler.getServices": {
    params: AppBskyLabelerGetServices.Params;
    output: AppBskyLabelerGetServices.Output;
  };
  "app.bsky.notification.getUnreadCount": {
    params: AppBskyNotificationGetUnreadCount.Params;
    output: AppBskyNotificationGetUnreadCount.Output;
  };
  "app.bsky.notification.listNotifications": {
    params: AppBskyNotificationListNotifications.Params;
    output: AppBskyNotificationListNotifications.Output;
  };
  "app.bsky.unspecced.getConfig": {
    output: AppBskyUnspeccedGetConfig.Output;
  };
  "app.bsky.unspecced.getPopularFeedGenerators": {
    params: AppBskyUnspeccedGetPopularFeedGenerators.Params;
    output: AppBskyUnspeccedGetPopularFeedGenerators.Output;
  };
  "app.bsky.unspecced.getSuggestionsSkeleton": {
    params: AppBskyUnspeccedGetSuggestionsSkeleton.Params;
    output: AppBskyUnspeccedGetSuggestionsSkeleton.Output;
  };
  "app.bsky.unspecced.getTaggedSuggestions": {
    output: AppBskyUnspeccedGetTaggedSuggestions.Output;
  };
  "app.bsky.unspecced.getTrendingTopics": {
    params: AppBskyUnspeccedGetTrendingTopics.Params;
    output: AppBskyUnspeccedGetTrendingTopics.Output;
  };
  "app.bsky.unspecced.searchActorsSkeleton": {
    params: AppBskyUnspeccedSearchActorsSkeleton.Params;
    output: AppBskyUnspeccedSearchActorsSkeleton.Output;
  };
  "app.bsky.unspecced.searchPostsSkeleton": {
    params: AppBskyUnspeccedSearchPostsSkeleton.Params;
    output: AppBskyUnspeccedSearchPostsSkeleton.Output;
  };
  "app.bsky.unspecced.searchStarterPacksSkeleton": {
    params: AppBskyUnspeccedSearchStarterPacksSkeleton.Params;
    output: AppBskyUnspeccedSearchStarterPacksSkeleton.Output;
  };
  "app.bsky.video.getJobStatus": {
    params: AppBskyVideoGetJobStatus.Params;
    output: AppBskyVideoGetJobStatus.Output;
  };
  "app.bsky.video.getUploadLimits": {
    output: AppBskyVideoGetUploadLimits.Output;
  };
  "chat.bsky.actor.exportAccountData": {
    output: ChatBskyActorExportAccountData.Output;
  };
  "chat.bsky.convo.getConvo": {
    params: ChatBskyConvoGetConvo.Params;
    output: ChatBskyConvoGetConvo.Output;
  };
  "chat.bsky.convo.getConvoAvailability": {
    params: ChatBskyConvoGetConvoAvailability.Params;
    output: ChatBskyConvoGetConvoAvailability.Output;
  };
  "chat.bsky.convo.getConvoForMembers": {
    params: ChatBskyConvoGetConvoForMembers.Params;
    output: ChatBskyConvoGetConvoForMembers.Output;
  };
  "chat.bsky.convo.getLog": {
    params: ChatBskyConvoGetLog.Params;
    output: ChatBskyConvoGetLog.Output;
  };
  "chat.bsky.convo.getMessages": {
    params: ChatBskyConvoGetMessages.Params;
    output: ChatBskyConvoGetMessages.Output;
  };
  "chat.bsky.convo.listConvos": {
    params: ChatBskyConvoListConvos.Params;
    output: ChatBskyConvoListConvos.Output;
  };
  "chat.bsky.moderation.getActorMetadata": {
    params: ChatBskyModerationGetActorMetadata.Params;
    output: ChatBskyModerationGetActorMetadata.Output;
  };
  "chat.bsky.moderation.getMessageContext": {
    params: ChatBskyModerationGetMessageContext.Params;
    output: ChatBskyModerationGetMessageContext.Output;
  };
  "com.atproto.admin.getAccountInfo": {
    params: ComAtprotoAdminGetAccountInfo.Params;
    output: ComAtprotoAdminGetAccountInfo.Output;
  };
  "com.atproto.admin.getAccountInfos": {
    params: ComAtprotoAdminGetAccountInfos.Params;
    output: ComAtprotoAdminGetAccountInfos.Output;
  };
  "com.atproto.admin.getInviteCodes": {
    params: ComAtprotoAdminGetInviteCodes.Params;
    output: ComAtprotoAdminGetInviteCodes.Output;
  };
  "com.atproto.admin.getSubjectStatus": {
    params: ComAtprotoAdminGetSubjectStatus.Params;
    output: ComAtprotoAdminGetSubjectStatus.Output;
  };
  "com.atproto.admin.searchAccounts": {
    params: ComAtprotoAdminSearchAccounts.Params;
    output: ComAtprotoAdminSearchAccounts.Output;
  };
  "com.atproto.identity.getRecommendedDidCredentials": {
    output: ComAtprotoIdentityGetRecommendedDidCredentials.Output;
  };
  "com.atproto.identity.resolveDid": {
    params: ComAtprotoIdentityResolveDid.Params;
    output: ComAtprotoIdentityResolveDid.Output;
  };
  "com.atproto.identity.resolveHandle": {
    params: ComAtprotoIdentityResolveHandle.Params;
    output: ComAtprotoIdentityResolveHandle.Output;
  };
  "com.atproto.identity.resolveIdentity": {
    params: ComAtprotoIdentityResolveIdentity.Params;
    output: ComAtprotoIdentityResolveIdentity.Output;
  };
  "com.atproto.label.queryLabels": {
    params: ComAtprotoLabelQueryLabels.Params;
    output: ComAtprotoLabelQueryLabels.Output;
  };
  "com.atproto.repo.describeRepo": {
    params: ComAtprotoRepoDescribeRepo.Params;
    output: ComAtprotoRepoDescribeRepo.Output;
  };
  "com.atproto.repo.getRecord": {
    params: ComAtprotoRepoGetRecord.Params;
    output: ComAtprotoRepoGetRecord.Output;
  };
  "com.atproto.repo.listMissingBlobs": {
    params: ComAtprotoRepoListMissingBlobs.Params;
    output: ComAtprotoRepoListMissingBlobs.Output;
  };
  "com.atproto.repo.listRecords": {
    params: ComAtprotoRepoListRecords.Params;
    output: ComAtprotoRepoListRecords.Output;
  };
  "com.atproto.server.checkAccountStatus": {
    output: ComAtprotoServerCheckAccountStatus.Output;
  };
  "com.atproto.server.describeServer": {
    output: ComAtprotoServerDescribeServer.Output;
  };
  "com.atproto.server.getAccountInviteCodes": {
    params: ComAtprotoServerGetAccountInviteCodes.Params;
    output: ComAtprotoServerGetAccountInviteCodes.Output;
  };
  "com.atproto.server.getServiceAuth": {
    params: ComAtprotoServerGetServiceAuth.Params;
    output: ComAtprotoServerGetServiceAuth.Output;
  };
  "com.atproto.server.getSession": {
    output: ComAtprotoServerGetSession.Output;
  };
  "com.atproto.server.listAppPasswords": {
    output: ComAtprotoServerListAppPasswords.Output;
  };
  "com.atproto.sync.getBlob": {
    params: ComAtprotoSyncGetBlob.Params;
    output: ComAtprotoSyncGetBlob.Output;
  };
  "com.atproto.sync.getBlocks": {
    params: ComAtprotoSyncGetBlocks.Params;
    output: ComAtprotoSyncGetBlocks.Output;
  };
  "com.atproto.sync.getCheckout": {
    params: ComAtprotoSyncGetCheckout.Params;
    output: ComAtprotoSyncGetCheckout.Output;
  };
  "com.atproto.sync.getHead": {
    params: ComAtprotoSyncGetHead.Params;
    output: ComAtprotoSyncGetHead.Output;
  };
  "com.atproto.sync.getLatestCommit": {
    params: ComAtprotoSyncGetLatestCommit.Params;
    output: ComAtprotoSyncGetLatestCommit.Output;
  };
  "com.atproto.sync.getRecord": {
    params: ComAtprotoSyncGetRecord.Params;
    output: ComAtprotoSyncGetRecord.Output;
  };
  "com.atproto.sync.getRepo": {
    params: ComAtprotoSyncGetRepo.Params;
    output: ComAtprotoSyncGetRepo.Output;
  };
  "com.atproto.sync.getRepoStatus": {
    params: ComAtprotoSyncGetRepoStatus.Params;
    output: ComAtprotoSyncGetRepoStatus.Output;
  };
  "com.atproto.sync.listBlobs": {
    params: ComAtprotoSyncListBlobs.Params;
    output: ComAtprotoSyncListBlobs.Output;
  };
  "com.atproto.sync.listRepos": {
    params: ComAtprotoSyncListRepos.Params;
    output: ComAtprotoSyncListRepos.Output;
  };
  "com.atproto.sync.listReposByCollection": {
    params: ComAtprotoSyncListReposByCollection.Params;
    output: ComAtprotoSyncListReposByCollection.Output;
  };
  "com.atproto.temp.checkSignupQueue": {
    output: ComAtprotoTempCheckSignupQueue.Output;
  };
  "com.atproto.temp.fetchLabels": {
    params: ComAtprotoTempFetchLabels.Params;
    output: ComAtprotoTempFetchLabels.Output;
  };
  "tools.ozone.communication.listTemplates": {
    output: ToolsOzoneCommunicationListTemplates.Output;
  };
  "tools.ozone.moderation.getEvent": {
    params: ToolsOzoneModerationGetEvent.Params;
    output: ToolsOzoneModerationGetEvent.Output;
  };
  "tools.ozone.moderation.getRecord": {
    params: ToolsOzoneModerationGetRecord.Params;
    output: ToolsOzoneModerationGetRecord.Output;
  };
  "tools.ozone.moderation.getRecords": {
    params: ToolsOzoneModerationGetRecords.Params;
    output: ToolsOzoneModerationGetRecords.Output;
  };
  "tools.ozone.moderation.getRepo": {
    params: ToolsOzoneModerationGetRepo.Params;
    output: ToolsOzoneModerationGetRepo.Output;
  };
  "tools.ozone.moderation.getReporterStats": {
    params: ToolsOzoneModerationGetReporterStats.Params;
    output: ToolsOzoneModerationGetReporterStats.Output;
  };
  "tools.ozone.moderation.getRepos": {
    params: ToolsOzoneModerationGetRepos.Params;
    output: ToolsOzoneModerationGetRepos.Output;
  };
  "tools.ozone.moderation.queryEvents": {
    params: ToolsOzoneModerationQueryEvents.Params;
    output: ToolsOzoneModerationQueryEvents.Output;
  };
  "tools.ozone.moderation.queryStatuses": {
    params: ToolsOzoneModerationQueryStatuses.Params;
    output: ToolsOzoneModerationQueryStatuses.Output;
  };
  "tools.ozone.moderation.searchRepos": {
    params: ToolsOzoneModerationSearchRepos.Params;
    output: ToolsOzoneModerationSearchRepos.Output;
  };
  "tools.ozone.server.getConfig": {
    output: ToolsOzoneServerGetConfig.Output;
  };
  "tools.ozone.set.getValues": {
    params: ToolsOzoneSetGetValues.Params;
    output: ToolsOzoneSetGetValues.Output;
  };
  "tools.ozone.set.querySets": {
    params: ToolsOzoneSetQuerySets.Params;
    output: ToolsOzoneSetQuerySets.Output;
  };
  "tools.ozone.setting.listOptions": {
    params: ToolsOzoneSettingListOptions.Params;
    output: ToolsOzoneSettingListOptions.Output;
  };
  "tools.ozone.signature.findCorrelation": {
    params: ToolsOzoneSignatureFindCorrelation.Params;
    output: ToolsOzoneSignatureFindCorrelation.Output;
  };
  "tools.ozone.signature.findRelatedAccounts": {
    params: ToolsOzoneSignatureFindRelatedAccounts.Params;
    output: ToolsOzoneSignatureFindRelatedAccounts.Output;
  };
  "tools.ozone.signature.searchAccounts": {
    params: ToolsOzoneSignatureSearchAccounts.Params;
    output: ToolsOzoneSignatureSearchAccounts.Output;
  };
  "tools.ozone.team.listMembers": {
    params: ToolsOzoneTeamListMembers.Params;
    output: ToolsOzoneTeamListMembers.Output;
  };
}

export declare interface Procedures {
  "app.bsky.actor.putPreferences": {
    input: AppBskyActorPutPreferences.Input;
  };
  "app.bsky.feed.sendInteractions": {
    input: AppBskyFeedSendInteractions.Input;
    output: AppBskyFeedSendInteractions.Output;
  };
  "app.bsky.graph.muteActor": {
    input: AppBskyGraphMuteActor.Input;
  };
  "app.bsky.graph.muteActorList": {
    input: AppBskyGraphMuteActorList.Input;
  };
  "app.bsky.graph.muteThread": {
    input: AppBskyGraphMuteThread.Input;
  };
  "app.bsky.graph.unmuteActor": {
    input: AppBskyGraphUnmuteActor.Input;
  };
  "app.bsky.graph.unmuteActorList": {
    input: AppBskyGraphUnmuteActorList.Input;
  };
  "app.bsky.graph.unmuteThread": {
    input: AppBskyGraphUnmuteThread.Input;
  };
  "app.bsky.notification.putPreferences": {
    input: AppBskyNotificationPutPreferences.Input;
  };
  "app.bsky.notification.registerPush": {
    input: AppBskyNotificationRegisterPush.Input;
  };
  "app.bsky.notification.updateSeen": {
    input: AppBskyNotificationUpdateSeen.Input;
  };
  "app.bsky.video.uploadVideo": {
    input: AppBskyVideoUploadVideo.Input;
    output: AppBskyVideoUploadVideo.Output;
  };
  "chat.bsky.actor.deleteAccount": {
    output: ChatBskyActorDeleteAccount.Output;
  };
  "chat.bsky.convo.acceptConvo": {
    input: ChatBskyConvoAcceptConvo.Input;
    output: ChatBskyConvoAcceptConvo.Output;
  };
  "chat.bsky.convo.deleteMessageForSelf": {
    input: ChatBskyConvoDeleteMessageForSelf.Input;
    output: ChatBskyConvoDeleteMessageForSelf.Output;
  };
  "chat.bsky.convo.leaveConvo": {
    input: ChatBskyConvoLeaveConvo.Input;
    output: ChatBskyConvoLeaveConvo.Output;
  };
  "chat.bsky.convo.muteConvo": {
    input: ChatBskyConvoMuteConvo.Input;
    output: ChatBskyConvoMuteConvo.Output;
  };
  "chat.bsky.convo.sendMessage": {
    input: ChatBskyConvoSendMessage.Input;
    output: ChatBskyConvoSendMessage.Output;
  };
  "chat.bsky.convo.sendMessageBatch": {
    input: ChatBskyConvoSendMessageBatch.Input;
    output: ChatBskyConvoSendMessageBatch.Output;
  };
  "chat.bsky.convo.unmuteConvo": {
    input: ChatBskyConvoUnmuteConvo.Input;
    output: ChatBskyConvoUnmuteConvo.Output;
  };
  "chat.bsky.convo.updateAllRead": {
    input: ChatBskyConvoUpdateAllRead.Input;
    output: ChatBskyConvoUpdateAllRead.Output;
  };
  "chat.bsky.convo.updateRead": {
    input: ChatBskyConvoUpdateRead.Input;
    output: ChatBskyConvoUpdateRead.Output;
  };
  "chat.bsky.moderation.updateActorAccess": {
    input: ChatBskyModerationUpdateActorAccess.Input;
  };
  "com.atproto.admin.deleteAccount": {
    input: ComAtprotoAdminDeleteAccount.Input;
  };
  "com.atproto.admin.disableAccountInvites": {
    input: ComAtprotoAdminDisableAccountInvites.Input;
  };
  "com.atproto.admin.disableInviteCodes": {
    input: ComAtprotoAdminDisableInviteCodes.Input;
  };
  "com.atproto.admin.enableAccountInvites": {
    input: ComAtprotoAdminEnableAccountInvites.Input;
  };
  "com.atproto.admin.sendEmail": {
    input: ComAtprotoAdminSendEmail.Input;
    output: ComAtprotoAdminSendEmail.Output;
  };
  "com.atproto.admin.updateAccountEmail": {
    input: ComAtprotoAdminUpdateAccountEmail.Input;
  };
  "com.atproto.admin.updateAccountHandle": {
    input: ComAtprotoAdminUpdateAccountHandle.Input;
  };
  "com.atproto.admin.updateAccountPassword": {
    input: ComAtprotoAdminUpdateAccountPassword.Input;
  };
  "com.atproto.admin.updateSubjectStatus": {
    input: ComAtprotoAdminUpdateSubjectStatus.Input;
    output: ComAtprotoAdminUpdateSubjectStatus.Output;
  };
  "com.atproto.identity.refreshIdentity": {
    input: ComAtprotoIdentityRefreshIdentity.Input;
    output: ComAtprotoIdentityRefreshIdentity.Output;
  };
  "com.atproto.identity.requestPlcOperationSignature": {};
  "com.atproto.identity.signPlcOperation": {
    input: ComAtprotoIdentitySignPlcOperation.Input;
    output: ComAtprotoIdentitySignPlcOperation.Output;
  };
  "com.atproto.identity.submitPlcOperation": {
    input: ComAtprotoIdentitySubmitPlcOperation.Input;
  };
  "com.atproto.identity.updateHandle": {
    input: ComAtprotoIdentityUpdateHandle.Input;
  };
  "com.atproto.moderation.createReport": {
    input: ComAtprotoModerationCreateReport.Input;
    output: ComAtprotoModerationCreateReport.Output;
  };
  "com.atproto.repo.applyWrites": {
    input: ComAtprotoRepoApplyWrites.Input;
    output: ComAtprotoRepoApplyWrites.Output;
  };
  "com.atproto.repo.createRecord": {
    input: ComAtprotoRepoCreateRecord.Input;
    output: ComAtprotoRepoCreateRecord.Output;
  };
  "com.atproto.repo.deleteRecord": {
    input: ComAtprotoRepoDeleteRecord.Input;
    output: ComAtprotoRepoDeleteRecord.Output;
  };
  "com.atproto.repo.importRepo": {
    input: ComAtprotoRepoImportRepo.Input;
  };
  "com.atproto.repo.putRecord": {
    input: ComAtprotoRepoPutRecord.Input;
    output: ComAtprotoRepoPutRecord.Output;
  };
  "com.atproto.repo.uploadBlob": {
    input: ComAtprotoRepoUploadBlob.Input;
    output: ComAtprotoRepoUploadBlob.Output;
  };
  "com.atproto.server.activateAccount": {};
  "com.atproto.server.confirmEmail": {
    input: ComAtprotoServerConfirmEmail.Input;
  };
  "com.atproto.server.createAccount": {
    input: ComAtprotoServerCreateAccount.Input;
    output: ComAtprotoServerCreateAccount.Output;
  };
  "com.atproto.server.createAppPassword": {
    input: ComAtprotoServerCreateAppPassword.Input;
    output: ComAtprotoServerCreateAppPassword.Output;
  };
  "com.atproto.server.createInviteCode": {
    input: ComAtprotoServerCreateInviteCode.Input;
    output: ComAtprotoServerCreateInviteCode.Output;
  };
  "com.atproto.server.createInviteCodes": {
    input: ComAtprotoServerCreateInviteCodes.Input;
    output: ComAtprotoServerCreateInviteCodes.Output;
  };
  "com.atproto.server.createSession": {
    input: ComAtprotoServerCreateSession.Input;
    output: ComAtprotoServerCreateSession.Output;
  };
  "com.atproto.server.deactivateAccount": {
    input: ComAtprotoServerDeactivateAccount.Input;
  };
  "com.atproto.server.deleteAccount": {
    input: ComAtprotoServerDeleteAccount.Input;
  };
  "com.atproto.server.deleteSession": {};
  "com.atproto.server.refreshSession": {
    output: ComAtprotoServerRefreshSession.Output;
  };
  "com.atproto.server.requestAccountDelete": {};
  "com.atproto.server.requestEmailConfirmation": {};
  "com.atproto.server.requestEmailUpdate": {
    output: ComAtprotoServerRequestEmailUpdate.Output;
  };
  "com.atproto.server.requestPasswordReset": {
    input: ComAtprotoServerRequestPasswordReset.Input;
  };
  "com.atproto.server.reserveSigningKey": {
    input: ComAtprotoServerReserveSigningKey.Input;
    output: ComAtprotoServerReserveSigningKey.Output;
  };
  "com.atproto.server.resetPassword": {
    input: ComAtprotoServerResetPassword.Input;
  };
  "com.atproto.server.revokeAppPassword": {
    input: ComAtprotoServerRevokeAppPassword.Input;
  };
  "com.atproto.server.updateEmail": {
    input: ComAtprotoServerUpdateEmail.Input;
  };
  "com.atproto.sync.notifyOfUpdate": {
    input: ComAtprotoSyncNotifyOfUpdate.Input;
  };
  "com.atproto.sync.requestCrawl": {
    input: ComAtprotoSyncRequestCrawl.Input;
  };
  "com.atproto.temp.addReservedHandle": {
    input: ComAtprotoTempAddReservedHandle.Input;
    output: ComAtprotoTempAddReservedHandle.Output;
  };
  "com.atproto.temp.requestPhoneVerification": {
    input: ComAtprotoTempRequestPhoneVerification.Input;
  };
  "tools.ozone.communication.createTemplate": {
    input: ToolsOzoneCommunicationCreateTemplate.Input;
    output: ToolsOzoneCommunicationCreateTemplate.Output;
  };
  "tools.ozone.communication.deleteTemplate": {
    input: ToolsOzoneCommunicationDeleteTemplate.Input;
  };
  "tools.ozone.communication.updateTemplate": {
    input: ToolsOzoneCommunicationUpdateTemplate.Input;
    output: ToolsOzoneCommunicationUpdateTemplate.Output;
  };
  "tools.ozone.moderation.emitEvent": {
    input: ToolsOzoneModerationEmitEvent.Input;
    output: ToolsOzoneModerationEmitEvent.Output;
  };
  "tools.ozone.set.addValues": {
    input: ToolsOzoneSetAddValues.Input;
  };
  "tools.ozone.set.deleteSet": {
    input: ToolsOzoneSetDeleteSet.Input;
    output: ToolsOzoneSetDeleteSet.Output;
  };
  "tools.ozone.set.deleteValues": {
    input: ToolsOzoneSetDeleteValues.Input;
  };
  "tools.ozone.set.upsertSet": {
    input: ToolsOzoneSetUpsertSet.Input;
    output: ToolsOzoneSetUpsertSet.Output;
  };
  "tools.ozone.setting.removeOptions": {
    input: ToolsOzoneSettingRemoveOptions.Input;
    output: ToolsOzoneSettingRemoveOptions.Output;
  };
  "tools.ozone.setting.upsertOption": {
    input: ToolsOzoneSettingUpsertOption.Input;
    output: ToolsOzoneSettingUpsertOption.Output;
  };
  "tools.ozone.team.addMember": {
    input: ToolsOzoneTeamAddMember.Input;
    output: ToolsOzoneTeamAddMember.Output;
  };
  "tools.ozone.team.deleteMember": {
    input: ToolsOzoneTeamDeleteMember.Input;
  };
  "tools.ozone.team.updateMember": {
    input: ToolsOzoneTeamUpdateMember.Input;
    output: ToolsOzoneTeamUpdateMember.Output;
  };
}

export declare interface Subscriptions {
  "com.atproto.label.subscribeLabels": {
    params: ComAtprotoLabelSubscribeLabels.Params;
    message: ComAtprotoLabelSubscribeLabels.Message;
    errors: ComAtprotoLabelSubscribeLabels.Errors;
  };
  "com.atproto.sync.subscribeRepos": {
    params: ComAtprotoSyncSubscribeRepos.Params;
    message: ComAtprotoSyncSubscribeRepos.Message;
    errors: ComAtprotoSyncSubscribeRepos.Errors;
  };
}
